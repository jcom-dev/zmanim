// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: calendar.sql

package sqlcgen

import (
	"context"
)

const getAllJewishEvents = `-- name: GetAllJewishEvents :many


SELECT
    je.id,
    je.code,
    je.name_hebrew,
    je.name_english,
    jet.key as event_type,
    je.duration_days_israel,
    je.duration_days_diaspora,
    fst.key as fast_start_type,
    parent_je.code as parent_event_code,
    je.sort_order
FROM jewish_events je
LEFT JOIN jewish_event_types jet ON je.event_type_id = jet.id
LEFT JOIN fast_start_types fst ON je.fast_start_type_id = fst.id
LEFT JOIN jewish_events parent_je ON je.parent_event_id = parent_je.id
ORDER BY je.sort_order, je.name_english
`

type GetAllJewishEventsRow struct {
	ID                   int32   `json:"id"`
	Code                 string  `json:"code"`
	NameHebrew           string  `json:"name_hebrew"`
	NameEnglish          string  `json:"name_english"`
	EventType            *string `json:"event_type"`
	DurationDaysIsrael   *int32  `json:"duration_days_israel"`
	DurationDaysDiaspora *int32  `json:"duration_days_diaspora"`
	FastStartType        *string `json:"fast_start_type"`
	ParentEventCode      *string `json:"parent_event_code"`
	SortOrder            *int32  `json:"sort_order"`
}

// Calendar and Jewish Events SQL Queries
// SQLc will generate type-safe Go code from these queries
// ============================================
// JEWISH EVENTS QUERIES
// ============================================
// Get all Jewish events with their type information
func (q *Queries) GetAllJewishEvents(ctx context.Context) ([]GetAllJewishEventsRow, error) {
	rows, err := q.db.Query(ctx, getAllJewishEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllJewishEventsRow{}
	for rows.Next() {
		var i GetAllJewishEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.NameHebrew,
			&i.NameEnglish,
			&i.EventType,
			&i.DurationDaysIsrael,
			&i.DurationDaysDiaspora,
			&i.FastStartType,
			&i.ParentEventCode,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJewishEventsByType = `-- name: GetJewishEventsByType :many
SELECT
    je.id,
    je.code,
    je.name_hebrew,
    je.name_english,
    jet.key as event_type,
    je.duration_days_israel,
    je.duration_days_diaspora,
    fst.key as fast_start_type,
    parent_je.code as parent_event_code,
    je.sort_order
FROM jewish_events je
LEFT JOIN jewish_event_types jet ON je.event_type_id = jet.id
LEFT JOIN fast_start_types fst ON je.fast_start_type_id = fst.id
LEFT JOIN jewish_events parent_je ON je.parent_event_id = parent_je.id
WHERE jet.key = $1
ORDER BY je.sort_order, je.name_english
`

type GetJewishEventsByTypeRow struct {
	ID                   int32   `json:"id"`
	Code                 string  `json:"code"`
	NameHebrew           string  `json:"name_hebrew"`
	NameEnglish          string  `json:"name_english"`
	EventType            *string `json:"event_type"`
	DurationDaysIsrael   *int32  `json:"duration_days_israel"`
	DurationDaysDiaspora *int32  `json:"duration_days_diaspora"`
	FastStartType        *string `json:"fast_start_type"`
	ParentEventCode      *string `json:"parent_event_code"`
	SortOrder            *int32  `json:"sort_order"`
}

// Get Jewish events filtered by event type
func (q *Queries) GetJewishEventsByType(ctx context.Context, key string) ([]GetJewishEventsByTypeRow, error) {
	rows, err := q.db.Query(ctx, getJewishEventsByType, key)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetJewishEventsByTypeRow{}
	for rows.Next() {
		var i GetJewishEventsByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.NameHebrew,
			&i.NameEnglish,
			&i.EventType,
			&i.DurationDaysIsrael,
			&i.DurationDaysDiaspora,
			&i.FastStartType,
			&i.ParentEventCode,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
