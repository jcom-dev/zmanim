// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: geo_hierarchy.sql

package sqlcgen

import (
	"context"
)

const deleteAllCountries = `-- name: DeleteAllCountries :exec
DELETE FROM geo_countries
`

func (q *Queries) DeleteAllCountries(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllCountries)
	return err
}

const deleteAllRegions = `-- name: DeleteAllRegions :exec
DELETE FROM geo_regions
`

func (q *Queries) DeleteAllRegions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllRegions)
	return err
}

const getContinents = `-- name: GetContinents :many


SELECT ct.id, ct.code, ct.name, COUNT(l.id) as locality_count
FROM geo_continents ct
JOIN geo_countries co ON co.continent_id = ct.id
JOIN geo_localities l ON l.country_id = co.id
GROUP BY ct.id, ct.code, ct.name
HAVING COUNT(l.id) > 0
ORDER BY ct.name
`

type GetContinentsRow struct {
	ID            int16  `json:"id"`
	Code          string `json:"code"`
	Name          string `json:"name"`
	LocalityCount int64  `json:"locality_count"`
}

// Cities SQL Queries (Geographic Hierarchy)
// Continent -> Country -> Region -> Locality
// ============================================================================
// Continents
// ============================================================================
// Count only localities with COMPLETE hierarchy chain (locality -> country -> continent)
// Filter out continents with 0 localities
func (q *Queries) GetContinents(ctx context.Context) ([]GetContinentsRow, error) {
	rows, err := q.db.Query(ctx, getContinents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetContinentsRow{}
	for rows.Next() {
		var i GetContinentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.LocalityCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountries = `-- name: GetCountries :many

SELECT
    co.id, co.code as country_code, co.code_iso3,
    COALESCE(
        (SELECT n.name FROM geo_names n
         WHERE n.entity_type = 'country' AND n.entity_id = co.id AND n.language_code = 'en'
         ORDER BY CASE n.name_type WHEN 'common' THEN 1 WHEN 'official' THEN 2 WHEN 'alternate' THEN 3 ELSE 4 END, n.id
         LIMIT 1),
        co.name
    ) as country,
    co.adm1_label, co.adm2_label, co.has_adm1, co.has_adm2, co.is_city_state,
    ct.code as continent_code, ct.name as continent
FROM geo_countries co
JOIN geo_continents ct ON co.continent_id = ct.id
ORDER BY COALESCE(
    (SELECT n.name FROM geo_names n
     WHERE n.entity_type = 'country' AND n.entity_id = co.id AND n.language_code = 'en'
     ORDER BY CASE n.name_type WHEN 'common' THEN 1 WHEN 'official' THEN 2 WHEN 'alternate' THEN 3 ELSE 4 END, n.id
     LIMIT 1),
    co.name
)
`

type GetCountriesRow struct {
	ID            int16   `json:"id"`
	CountryCode   string  `json:"country_code"`
	CodeIso3      *string `json:"code_iso3"`
	Country       string  `json:"country"`
	Adm1Label     *string `json:"adm1_label"`
	Adm2Label     *string `json:"adm2_label"`
	HasAdm1       *bool   `json:"has_adm1"`
	HasAdm2       *bool   `json:"has_adm2"`
	IsCityState   *bool   `json:"is_city_state"`
	ContinentCode string  `json:"continent_code"`
	Continent     string  `json:"continent"`
}

// ============================================================================
// Countries
// ============================================================================
// Returns English name if available, otherwise native name
// Uses subquery to get only one English name per country (prevents duplicates from multiple name entries)
// Prefers common/official names over primary (which may contain multi-script concatenation)
func (q *Queries) GetCountries(ctx context.Context) ([]GetCountriesRow, error) {
	rows, err := q.db.Query(ctx, getCountries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCountriesRow{}
	for rows.Next() {
		var i GetCountriesRow
		if err := rows.Scan(
			&i.ID,
			&i.CountryCode,
			&i.CodeIso3,
			&i.Country,
			&i.Adm1Label,
			&i.Adm2Label,
			&i.HasAdm1,
			&i.HasAdm2,
			&i.IsCityState,
			&i.ContinentCode,
			&i.Continent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountriesByContinent = `-- name: GetCountriesByContinent :many
SELECT
    co.id, co.code as country_code,
    COALESCE(
        (SELECT n.name FROM geo_names n
         WHERE n.entity_type = 'country' AND n.entity_id = co.id AND n.language_code = 'en'
         ORDER BY CASE n.name_type WHEN 'common' THEN 1 WHEN 'official' THEN 2 WHEN 'alternate' THEN 3 ELSE 4 END, n.id
         LIMIT 1),
        co.name
    ) as country,
    co.adm1_label, co.adm2_label, co.has_adm1, co.has_adm2,
    (SELECT COUNT(*) FROM geo_search_index s
     WHERE s.entity_type = 'locality' AND s.country_id = co.id)::bigint as locality_count
FROM geo_countries co
JOIN geo_continents ct ON co.continent_id = ct.id
WHERE ct.code = $1
  AND EXISTS (SELECT 1 FROM geo_search_index s WHERE s.entity_type = 'locality' AND s.country_id = co.id)
ORDER BY COALESCE(
    (SELECT n.name FROM geo_names n
     WHERE n.entity_type = 'country' AND n.entity_id = co.id AND n.language_code = 'en'
     ORDER BY CASE n.name_type WHEN 'common' THEN 1 WHEN 'official' THEN 2 WHEN 'alternate' THEN 3 ELSE 4 END, n.id
     LIMIT 1),
    co.name
)
`

type GetCountriesByContinentRow struct {
	ID            int16   `json:"id"`
	CountryCode   string  `json:"country_code"`
	Country       string  `json:"country"`
	Adm1Label     *string `json:"adm1_label"`
	Adm2Label     *string `json:"adm2_label"`
	HasAdm1       *bool   `json:"has_adm1"`
	HasAdm2       *bool   `json:"has_adm2"`
	LocalityCount int64   `json:"locality_count"`
}

// Count localities via geo_search_index (uses idx_geo_search_country for O(1) lookups)
// Filter out countries with 0 localities
// Returns English name if available, otherwise native name
// Prefers common/official names over primary (which may contain multi-script concatenation)
func (q *Queries) GetCountriesByContinent(ctx context.Context, code string) ([]GetCountriesByContinentRow, error) {
	rows, err := q.db.Query(ctx, getCountriesByContinent, code)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCountriesByContinentRow{}
	for rows.Next() {
		var i GetCountriesByContinentRow
		if err := rows.Scan(
			&i.ID,
			&i.CountryCode,
			&i.Country,
			&i.Adm1Label,
			&i.Adm2Label,
			&i.HasAdm1,
			&i.HasAdm2,
			&i.LocalityCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountryBoundaryGeoJSON = `-- name: GetCountryBoundaryGeoJSON :one

SELECT
    co.id, co.code, co.name,
    COALESCE(ST_AsGeoJSON(co.boundary)::text, '') as boundary_geojson,
    (co.boundary IS NOT NULL) as has_boundary
FROM geo_countries co
WHERE co.code = $1
`

type GetCountryBoundaryGeoJSONRow struct {
	ID              int16       `json:"id"`
	Code            string      `json:"code"`
	Name            string      `json:"name"`
	BoundaryGeojson interface{} `json:"boundary_geojson"`
	HasBoundary     interface{} `json:"has_boundary"`
}

// ============================================================================
// Boundary GeoJSON Queries (for map display)
// ============================================================================
// Returns country boundary as GeoJSON geometry string
// Returns empty string if no boundary exists
func (q *Queries) GetCountryBoundaryGeoJSON(ctx context.Context, code string) (GetCountryBoundaryGeoJSONRow, error) {
	row := q.db.QueryRow(ctx, getCountryBoundaryGeoJSON, code)
	var i GetCountryBoundaryGeoJSONRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.BoundaryGeojson,
		&i.HasBoundary,
	)
	return i, err
}

const getCountryByCode = `-- name: GetCountryByCode :one
SELECT
    co.id, co.code, co.code_iso3,
    COALESCE(
        (SELECT n.name FROM geo_names n
         WHERE n.entity_type = 'country' AND n.entity_id = co.id AND n.language_code = 'en'
         ORDER BY CASE n.name_type WHEN 'common' THEN 1 WHEN 'official' THEN 2 WHEN 'alternate' THEN 3 ELSE 4 END, n.id
         LIMIT 1),
        co.name
    ) as name,
    co.adm1_label, co.adm2_label, co.has_adm1, co.has_adm2, co.is_city_state,
    ct.id as continent_id, ct.code as continent_code, ct.name as continent
FROM geo_countries co
JOIN geo_continents ct ON co.continent_id = ct.id
WHERE co.code = $1
`

type GetCountryByCodeRow struct {
	ID            int16   `json:"id"`
	Code          string  `json:"code"`
	CodeIso3      *string `json:"code_iso3"`
	Name          string  `json:"name"`
	Adm1Label     *string `json:"adm1_label"`
	Adm2Label     *string `json:"adm2_label"`
	HasAdm1       *bool   `json:"has_adm1"`
	HasAdm2       *bool   `json:"has_adm2"`
	IsCityState   *bool   `json:"is_city_state"`
	ContinentID   int16   `json:"continent_id"`
	ContinentCode string  `json:"continent_code"`
	Continent     string  `json:"continent"`
}

// Returns English name if available, otherwise native name
// Prefers common/official names over primary (which may contain multi-script concatenation)
func (q *Queries) GetCountryByCode(ctx context.Context, code string) (GetCountryByCodeRow, error) {
	row := q.db.QueryRow(ctx, getCountryByCode, code)
	var i GetCountryByCodeRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.CodeIso3,
		&i.Name,
		&i.Adm1Label,
		&i.Adm2Label,
		&i.HasAdm1,
		&i.HasAdm2,
		&i.IsCityState,
		&i.ContinentID,
		&i.ContinentCode,
		&i.Continent,
	)
	return i, err
}

const getCountryByID = `-- name: GetCountryByID :one
SELECT
    co.id, co.code, co.code_iso3,
    COALESCE(
        (SELECT n.name FROM geo_names n
         WHERE n.entity_type = 'country' AND n.entity_id = co.id AND n.language_code = 'en'
         ORDER BY CASE n.name_type WHEN 'common' THEN 1 WHEN 'official' THEN 2 WHEN 'alternate' THEN 3 ELSE 4 END, n.id
         LIMIT 1),
        co.name
    ) as name,
    co.adm1_label, co.adm2_label, co.has_adm1, co.has_adm2, co.is_city_state,
    ct.id as continent_id, ct.code as continent_code, ct.name as continent
FROM geo_countries co
JOIN geo_continents ct ON co.continent_id = ct.id
WHERE co.id = $1
`

type GetCountryByIDRow struct {
	ID            int16   `json:"id"`
	Code          string  `json:"code"`
	CodeIso3      *string `json:"code_iso3"`
	Name          string  `json:"name"`
	Adm1Label     *string `json:"adm1_label"`
	Adm2Label     *string `json:"adm2_label"`
	HasAdm1       *bool   `json:"has_adm1"`
	HasAdm2       *bool   `json:"has_adm2"`
	IsCityState   *bool   `json:"is_city_state"`
	ContinentID   int16   `json:"continent_id"`
	ContinentCode string  `json:"continent_code"`
	Continent     string  `json:"continent"`
}

// Returns English name if available, otherwise native name
// Prefers common/official names over primary (which may contain multi-script concatenation)
func (q *Queries) GetCountryByID(ctx context.Context, id int16) (GetCountryByIDRow, error) {
	row := q.db.QueryRow(ctx, getCountryByID, id)
	var i GetCountryByIDRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.CodeIso3,
		&i.Name,
		&i.Adm1Label,
		&i.Adm2Label,
		&i.HasAdm1,
		&i.HasAdm2,
		&i.IsCityState,
		&i.ContinentID,
		&i.ContinentCode,
		&i.Continent,
	)
	return i, err
}

const getLocalityBoundaryGeoJSON = `-- name: GetLocalityBoundaryGeoJSON :one
WITH best_coords AS (
    SELECT DISTINCT ON (ll.locality_id)
        ll.locality_id,
        ll.latitude,
        ll.longitude
    FROM geo_locality_locations ll
    JOIN geo_data_sources ds ON ds.id = ll.source_id AND ds.is_active = true
    WHERE ll.publisher_id IS NULL AND ll.locality_id = $1
    ORDER BY ll.locality_id,
             CASE ds.key WHEN 'admin' THEN 1 ELSE 2 END,
             ds.priority
)
SELECT
    l.id, l.name,
    co.code as country_code, co.name as country_name,
    COALESCE(
        ST_AsGeoJSON(l.boundary)::text,
        CASE WHEN bc.latitude IS NOT NULL THEN
            '{"type":"Point","coordinates":[' || bc.longitude || ',' || bc.latitude || ']}'
        END
    ) as boundary_geojson,
    (l.boundary IS NOT NULL) as has_boundary,
    bc.latitude, bc.longitude, l.timezone
FROM geo_localities l
LEFT JOIN best_coords bc ON bc.locality_id = l.id
JOIN geo_countries co ON l.country_id = co.id
WHERE l.id = $1
`

type GetLocalityBoundaryGeoJSONRow struct {
	ID              int32       `json:"id"`
	Name            string      `json:"name"`
	CountryCode     string      `json:"country_code"`
	CountryName     string      `json:"country_name"`
	BoundaryGeojson interface{} `json:"boundary_geojson"`
	HasBoundary     interface{} `json:"has_boundary"`
	Latitude        *float64    `json:"latitude"`
	Longitude       *float64    `json:"longitude"`
	Timezone        string      `json:"timezone"`
}

// Returns locality boundary as GeoJSON geometry string (if exists)
// Also returns point geometry as fallback
// Coordinates resolved with priority: admin > default (system-wide only)
func (q *Queries) GetLocalityBoundaryGeoJSON(ctx context.Context, id int32) (GetLocalityBoundaryGeoJSONRow, error) {
	row := q.db.QueryRow(ctx, getLocalityBoundaryGeoJSON, id)
	var i GetLocalityBoundaryGeoJSONRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CountryCode,
		&i.CountryName,
		&i.BoundaryGeojson,
		&i.HasBoundary,
		&i.Latitude,
		&i.Longitude,
		&i.Timezone,
	)
	return i, err
}

const getNearestLocality = `-- name: GetNearestLocality :one

WITH best_coords AS (
    SELECT DISTINCT ON (ll.locality_id)
        ll.locality_id,
        ll.latitude,
        ll.longitude,
        ll.location
    FROM geo_locality_locations ll
    JOIN geo_data_sources ds ON ds.id = ll.source_id AND ds.is_active = true
    WHERE ll.publisher_id IS NULL  -- System-wide records only
    ORDER BY ll.locality_id,
             CASE ds.key WHEN 'admin' THEN 1 ELSE 2 END,  -- admin > default
             ds.priority
),
best_elevs AS (
    SELECT DISTINCT ON (le.locality_id)
        le.locality_id,
        le.elevation_m
    FROM geo_locality_elevations le
    JOIN geo_data_sources ds ON ds.id = le.source_id AND ds.is_active = true
    WHERE le.publisher_id IS NULL  -- System-wide records only
    ORDER BY le.locality_id,
             CASE ds.key WHEN 'admin' THEN 1 ELSE 2 END,  -- admin > default
             ds.priority
)
SELECT
    l.id, l.name,
    co.code as country_code, COALESCE(co_en.name, co.name) as country,
    s.inherited_region_id as region_id, r.code as region_code, CASE WHEN r.id IS NOT NULL THEN COALESCE(r_en.name, r.name) END as region,
    ct.code as continent_code, ct.name as continent,
    bc.latitude, bc.longitude, l.timezone,
    l.population, be.elevation_m,
    ST_Distance(bc.location, ST_SetSRID(ST_MakePoint($1::float8, $2::float8), 4326)::geography)::float8 as distance_meters
FROM geo_localities l
JOIN best_coords bc ON bc.locality_id = l.id
LEFT JOIN best_elevs be ON be.locality_id = l.id
JOIN geo_countries co ON l.country_id = co.id
LEFT JOIN geo_names co_en ON co_en.entity_type = 'country' AND co_en.entity_id = co.id AND co_en.language_code = 'en'
JOIN geo_continents ct ON co.continent_id = ct.id
LEFT JOIN geo_search_index s ON s.entity_type = 'locality' AND s.entity_id = l.id
LEFT JOIN geo_regions r ON s.inherited_region_id = r.id
LEFT JOIN geo_names r_en ON r_en.entity_type = 'region' AND r_en.entity_id = r.id AND r_en.language_code = 'en'
ORDER BY bc.location <-> ST_SetSRID(ST_MakePoint($1::float8, $2::float8), 4326)::geography
LIMIT 1
`

type GetNearestLocalityParams struct {
	Longitude float64 `json:"longitude"`
	Latitude  float64 `json:"latitude"`
}

type GetNearestLocalityRow struct {
	ID             int32       `json:"id"`
	Name           string      `json:"name"`
	CountryCode    string      `json:"country_code"`
	Country        string      `json:"country"`
	RegionID       *int32      `json:"region_id"`
	RegionCode     *string     `json:"region_code"`
	Region         interface{} `json:"region"`
	ContinentCode  string      `json:"continent_code"`
	Continent      string      `json:"continent"`
	Latitude       float64     `json:"latitude"`
	Longitude      float64     `json:"longitude"`
	Timezone       string      `json:"timezone"`
	Population     *int32      `json:"population"`
	ElevationM     *int32      `json:"elevation_m"`
	DistanceMeters float64     `json:"distance_meters"`
}

// ============================================================================
// Geolocation
// ============================================================================
// Find the nearest locality to given coordinates using PostGIS
// Returns English names if available, otherwise native names
// Uses geo_search_index.inherited_region_id for region resolution
// Coordinates resolved with priority: admin > default (system-wide only, no publisher context)
func (q *Queries) GetNearestLocality(ctx context.Context, arg GetNearestLocalityParams) (GetNearestLocalityRow, error) {
	row := q.db.QueryRow(ctx, getNearestLocality, arg.Longitude, arg.Latitude)
	var i GetNearestLocalityRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CountryCode,
		&i.Country,
		&i.RegionID,
		&i.RegionCode,
		&i.Region,
		&i.ContinentCode,
		&i.Continent,
		&i.Latitude,
		&i.Longitude,
		&i.Timezone,
		&i.Population,
		&i.ElevationM,
		&i.DistanceMeters,
	)
	return i, err
}

const getRegionBoundaryGeoJSON = `-- name: GetRegionBoundaryGeoJSON :one
SELECT
    r.id, r.code, r.name,
    co.code as country_code, co.name as country_name,
    COALESCE(ST_AsGeoJSON(r.boundary)::text, '') as boundary_geojson,
    (r.boundary IS NOT NULL) as has_boundary
FROM geo_regions r
JOIN geo_countries co ON r.country_id = co.id
WHERE r.id = $1
`

type GetRegionBoundaryGeoJSONRow struct {
	ID              int32       `json:"id"`
	Code            string      `json:"code"`
	Name            string      `json:"name"`
	CountryCode     string      `json:"country_code"`
	CountryName     string      `json:"country_name"`
	BoundaryGeojson interface{} `json:"boundary_geojson"`
	HasBoundary     interface{} `json:"has_boundary"`
}

// Returns region boundary as GeoJSON geometry string
// Returns empty string if no boundary exists
func (q *Queries) GetRegionBoundaryGeoJSON(ctx context.Context, id int32) (GetRegionBoundaryGeoJSONRow, error) {
	row := q.db.QueryRow(ctx, getRegionBoundaryGeoJSON, id)
	var i GetRegionBoundaryGeoJSONRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.CountryCode,
		&i.CountryName,
		&i.BoundaryGeojson,
		&i.HasBoundary,
	)
	return i, err
}

const getRegionByID = `-- name: GetRegionByID :one
SELECT
    r.id, r.code, r.name,
    co.id as country_id, co.code as country_code, co.name as country
FROM geo_regions r
JOIN geo_countries co ON r.country_id = co.id
WHERE r.id = $1
`

type GetRegionByIDRow struct {
	ID          int32  `json:"id"`
	Code        string `json:"code"`
	Name        string `json:"name"`
	CountryID   int16  `json:"country_id"`
	CountryCode string `json:"country_code"`
	Country     string `json:"country"`
}

func (q *Queries) GetRegionByID(ctx context.Context, id int32) (GetRegionByIDRow, error) {
	row := q.db.QueryRow(ctx, getRegionByID, id)
	var i GetRegionByIDRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.CountryID,
		&i.CountryCode,
		&i.Country,
	)
	return i, err
}

const getRegionsByCountry = `-- name: GetRegionsByCountry :many

SELECT r.id, r.code, r.name,
       (SELECT COUNT(*) FROM geo_search_index s
        WHERE s.entity_type = 'locality' AND s.inherited_region_id = r.id)::bigint as locality_count
FROM geo_regions r
JOIN geo_countries co ON r.country_id = co.id
WHERE co.code = $1
ORDER BY r.name
`

type GetRegionsByCountryRow struct {
	ID            int32  `json:"id"`
	Code          string `json:"code"`
	Name          string `json:"name"`
	LocalityCount int64  `json:"locality_count"`
}

// ============================================================================
// Regions (ADM1)
// ============================================================================
// Returns all regions for a country with their locality counts
// Uses geo_search_index.inherited_region_id for accurate locality counts
func (q *Queries) GetRegionsByCountry(ctx context.Context, code string) ([]GetRegionsByCountryRow, error) {
	rows, err := q.db.Query(ctx, getRegionsByCountry, code)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRegionsByCountryRow{}
	for rows.Next() {
		var i GetRegionsByCountryRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.LocalityCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopLocalitiesAsLocations = `-- name: GetTopLocalitiesAsLocations :many

WITH best_coords AS (
    SELECT DISTINCT ON (ll.locality_id)
        ll.locality_id,
        ll.latitude,
        ll.longitude
    FROM geo_locality_locations ll
    JOIN geo_data_sources ds ON ds.id = ll.source_id AND ds.is_active = true
    WHERE ll.publisher_id IS NULL  -- System-wide records only
    ORDER BY ll.locality_id,
             CASE ds.key WHEN 'admin' THEN 1 ELSE 2 END,  -- admin > default
             ds.priority
)
SELECT
    l.id, l.name,
    bc.latitude, bc.longitude, l.timezone
FROM geo_localities l
JOIN best_coords bc ON bc.locality_id = l.id
ORDER BY l.population DESC NULLS LAST, l.name
LIMIT $1
`

type GetTopLocalitiesAsLocationsRow struct {
	ID        int32   `json:"id"`
	Name      string  `json:"name"`
	Latitude  float64 `json:"latitude"`
	Longitude float64 `json:"longitude"`
	Timezone  string  `json:"timezone"`
}

// ============================================================================
// Location Picker
// ============================================================================
// Get top localities ordered by population for location picker
// Coordinates resolved with priority: admin > default (system-wide only)
func (q *Queries) GetTopLocalitiesAsLocations(ctx context.Context, limit int32) ([]GetTopLocalitiesAsLocationsRow, error) {
	rows, err := q.db.Query(ctx, getTopLocalitiesAsLocations, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopLocalitiesAsLocationsRow{}
	for rows.Next() {
		var i GetTopLocalitiesAsLocationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Latitude,
			&i.Longitude,
			&i.Timezone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertCountry = `-- name: InsertCountry :one

INSERT INTO geo_countries (code, code_iso3, name, continent_id, adm1_label, adm2_label, has_adm1, has_adm2, is_city_state)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id
`

type InsertCountryParams struct {
	Code        string  `json:"code"`
	CodeIso3    *string `json:"code_iso3"`
	Name        string  `json:"name"`
	ContinentID int16   `json:"continent_id"`
	Adm1Label   *string `json:"adm1_label"`
	Adm2Label   *string `json:"adm2_label"`
	HasAdm1     *bool   `json:"has_adm1"`
	HasAdm2     *bool   `json:"has_adm2"`
	IsCityState *bool   `json:"is_city_state"`
}

// ============================================================================
// Insert/Update Operations
// ============================================================================
func (q *Queries) InsertCountry(ctx context.Context, arg InsertCountryParams) (int16, error) {
	row := q.db.QueryRow(ctx, insertCountry,
		arg.Code,
		arg.CodeIso3,
		arg.Name,
		arg.ContinentID,
		arg.Adm1Label,
		arg.Adm2Label,
		arg.HasAdm1,
		arg.HasAdm2,
		arg.IsCityState,
	)
	var id int16
	err := row.Scan(&id)
	return id, err
}

const insertRegion = `-- name: InsertRegion :one
INSERT INTO geo_regions (country_id, continent_id, code, name)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type InsertRegionParams struct {
	CountryID   *int16 `json:"country_id"`
	ContinentID *int16 `json:"continent_id"`
	Code        string `json:"code"`
	Name        string `json:"name"`
}

func (q *Queries) InsertRegion(ctx context.Context, arg InsertRegionParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertRegion,
		arg.CountryID,
		arg.ContinentID,
		arg.Code,
		arg.Name,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const searchRegions = `-- name: SearchRegions :many
SELECT
    r.id, r.code, r.name,
    co.id as country_id, co.code as country_code, co.name as country,
    (SELECT COUNT(*) FROM geo_search_index s
     WHERE s.entity_type = 'locality' AND s.inherited_region_id = r.id)::bigint as locality_count
FROM geo_regions r
JOIN geo_countries co ON r.country_id = co.id
WHERE r.name ILIKE '%' || $1 || '%'
ORDER BY r.name
LIMIT $2
`

type SearchRegionsParams struct {
	Column1 *string `json:"column_1"`
	Limit   int32   `json:"limit"`
}

type SearchRegionsRow struct {
	ID            int32  `json:"id"`
	Code          string `json:"code"`
	Name          string `json:"name"`
	CountryID     int16  `json:"country_id"`
	CountryCode   string `json:"country_code"`
	Country       string `json:"country"`
	LocalityCount int64  `json:"locality_count"`
}

// Search regions by name with locality counts
// Uses geo_search_index.inherited_region_id for accurate locality counts
func (q *Queries) SearchRegions(ctx context.Context, arg SearchRegionsParams) ([]SearchRegionsRow, error) {
	rows, err := q.db.Query(ctx, searchRegions, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchRegionsRow{}
	for rows.Next() {
		var i SearchRegionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.CountryID,
			&i.CountryCode,
			&i.Country,
			&i.LocalityCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
