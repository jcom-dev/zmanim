// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: publisher_requests.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const approvePublisherRequest = `-- name: ApprovePublisherRequest :exec
UPDATE publisher_requests
SET
    status_id = (SELECT id FROM request_statuses WHERE key = 'approved'),
    reviewed_by = $2,
    reviewed_at = NOW()
WHERE publisher_requests.id = $1
`

type ApprovePublisherRequestParams struct {
	ID         int32   `json:"id"`
	ReviewedBy *string `json:"reviewed_by"`
}

// Mark a publisher request as approved
func (q *Queries) ApprovePublisherRequest(ctx context.Context, arg ApprovePublisherRequestParams) error {
	_, err := q.db.Exec(ctx, approvePublisherRequest, arg.ID, arg.ReviewedBy)
	return err
}

const checkExistingPublisherRequest = `-- name: CheckExistingPublisherRequest :one

SELECT COUNT(*) as count
FROM publisher_requests pr
JOIN request_statuses rs ON pr.status_id = rs.id
WHERE LOWER(pr.email) = LOWER($1)
  AND rs.key IN ('pending', 'approved')
`

// Publisher Request Queries
// These queries handle publisher registration requests (public submissions and admin review)
// Check if there's already a pending or approved request for this email
func (q *Queries) CheckExistingPublisherRequest(ctx context.Context, lower string) (int64, error) {
	row := q.db.QueryRow(ctx, checkExistingPublisherRequest, lower)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublisherRequestsByStatus = `-- name: CountPublisherRequestsByStatus :one
SELECT COUNT(*) as count
FROM publisher_requests pr
JOIN request_statuses rs ON pr.status_id = rs.id
WHERE rs.key = $1
`

// Count publisher requests by status
func (q *Queries) CountPublisherRequestsByStatus(ctx context.Context, key string) (int64, error) {
	row := q.db.QueryRow(ctx, countPublisherRequestsByStatus, key)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPublisherFromRequest = `-- name: CreatePublisherFromRequest :one
INSERT INTO publishers (name, slug, contact_email, description, status_id)
VALUES (
    $1,
    $2,
    $3,
    $4,
    (SELECT id FROM publisher_statuses WHERE key = 'pending')
)
RETURNING id, name, slug, contact_email, description, status_id, created_at
`

type CreatePublisherFromRequestParams struct {
	Name         string  `json:"name"`
	Slug         *string `json:"slug"`
	ContactEmail string  `json:"contact_email"`
	Description  *string `json:"description"`
}

type CreatePublisherFromRequestRow struct {
	ID           int32              `json:"id"`
	Name         string             `json:"name"`
	Slug         *string            `json:"slug"`
	ContactEmail string             `json:"contact_email"`
	Description  *string            `json:"description"`
	StatusID     int16              `json:"status_id"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

// Create a new publisher from an approved request
func (q *Queries) CreatePublisherFromRequest(ctx context.Context, arg CreatePublisherFromRequestParams) (CreatePublisherFromRequestRow, error) {
	row := q.db.QueryRow(ctx, createPublisherFromRequest,
		arg.Name,
		arg.Slug,
		arg.ContactEmail,
		arg.Description,
	)
	var i CreatePublisherFromRequestRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.ContactEmail,
		&i.Description,
		&i.StatusID,
		&i.CreatedAt,
	)
	return i, err
}

const createPublisherRequest = `-- name: CreatePublisherRequest :one
INSERT INTO publisher_requests (name, email, organization, message, status_id)
VALUES (
    $1,
    $2,
    $3,
    $4,
    (SELECT id FROM request_statuses WHERE key = 'pending')
)
RETURNING id, name, email, organization, message, status_id, created_at
`

type CreatePublisherRequestParams struct {
	Name         string  `json:"name"`
	Email        string  `json:"email"`
	Organization *string `json:"organization"`
	Message      *string `json:"message"`
}

type CreatePublisherRequestRow struct {
	ID           int32              `json:"id"`
	Name         string             `json:"name"`
	Email        string             `json:"email"`
	Organization *string            `json:"organization"`
	Message      *string            `json:"message"`
	StatusID     int16              `json:"status_id"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

// Insert a new publisher registration request
func (q *Queries) CreatePublisherRequest(ctx context.Context, arg CreatePublisherRequestParams) (CreatePublisherRequestRow, error) {
	row := q.db.QueryRow(ctx, createPublisherRequest,
		arg.Name,
		arg.Email,
		arg.Organization,
		arg.Message,
	)
	var i CreatePublisherRequestRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Organization,
		&i.Message,
		&i.StatusID,
		&i.CreatedAt,
	)
	return i, err
}

const getPublisherRequestByID = `-- name: GetPublisherRequestByID :one
SELECT
    pr.id,
    pr.name,
    pr.email,
    pr.organization,
    pr.message,
    pr.status_id,
    rs.key as status,
    pr.reviewed_by,
    pr.reviewed_at,
    pr.created_at
FROM publisher_requests pr
JOIN request_statuses rs ON pr.status_id = rs.id
WHERE pr.id = $1
`

type GetPublisherRequestByIDRow struct {
	ID           int32              `json:"id"`
	Name         string             `json:"name"`
	Email        string             `json:"email"`
	Organization *string            `json:"organization"`
	Message      *string            `json:"message"`
	StatusID     int16              `json:"status_id"`
	Status       string             `json:"status"`
	ReviewedBy   *string            `json:"reviewed_by"`
	ReviewedAt   pgtype.Timestamptz `json:"reviewed_at"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

// Get a specific publisher request by ID
func (q *Queries) GetPublisherRequestByID(ctx context.Context, id int32) (GetPublisherRequestByIDRow, error) {
	row := q.db.QueryRow(ctx, getPublisherRequestByID, id)
	var i GetPublisherRequestByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Organization,
		&i.Message,
		&i.StatusID,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getPublisherRequestsByStatus = `-- name: GetPublisherRequestsByStatus :many
SELECT
    pr.id,
    pr.name,
    pr.email,
    pr.organization,
    pr.message,
    pr.status_id,
    rs.key as status,
    pr.reviewed_by,
    pr.reviewed_at,
    pr.created_at
FROM publisher_requests pr
JOIN request_statuses rs ON pr.status_id = rs.id
WHERE rs.key = $1
ORDER BY pr.created_at DESC
`

type GetPublisherRequestsByStatusRow struct {
	ID           int32              `json:"id"`
	Name         string             `json:"name"`
	Email        string             `json:"email"`
	Organization *string            `json:"organization"`
	Message      *string            `json:"message"`
	StatusID     int16              `json:"status_id"`
	Status       string             `json:"status"`
	ReviewedBy   *string            `json:"reviewed_by"`
	ReviewedAt   pgtype.Timestamptz `json:"reviewed_at"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

// Get publisher requests filtered by status
func (q *Queries) GetPublisherRequestsByStatus(ctx context.Context, key string) ([]GetPublisherRequestsByStatusRow, error) {
	rows, err := q.db.Query(ctx, getPublisherRequestsByStatus, key)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherRequestsByStatusRow{}
	for rows.Next() {
		var i GetPublisherRequestsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Organization,
			&i.Message,
			&i.StatusID,
			&i.Status,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectPublisherRequest = `-- name: RejectPublisherRequest :exec
UPDATE publisher_requests
SET
    status_id = (SELECT id FROM request_statuses WHERE key = 'rejected'),
    reviewed_by = $2,
    reviewed_at = NOW()
WHERE publisher_requests.id = $1
`

type RejectPublisherRequestParams struct {
	ID         int32   `json:"id"`
	ReviewedBy *string `json:"reviewed_by"`
}

// Mark a publisher request as rejected
func (q *Queries) RejectPublisherRequest(ctx context.Context, arg RejectPublisherRequestParams) error {
	_, err := q.db.Exec(ctx, rejectPublisherRequest, arg.ID, arg.ReviewedBy)
	return err
}
