// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: publishers.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const countPublishers = `-- name: CountPublishers :one
SELECT COUNT(*)
FROM publishers
`

func (q *Queries) CountPublishers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countPublishers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVerifiedPublishers = `-- name: CountVerifiedPublishers :one
SELECT COUNT(*)
FROM publishers
WHERE is_verified = true AND deleted_at IS NULL
`

// Count total verified/active publishers
func (q *Queries) CountVerifiedPublishers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countVerifiedPublishers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPublisher = `-- name: CreatePublisher :one
WITH inserted AS (
    INSERT INTO publishers (name, contact_email, status_id, clerk_user_id)
    VALUES ($1, $2, $3, $4)
    RETURNING id, clerk_user_id, name, contact_email, description, bio,
              website, logo_url, logo_data, status_id, created_at, updated_at
)
SELECT i.id, i.clerk_user_id, i.name, i.contact_email, i.description, i.bio,
       i.website, i.logo_url, i.logo_data, i.status_id,
       ps.key as status_key,
       ps.display_name_hebrew as status_display_hebrew,
       ps.display_name_english as status_display_english,
       i.created_at, i.updated_at
FROM inserted i
JOIN publisher_statuses ps ON ps.id = i.status_id
`

type CreatePublisherParams struct {
	Name         string  `json:"name"`
	ContactEmail string  `json:"contact_email"`
	StatusID     int16   `json:"status_id"`
	ClerkUserID  *string `json:"clerk_user_id"`
}

type CreatePublisherRow struct {
	ID                   int32              `json:"id"`
	ClerkUserID          *string            `json:"clerk_user_id"`
	Name                 string             `json:"name"`
	ContactEmail         string             `json:"contact_email"`
	Description          *string            `json:"description"`
	Bio                  *string            `json:"bio"`
	Website              *string            `json:"website"`
	LogoUrl              *string            `json:"logo_url"`
	LogoData             *string            `json:"logo_data"`
	StatusID             int16              `json:"status_id"`
	StatusKey            string             `json:"status_key"`
	StatusDisplayHebrew  string             `json:"status_display_hebrew"`
	StatusDisplayEnglish string             `json:"status_display_english"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreatePublisher(ctx context.Context, arg CreatePublisherParams) (CreatePublisherRow, error) {
	row := q.db.QueryRow(ctx, createPublisher,
		arg.Name,
		arg.ContactEmail,
		arg.StatusID,
		arg.ClerkUserID,
	)
	var i CreatePublisherRow
	err := row.Scan(
		&i.ID,
		&i.ClerkUserID,
		&i.Name,
		&i.ContactEmail,
		&i.Description,
		&i.Bio,
		&i.Website,
		&i.LogoUrl,
		&i.LogoData,
		&i.StatusID,
		&i.StatusKey,
		&i.StatusDisplayHebrew,
		&i.StatusDisplayEnglish,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPublisherFromImport = `-- name: CreatePublisherFromImport :one
INSERT INTO publishers (name, contact_email, website, description, bio, status_id)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    (SELECT id FROM publisher_statuses WHERE key = 'pending')
)
RETURNING id, name
`

type CreatePublisherFromImportParams struct {
	Name         string  `json:"name"`
	ContactEmail string  `json:"contact_email"`
	Website      *string `json:"website"`
	Description  *string `json:"description"`
	Bio          *string `json:"bio"`
}

type CreatePublisherFromImportRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) CreatePublisherFromImport(ctx context.Context, arg CreatePublisherFromImportParams) (CreatePublisherFromImportRow, error) {
	row := q.db.QueryRow(ctx, createPublisherFromImport,
		arg.Name,
		arg.ContactEmail,
		arg.Website,
		arg.Description,
		arg.Bio,
	)
	var i CreatePublisherFromImportRow
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const deletePendingInvitation = `-- name: DeletePendingInvitation :execresult
DELETE FROM publisher_invitations
WHERE id = $1
`

func (q *Queries) DeletePendingInvitation(ctx context.Context, id int32) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, deletePendingInvitation, id)
}

const deletePublisher = `-- name: DeletePublisher :exec
DELETE FROM publishers
WHERE id = $1
`

func (q *Queries) DeletePublisher(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deletePublisher, id)
	return err
}

const getAccessiblePublishersByClerkUserID = `-- name: GetAccessiblePublishersByClerkUserID :one
SELECT id::text as id, name,
       (SELECT key FROM publisher_statuses WHERE id = p.status_id) as status_key
FROM publishers p
WHERE clerk_user_id = $1
`

type GetAccessiblePublishersByClerkUserIDRow struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	StatusKey string `json:"status_key"`
}

func (q *Queries) GetAccessiblePublishersByClerkUserID(ctx context.Context, clerkUserID *string) (GetAccessiblePublishersByClerkUserIDRow, error) {
	row := q.db.QueryRow(ctx, getAccessiblePublishersByClerkUserID, clerkUserID)
	var i GetAccessiblePublishersByClerkUserIDRow
	err := row.Scan(&i.ID, &i.Name, &i.StatusKey)
	return i, err
}

const getAccessiblePublishersByIDs = `-- name: GetAccessiblePublishersByIDs :many
SELECT id::text as id, name,
       (SELECT key FROM publisher_statuses WHERE id = p.status_id) as status_key
FROM publishers p
WHERE id = ANY($1::int[])
ORDER BY name
`

type GetAccessiblePublishersByIDsRow struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	StatusKey string `json:"status_key"`
}

func (q *Queries) GetAccessiblePublishersByIDs(ctx context.Context, dollar_1 []int32) ([]GetAccessiblePublishersByIDsRow, error) {
	rows, err := q.db.Query(ctx, getAccessiblePublishersByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAccessiblePublishersByIDsRow{}
	for rows.Next() {
		var i GetAccessiblePublishersByIDsRow
		if err := rows.Scan(&i.ID, &i.Name, &i.StatusKey); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDefaultPublisherWithAlgorithm = `-- name: GetDefaultPublisherWithAlgorithm :one
SELECT
    p.id as publisher_id,
    p.name as publisher_name,
    COALESCE(p.description, '') as publisher_description,
    p.website as publisher_website,
    p.contact_email as publisher_email,
    p.logo_url as publisher_logo_url,
    p.is_verified as publisher_is_verified,
    0 as publisher_subscriber_count,
    p.created_at as publisher_created_at,
    p.updated_at as publisher_updated_at,
    a.id as algorithm_id,
    a.name as algorithm_name,
    COALESCE(a.description, '') as algorithm_description,
    '1.0' as algorithm_version,
    COALESCE(a.configuration::text, '{}')::jsonb as algorithm_configuration,
    astatus.key = 'active' as algorithm_is_active
FROM publishers p
JOIN algorithms a ON p.id = a.publisher_id
JOIN algorithm_statuses astatus ON astatus.id = a.status_id
WHERE p.is_verified = true
  AND astatus.key = 'active'
  AND p.deleted_at IS NULL
ORDER BY p.name
LIMIT 1
`

type GetDefaultPublisherWithAlgorithmRow struct {
	PublisherID              int32              `json:"publisher_id"`
	PublisherName            string             `json:"publisher_name"`
	PublisherDescription     string             `json:"publisher_description"`
	PublisherWebsite         *string            `json:"publisher_website"`
	PublisherEmail           string             `json:"publisher_email"`
	PublisherLogoUrl         *string            `json:"publisher_logo_url"`
	PublisherIsVerified      bool               `json:"publisher_is_verified"`
	PublisherSubscriberCount int32              `json:"publisher_subscriber_count"`
	PublisherCreatedAt       pgtype.Timestamptz `json:"publisher_created_at"`
	PublisherUpdatedAt       pgtype.Timestamptz `json:"publisher_updated_at"`
	AlgorithmID              int32              `json:"algorithm_id"`
	AlgorithmName            string             `json:"algorithm_name"`
	AlgorithmDescription     string             `json:"algorithm_description"`
	AlgorithmVersion         string             `json:"algorithm_version"`
	AlgorithmConfiguration   []byte             `json:"algorithm_configuration"`
	AlgorithmIsActive        bool               `json:"algorithm_is_active"`
}

// Get the default publisher (highest subscriber count) with their active algorithm
func (q *Queries) GetDefaultPublisherWithAlgorithm(ctx context.Context) (GetDefaultPublisherWithAlgorithmRow, error) {
	row := q.db.QueryRow(ctx, getDefaultPublisherWithAlgorithm)
	var i GetDefaultPublisherWithAlgorithmRow
	err := row.Scan(
		&i.PublisherID,
		&i.PublisherName,
		&i.PublisherDescription,
		&i.PublisherWebsite,
		&i.PublisherEmail,
		&i.PublisherLogoUrl,
		&i.PublisherIsVerified,
		&i.PublisherSubscriberCount,
		&i.PublisherCreatedAt,
		&i.PublisherUpdatedAt,
		&i.AlgorithmID,
		&i.AlgorithmName,
		&i.AlgorithmDescription,
		&i.AlgorithmVersion,
		&i.AlgorithmConfiguration,
		&i.AlgorithmIsActive,
	)
	return i, err
}

const getInvitationForResend = `-- name: GetInvitationForResend :one
SELECT pi.publisher_id, pi.email, pi.token
FROM publisher_invitations pi
JOIN publishers p ON pi.publisher_id = p.id
WHERE pi.id = $1
`

type GetInvitationForResendRow struct {
	PublisherID int32  `json:"publisher_id"`
	Email       string `json:"email"`
	Token       string `json:"token"`
}

func (q *Queries) GetInvitationForResend(ctx context.Context, id int32) (GetInvitationForResendRow, error) {
	row := q.db.QueryRow(ctx, getInvitationForResend, id)
	var i GetInvitationForResendRow
	err := row.Scan(&i.PublisherID, &i.Email, &i.Token)
	return i, err
}

const getPublisherAlgorithmSummary = `-- name: GetPublisherAlgorithmSummary :one
SELECT
    COUNT(*)::int as total_count,
    COUNT(*) FILTER (WHERE is_published)::int as published_count,
    TO_CHAR(MAX(updated_at), 'YYYY-MM-DD"T"HH24:MI:SS"Z"') as updated_at
FROM publisher_zmanim
WHERE publisher_id = $1 AND deleted_at IS NULL
`

type GetPublisherAlgorithmSummaryRow struct {
	TotalCount     int32  `json:"total_count"`
	PublishedCount int32  `json:"published_count"`
	UpdatedAt      string `json:"updated_at"`
}

// Returns zmanim counts from publisher_zmanim table
func (q *Queries) GetPublisherAlgorithmSummary(ctx context.Context, publisherID int32) (GetPublisherAlgorithmSummaryRow, error) {
	row := q.db.QueryRow(ctx, getPublisherAlgorithmSummary, publisherID)
	var i GetPublisherAlgorithmSummaryRow
	err := row.Scan(&i.TotalCount, &i.PublishedCount, &i.UpdatedAt)
	return i, err
}

const getPublisherBasic = `-- name: GetPublisherBasic :one
SELECT p.id, p.name, p.status_id,
       ps.key as status_key,
       ps.display_name_hebrew as status_display_hebrew,
       ps.display_name_english as status_display_english
FROM publishers p
JOIN publisher_statuses ps ON ps.id = p.status_id
WHERE p.id = $1
`

type GetPublisherBasicRow struct {
	ID                   int32  `json:"id"`
	Name                 string `json:"name"`
	StatusID             int16  `json:"status_id"`
	StatusKey            string `json:"status_key"`
	StatusDisplayHebrew  string `json:"status_display_hebrew"`
	StatusDisplayEnglish string `json:"status_display_english"`
}

func (q *Queries) GetPublisherBasic(ctx context.Context, id int32) (GetPublisherBasicRow, error) {
	row := q.db.QueryRow(ctx, getPublisherBasic, id)
	var i GetPublisherBasicRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StatusID,
		&i.StatusKey,
		&i.StatusDisplayHebrew,
		&i.StatusDisplayEnglish,
	)
	return i, err
}

const getPublisherBasicByClerkUserID = `-- name: GetPublisherBasicByClerkUserID :one
SELECT p.id, p.name, p.status_id,
       ps.key as status_key,
       ps.display_name_hebrew as status_display_hebrew,
       ps.display_name_english as status_display_english
FROM publishers p
JOIN publisher_statuses ps ON ps.id = p.status_id
WHERE p.clerk_user_id = $1
`

type GetPublisherBasicByClerkUserIDRow struct {
	ID                   int32  `json:"id"`
	Name                 string `json:"name"`
	StatusID             int16  `json:"status_id"`
	StatusKey            string `json:"status_key"`
	StatusDisplayHebrew  string `json:"status_display_hebrew"`
	StatusDisplayEnglish string `json:"status_display_english"`
}

func (q *Queries) GetPublisherBasicByClerkUserID(ctx context.Context, clerkUserID *string) (GetPublisherBasicByClerkUserIDRow, error) {
	row := q.db.QueryRow(ctx, getPublisherBasicByClerkUserID, clerkUserID)
	var i GetPublisherBasicByClerkUserIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StatusID,
		&i.StatusKey,
		&i.StatusDisplayHebrew,
		&i.StatusDisplayEnglish,
	)
	return i, err
}

const getPublisherByClerkUserID = `-- name: GetPublisherByClerkUserID :one
SELECT id
FROM publishers
WHERE clerk_user_id = $1
`

func (q *Queries) GetPublisherByClerkUserID(ctx context.Context, clerkUserID *string) (int32, error) {
	row := q.db.QueryRow(ctx, getPublisherByClerkUserID, clerkUserID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getPublisherByID = `-- name: GetPublisherByID :one

SELECT p.id, p.clerk_user_id, p.name, p.contact_email, p.description, p.bio,
       p.website, p.logo_url, p.logo_data, p.status_id, p.is_global,
       ps.key as status_key,
       ps.display_name_hebrew as status_display_hebrew,
       ps.display_name_english as status_display_english,
       p.created_at, p.updated_at
FROM publishers p
JOIN publisher_statuses ps ON ps.id = p.status_id
WHERE p.id = $1
`

type GetPublisherByIDRow struct {
	ID                   int32              `json:"id"`
	ClerkUserID          *string            `json:"clerk_user_id"`
	Name                 string             `json:"name"`
	ContactEmail         string             `json:"contact_email"`
	Description          *string            `json:"description"`
	Bio                  *string            `json:"bio"`
	Website              *string            `json:"website"`
	LogoUrl              *string            `json:"logo_url"`
	LogoData             *string            `json:"logo_data"`
	StatusID             int16              `json:"status_id"`
	IsGlobal             bool               `json:"is_global"`
	StatusKey            string             `json:"status_key"`
	StatusDisplayHebrew  string             `json:"status_display_hebrew"`
	StatusDisplayEnglish string             `json:"status_display_english"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

// Publishers SQL Queries
// SQLc will generate type-safe Go code from these queries
func (q *Queries) GetPublisherByID(ctx context.Context, id int32) (GetPublisherByIDRow, error) {
	row := q.db.QueryRow(ctx, getPublisherByID, id)
	var i GetPublisherByIDRow
	err := row.Scan(
		&i.ID,
		&i.ClerkUserID,
		&i.Name,
		&i.ContactEmail,
		&i.Description,
		&i.Bio,
		&i.Website,
		&i.LogoUrl,
		&i.LogoData,
		&i.StatusID,
		&i.IsGlobal,
		&i.StatusKey,
		&i.StatusDisplayHebrew,
		&i.StatusDisplayEnglish,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPublisherByIDLegacy = `-- name: GetPublisherByIDLegacy :one
SELECT id, name, COALESCE(description, '') as description, website, contact_email,
       logo_url, is_verified,
       0 as subscriber_count,
       created_at, updated_at
FROM publishers
WHERE id = $1 AND deleted_at IS NULL
`

type GetPublisherByIDLegacyRow struct {
	ID              int32              `json:"id"`
	Name            string             `json:"name"`
	Description     string             `json:"description"`
	Website         *string            `json:"website"`
	ContactEmail    string             `json:"contact_email"`
	LogoUrl         *string            `json:"logo_url"`
	IsVerified      bool               `json:"is_verified"`
	SubscriberCount int32              `json:"subscriber_count"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

// Get publisher by ID (legacy format)
func (q *Queries) GetPublisherByIDLegacy(ctx context.Context, id int32) (GetPublisherByIDLegacyRow, error) {
	row := q.db.QueryRow(ctx, getPublisherByIDLegacy, id)
	var i GetPublisherByIDLegacyRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Website,
		&i.ContactEmail,
		&i.LogoUrl,
		&i.IsVerified,
		&i.SubscriberCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPublisherCalculationSettings = `-- name: GetPublisherCalculationSettings :one
SELECT id, ignore_elevation, transliteration_style
FROM publishers
WHERE id = $1 AND deleted_at IS NULL
`

type GetPublisherCalculationSettingsRow struct {
	ID                   int32  `json:"id"`
	IgnoreElevation      bool   `json:"ignore_elevation"`
	TransliterationStyle string `json:"transliteration_style"`
}

func (q *Queries) GetPublisherCalculationSettings(ctx context.Context, id int32) (GetPublisherCalculationSettingsRow, error) {
	row := q.db.QueryRow(ctx, getPublisherCalculationSettings, id)
	var i GetPublisherCalculationSettingsRow
	err := row.Scan(&i.ID, &i.IgnoreElevation, &i.TransliterationStyle)
	return i, err
}

const getPublisherCoverageCount = `-- name: GetPublisherCoverageCount :one
SELECT COUNT(*)
FROM publisher_coverage
WHERE publisher_id = $1 AND is_active = true
`

func (q *Queries) GetPublisherCoverageCount(ctx context.Context, publisherID int32) (int64, error) {
	row := q.db.QueryRow(ctx, getPublisherCoverageCount, publisherID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPublisherDashboardSummary = `-- name: GetPublisherDashboardSummary :one
SELECT
    p.name,
    p.is_verified,
    ps.key as status_key,
    ps.display_name_hebrew as status_display_hebrew,
    ps.display_name_english as status_display_english
FROM publishers p
JOIN publisher_statuses ps ON ps.id = p.status_id
WHERE p.id = $1
`

type GetPublisherDashboardSummaryRow struct {
	Name                 string `json:"name"`
	IsVerified           bool   `json:"is_verified"`
	StatusKey            string `json:"status_key"`
	StatusDisplayHebrew  string `json:"status_display_hebrew"`
	StatusDisplayEnglish string `json:"status_display_english"`
}

func (q *Queries) GetPublisherDashboardSummary(ctx context.Context, id int32) (GetPublisherDashboardSummaryRow, error) {
	row := q.db.QueryRow(ctx, getPublisherDashboardSummary, id)
	var i GetPublisherDashboardSummaryRow
	err := row.Scan(
		&i.Name,
		&i.IsVerified,
		&i.StatusKey,
		&i.StatusDisplayHebrew,
		&i.StatusDisplayEnglish,
	)
	return i, err
}

const getPublisherForLocationWithAlgorithm = `-- name: GetPublisherForLocationWithAlgorithm :one
SELECT
    p.id as publisher_id,
    p.name as publisher_name,
    COALESCE(p.description, '') as publisher_description,
    p.website as publisher_website,
    p.contact_email as publisher_email,
    p.logo_url as publisher_logo_url,
    p.is_verified as publisher_is_verified,
    0 as publisher_subscriber_count,
    p.created_at as publisher_created_at,
    p.updated_at as publisher_updated_at,
    a.id as algorithm_id,
    a.name as algorithm_name,
    COALESCE(a.description, '') as algorithm_description,
    '1.0' as algorithm_version,
    COALESCE(a.configuration::text, '{}')::jsonb as algorithm_configuration,
    astatus.key = 'active' as algorithm_is_active
FROM publishers p
JOIN publisher_coverage pc ON p.id = pc.publisher_id
JOIN algorithms a ON p.id = a.publisher_id
JOIN algorithm_statuses astatus ON astatus.id = a.status_id
WHERE p.is_verified = true
  AND pc.is_active = true
  AND astatus.key = 'active'
  AND p.deleted_at IS NULL
  AND pc.locality_id = $1
ORDER BY pc.priority DESC
LIMIT 1
`

type GetPublisherForLocationWithAlgorithmRow struct {
	PublisherID              int32              `json:"publisher_id"`
	PublisherName            string             `json:"publisher_name"`
	PublisherDescription     string             `json:"publisher_description"`
	PublisherWebsite         *string            `json:"publisher_website"`
	PublisherEmail           string             `json:"publisher_email"`
	PublisherLogoUrl         *string            `json:"publisher_logo_url"`
	PublisherIsVerified      bool               `json:"publisher_is_verified"`
	PublisherSubscriberCount int32              `json:"publisher_subscriber_count"`
	PublisherCreatedAt       pgtype.Timestamptz `json:"publisher_created_at"`
	PublisherUpdatedAt       pgtype.Timestamptz `json:"publisher_updated_at"`
	AlgorithmID              int32              `json:"algorithm_id"`
	AlgorithmName            string             `json:"algorithm_name"`
	AlgorithmDescription     string             `json:"algorithm_description"`
	AlgorithmVersion         string             `json:"algorithm_version"`
	AlgorithmConfiguration   []byte             `json:"algorithm_configuration"`
	AlgorithmIsActive        bool               `json:"algorithm_is_active"`
}

// Find the best publisher for a location with their active algorithm
// Uses publisher_coverage to find publishers covering the location
func (q *Queries) GetPublisherForLocationWithAlgorithm(ctx context.Context, localityID *int32) (GetPublisherForLocationWithAlgorithmRow, error) {
	row := q.db.QueryRow(ctx, getPublisherForLocationWithAlgorithm, localityID)
	var i GetPublisherForLocationWithAlgorithmRow
	err := row.Scan(
		&i.PublisherID,
		&i.PublisherName,
		&i.PublisherDescription,
		&i.PublisherWebsite,
		&i.PublisherEmail,
		&i.PublisherLogoUrl,
		&i.PublisherIsVerified,
		&i.PublisherSubscriberCount,
		&i.PublisherCreatedAt,
		&i.PublisherUpdatedAt,
		&i.AlgorithmID,
		&i.AlgorithmName,
		&i.AlgorithmDescription,
		&i.AlgorithmVersion,
		&i.AlgorithmConfiguration,
		&i.AlgorithmIsActive,
	)
	return i, err
}

const getPublisherFullByClerkUserID = `-- name: GetPublisherFullByClerkUserID :one
SELECT p.id, p.clerk_user_id, p.name, p.contact_email, p.description, p.bio,
       p.website, p.logo_url, p.logo_data, p.status_id, p.is_global,
       ps.key as status_key,
       ps.display_name_hebrew as status_display_hebrew,
       ps.display_name_english as status_display_english,
       p.created_at, p.updated_at
FROM publishers p
JOIN publisher_statuses ps ON ps.id = p.status_id
WHERE p.clerk_user_id = $1
`

type GetPublisherFullByClerkUserIDRow struct {
	ID                   int32              `json:"id"`
	ClerkUserID          *string            `json:"clerk_user_id"`
	Name                 string             `json:"name"`
	ContactEmail         string             `json:"contact_email"`
	Description          *string            `json:"description"`
	Bio                  *string            `json:"bio"`
	Website              *string            `json:"website"`
	LogoUrl              *string            `json:"logo_url"`
	LogoData             *string            `json:"logo_data"`
	StatusID             int16              `json:"status_id"`
	IsGlobal             bool               `json:"is_global"`
	StatusKey            string             `json:"status_key"`
	StatusDisplayHebrew  string             `json:"status_display_hebrew"`
	StatusDisplayEnglish string             `json:"status_display_english"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetPublisherFullByClerkUserID(ctx context.Context, clerkUserID *string) (GetPublisherFullByClerkUserIDRow, error) {
	row := q.db.QueryRow(ctx, getPublisherFullByClerkUserID, clerkUserID)
	var i GetPublisherFullByClerkUserIDRow
	err := row.Scan(
		&i.ID,
		&i.ClerkUserID,
		&i.Name,
		&i.ContactEmail,
		&i.Description,
		&i.Bio,
		&i.Website,
		&i.LogoUrl,
		&i.LogoData,
		&i.StatusID,
		&i.IsGlobal,
		&i.StatusKey,
		&i.StatusDisplayHebrew,
		&i.StatusDisplayEnglish,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPublisherFullProfileByClerkUserID = `-- name: GetPublisherFullProfileByClerkUserID :one
SELECT p.id, p.clerk_user_id, p.name, p.contact_email,
       COALESCE(p.description, '') as description,
       COALESCE(p.bio, '') as bio,
       p.website, p.logo_url, p.logo_data, p.status_id, p.is_verified, p.is_global,
       ps.key as status_key,
       p.created_at, p.updated_at
FROM publishers p
JOIN publisher_statuses ps ON ps.id = p.status_id
WHERE p.clerk_user_id = $1
`

type GetPublisherFullProfileByClerkUserIDRow struct {
	ID           int32              `json:"id"`
	ClerkUserID  *string            `json:"clerk_user_id"`
	Name         string             `json:"name"`
	ContactEmail string             `json:"contact_email"`
	Description  string             `json:"description"`
	Bio          string             `json:"bio"`
	Website      *string            `json:"website"`
	LogoUrl      *string            `json:"logo_url"`
	LogoData     *string            `json:"logo_data"`
	StatusID     int16              `json:"status_id"`
	IsVerified   bool               `json:"is_verified"`
	IsGlobal     bool               `json:"is_global"`
	StatusKey    string             `json:"status_key"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetPublisherFullProfileByClerkUserID(ctx context.Context, clerkUserID *string) (GetPublisherFullProfileByClerkUserIDRow, error) {
	row := q.db.QueryRow(ctx, getPublisherFullProfileByClerkUserID, clerkUserID)
	var i GetPublisherFullProfileByClerkUserIDRow
	err := row.Scan(
		&i.ID,
		&i.ClerkUserID,
		&i.Name,
		&i.ContactEmail,
		&i.Description,
		&i.Bio,
		&i.Website,
		&i.LogoUrl,
		&i.LogoData,
		&i.StatusID,
		&i.IsVerified,
		&i.IsGlobal,
		&i.StatusKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPublisherFullProfileByID = `-- name: GetPublisherFullProfileByID :one
SELECT p.id, p.clerk_user_id, p.name, p.contact_email,
       COALESCE(p.description, '') as description,
       COALESCE(p.bio, '') as bio,
       p.website, p.logo_url, p.logo_data, p.status_id, p.is_verified, p.is_global,
       ps.key as status_key,
       p.created_at, p.updated_at
FROM publishers p
JOIN publisher_statuses ps ON ps.id = p.status_id
WHERE p.id = $1
`

type GetPublisherFullProfileByIDRow struct {
	ID           int32              `json:"id"`
	ClerkUserID  *string            `json:"clerk_user_id"`
	Name         string             `json:"name"`
	ContactEmail string             `json:"contact_email"`
	Description  string             `json:"description"`
	Bio          string             `json:"bio"`
	Website      *string            `json:"website"`
	LogoUrl      *string            `json:"logo_url"`
	LogoData     *string            `json:"logo_data"`
	StatusID     int16              `json:"status_id"`
	IsVerified   bool               `json:"is_verified"`
	IsGlobal     bool               `json:"is_global"`
	StatusKey    string             `json:"status_key"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetPublisherFullProfileByID(ctx context.Context, id int32) (GetPublisherFullProfileByIDRow, error) {
	row := q.db.QueryRow(ctx, getPublisherFullProfileByID, id)
	var i GetPublisherFullProfileByIDRow
	err := row.Scan(
		&i.ID,
		&i.ClerkUserID,
		&i.Name,
		&i.ContactEmail,
		&i.Description,
		&i.Bio,
		&i.Website,
		&i.LogoUrl,
		&i.LogoData,
		&i.StatusID,
		&i.IsVerified,
		&i.IsGlobal,
		&i.StatusKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPublisherIsGlobal = `-- name: GetPublisherIsGlobal :one
SELECT is_global FROM publishers WHERE id = $1 AND deleted_at IS NULL
`

// Get publisher's is_global status
func (q *Queries) GetPublisherIsGlobal(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRow(ctx, getPublisherIsGlobal, id)
	var is_global bool
	err := row.Scan(&is_global)
	return is_global, err
}

const getPublisherLocalitiesCovered = `-- name: GetPublisherLocalitiesCovered :one
SELECT COALESCE(SUM(
    CASE cl.key
        WHEN 'locality' THEN 1
        WHEN 'region' THEN (
            SELECT COUNT(*) FROM geo_search_index s
            WHERE s.entity_type = 'locality' AND s.inherited_region_id = pc.region_id
        )
        WHEN 'country' THEN (
            SELECT COUNT(*) FROM geo_localities l WHERE l.country_id = pc.country_id
        )
        ELSE 0
    END
), 0)::bigint as localities_covered
FROM publisher_coverage pc
JOIN coverage_levels cl ON cl.id = pc.coverage_level_id
WHERE pc.publisher_id = $1 AND pc.is_active = true
`

// Uses geo_search_index.inherited_region_id for accurate region locality counts
func (q *Queries) GetPublisherLocalitiesCovered(ctx context.Context, publisherID int32) (int64, error) {
	row := q.db.QueryRow(ctx, getPublisherLocalitiesCovered, publisherID)
	var localities_covered int64
	err := row.Scan(&localities_covered)
	return localities_covered, err
}

const getPublisherNameForTeam = `-- name: GetPublisherNameForTeam :one
SELECT name
FROM publishers
WHERE id = $1
`

func (q *Queries) GetPublisherNameForTeam(ctx context.Context, id int32) (string, error) {
	row := q.db.QueryRow(ctx, getPublisherNameForTeam, id)
	var name string
	err := row.Scan(&name)
	return name, err
}

const getPublisherOwnerID = `-- name: GetPublisherOwnerID :one

SELECT clerk_user_id
FROM publishers
WHERE id = $1
`

// Team/Invitation Queries
func (q *Queries) GetPublisherOwnerID(ctx context.Context, id int32) (*string, error) {
	row := q.db.QueryRow(ctx, getPublisherOwnerID, id)
	var clerk_user_id *string
	err := row.Scan(&clerk_user_id)
	return clerk_user_id, err
}

const getPublisherProfileByClerkUserID = `-- name: GetPublisherProfileByClerkUserID :one
SELECT id, clerk_user_id, name, contact_email,
       COALESCE(description, '') as description, COALESCE(bio, '') as bio,
       website, logo_url, logo_data, status_id, is_verified, is_global, created_at, updated_at
FROM publishers
WHERE clerk_user_id = $1
`

type GetPublisherProfileByClerkUserIDRow struct {
	ID           int32              `json:"id"`
	ClerkUserID  *string            `json:"clerk_user_id"`
	Name         string             `json:"name"`
	ContactEmail string             `json:"contact_email"`
	Description  string             `json:"description"`
	Bio          string             `json:"bio"`
	Website      *string            `json:"website"`
	LogoUrl      *string            `json:"logo_url"`
	LogoData     *string            `json:"logo_data"`
	StatusID     int16              `json:"status_id"`
	IsVerified   bool               `json:"is_verified"`
	IsGlobal     bool               `json:"is_global"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetPublisherProfileByClerkUserID(ctx context.Context, clerkUserID *string) (GetPublisherProfileByClerkUserIDRow, error) {
	row := q.db.QueryRow(ctx, getPublisherProfileByClerkUserID, clerkUserID)
	var i GetPublisherProfileByClerkUserIDRow
	err := row.Scan(
		&i.ID,
		&i.ClerkUserID,
		&i.Name,
		&i.ContactEmail,
		&i.Description,
		&i.Bio,
		&i.Website,
		&i.LogoUrl,
		&i.LogoData,
		&i.StatusID,
		&i.IsVerified,
		&i.IsGlobal,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPublisherProfileByID = `-- name: GetPublisherProfileByID :one
SELECT id, clerk_user_id, name, contact_email,
       COALESCE(description, '') as description, COALESCE(bio, '') as bio,
       website, logo_url, logo_data, status_id, is_verified, is_global, created_at, updated_at
FROM publishers
WHERE id = $1
`

type GetPublisherProfileByIDRow struct {
	ID           int32              `json:"id"`
	ClerkUserID  *string            `json:"clerk_user_id"`
	Name         string             `json:"name"`
	ContactEmail string             `json:"contact_email"`
	Description  string             `json:"description"`
	Bio          string             `json:"bio"`
	Website      *string            `json:"website"`
	LogoUrl      *string            `json:"logo_url"`
	LogoData     *string            `json:"logo_data"`
	StatusID     int16              `json:"status_id"`
	IsVerified   bool               `json:"is_verified"`
	IsGlobal     bool               `json:"is_global"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetPublisherProfileByID(ctx context.Context, id int32) (GetPublisherProfileByIDRow, error) {
	row := q.db.QueryRow(ctx, getPublisherProfileByID, id)
	var i GetPublisherProfileByIDRow
	err := row.Scan(
		&i.ID,
		&i.ClerkUserID,
		&i.Name,
		&i.ContactEmail,
		&i.Description,
		&i.Bio,
		&i.Website,
		&i.LogoUrl,
		&i.LogoData,
		&i.StatusID,
		&i.IsVerified,
		&i.IsGlobal,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPublisherTransliterationStyle = `-- name: GetPublisherTransliterationStyle :one
SELECT COALESCE(transliteration_style, 'ashkenazi') AS transliteration_style
FROM publishers
WHERE id = $1 AND deleted_at IS NULL
`

// Get publisher's preferred English transliteration style (ashkenazi or sephardi)
func (q *Queries) GetPublisherTransliterationStyle(ctx context.Context, id int32) (string, error) {
	row := q.db.QueryRow(ctx, getPublisherTransliterationStyle, id)
	var transliteration_style string
	err := row.Scan(&transliteration_style)
	return transliteration_style, err
}

const listPendingInvitationsByPublisher = `-- name: ListPendingInvitationsByPublisher :many
SELECT id, email, expires_at, created_at
FROM publisher_invitations
WHERE publisher_id = $1
ORDER BY created_at DESC
`

type ListPendingInvitationsByPublisherRow struct {
	ID        int32              `json:"id"`
	Email     string             `json:"email"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) ListPendingInvitationsByPublisher(ctx context.Context, publisherID int32) ([]ListPendingInvitationsByPublisherRow, error) {
	rows, err := q.db.Query(ctx, listPendingInvitationsByPublisher, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPendingInvitationsByPublisherRow{}
	for rows.Next() {
		var i ListPendingInvitationsByPublisherRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishers = `-- name: ListPublishers :many
SELECT p.id, p.name, p.status_id,
       ps.key as status_key,
       ps.display_name_hebrew as status_display_hebrew,
       ps.display_name_english as status_display_english,
       p.created_at
FROM publishers p
JOIN publisher_statuses ps ON ps.id = p.status_id
ORDER BY p.name
LIMIT $1 OFFSET $2
`

type ListPublishersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListPublishersRow struct {
	ID                   int32              `json:"id"`
	Name                 string             `json:"name"`
	StatusID             int16              `json:"status_id"`
	StatusKey            string             `json:"status_key"`
	StatusDisplayHebrew  string             `json:"status_display_hebrew"`
	StatusDisplayEnglish string             `json:"status_display_english"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) ListPublishers(ctx context.Context, arg ListPublishersParams) ([]ListPublishersRow, error) {
	rows, err := q.db.Query(ctx, listPublishers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPublishersRow{}
	for rows.Next() {
		var i ListPublishersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.StatusID,
			&i.StatusKey,
			&i.StatusDisplayHebrew,
			&i.StatusDisplayEnglish,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishersByIDs = `-- name: ListPublishersByIDs :many
SELECT p.id, p.name, p.status_id,
       ps.key as status_key,
       ps.display_name_hebrew as status_display_hebrew,
       ps.display_name_english as status_display_english
FROM publishers p
JOIN publisher_statuses ps ON ps.id = p.status_id
WHERE p.id = ANY($1::text[])
ORDER BY p.name
`

type ListPublishersByIDsRow struct {
	ID                   int32  `json:"id"`
	Name                 string `json:"name"`
	StatusID             int16  `json:"status_id"`
	StatusKey            string `json:"status_key"`
	StatusDisplayHebrew  string `json:"status_display_hebrew"`
	StatusDisplayEnglish string `json:"status_display_english"`
}

func (q *Queries) ListPublishersByIDs(ctx context.Context, dollar_1 []string) ([]ListPublishersByIDsRow, error) {
	rows, err := q.db.Query(ctx, listPublishersByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPublishersByIDsRow{}
	for rows.Next() {
		var i ListPublishersByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.StatusID,
			&i.StatusKey,
			&i.StatusDisplayHebrew,
			&i.StatusDisplayEnglish,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVerifiedPublishers = `-- name: ListVerifiedPublishers :many

SELECT id, name, COALESCE(description, '') as description, website, contact_email,
       logo_url, is_verified,
       0 as subscriber_count,
       created_at, updated_at
FROM publishers
WHERE is_verified = true AND deleted_at IS NULL
ORDER BY name
LIMIT $1 OFFSET $2
`

type ListVerifiedPublishersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListVerifiedPublishersRow struct {
	ID              int32              `json:"id"`
	Name            string             `json:"name"`
	Description     string             `json:"description"`
	Website         *string            `json:"website"`
	ContactEmail    string             `json:"contact_email"`
	LogoUrl         *string            `json:"logo_url"`
	IsVerified      bool               `json:"is_verified"`
	SubscriberCount int32              `json:"subscriber_count"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

// ============================================================================
// Legacy Service Queries (for publisher_service.go migration)
// ============================================================================
// Get verified/active publishers with pagination
func (q *Queries) ListVerifiedPublishers(ctx context.Context, arg ListVerifiedPublishersParams) ([]ListVerifiedPublishersRow, error) {
	rows, err := q.db.Query(ctx, listVerifiedPublishers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListVerifiedPublishersRow{}
	for rows.Next() {
		var i ListVerifiedPublishersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Website,
			&i.ContactEmail,
			&i.LogoUrl,
			&i.IsVerified,
			&i.SubscriberCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPublishersAll = `-- name: SearchPublishersAll :many
SELECT
    p.id::text as id, p.name, p.description, p.logo_url,
    (p.status_id = (SELECT id FROM publisher_statuses WHERE key = 'verified') OR
     p.status_id = (SELECT id FROM publisher_statuses WHERE key = 'active')) as is_verified,
    0 as zmanim_count
FROM publishers p
WHERE (p.status_id = (SELECT id FROM publisher_statuses WHERE key = 'verified') OR
       p.status_id = (SELECT id FROM publisher_statuses WHERE key = 'active'))
  AND (p.name ILIKE $1 OR p.description ILIKE $1)
ORDER BY p.name
LIMIT $2 OFFSET $3
`

type SearchPublishersAllParams struct {
	Name   string `json:"name"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type SearchPublishersAllRow struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	Description *string `json:"description"`
	LogoUrl     *string `json:"logo_url"`
	IsVerified  *bool   `json:"is_verified"`
	ZmanimCount int32   `json:"zmanim_count"`
}

func (q *Queries) SearchPublishersAll(ctx context.Context, arg SearchPublishersAllParams) ([]SearchPublishersAllRow, error) {
	rows, err := q.db.Query(ctx, searchPublishersAll, arg.Name, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchPublishersAllRow{}
	for rows.Next() {
		var i SearchPublishersAllRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.LogoUrl,
			&i.IsVerified,
			&i.ZmanimCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPublishersWithAlgorithm = `-- name: SearchPublishersWithAlgorithm :many
SELECT DISTINCT
    p.id::text as id, p.name, p.description, p.logo_url,
    (p.status_id = (SELECT id FROM publisher_statuses WHERE key = 'verified') OR
     p.status_id = (SELECT id FROM publisher_statuses WHERE key = 'active')) as is_verified,
    COUNT(DISTINCT pz.id) as zmanim_count
FROM publishers p
JOIN publisher_zmanim pz ON pz.publisher_id = p.id
    AND pz.is_published = true
    AND pz.is_enabled = true
    AND pz.deleted_at IS NULL
WHERE (p.status_id = (SELECT id FROM publisher_statuses WHERE key = 'verified') OR
       p.status_id = (SELECT id FROM publisher_statuses WHERE key = 'active'))
  AND (p.name ILIKE $1 OR p.description ILIKE $1)
GROUP BY p.id, p.name, p.description, p.logo_url, p.status_id
HAVING COUNT(DISTINCT pz.id) > 0
ORDER BY p.name
LIMIT $2 OFFSET $3
`

type SearchPublishersWithAlgorithmParams struct {
	Name   string `json:"name"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type SearchPublishersWithAlgorithmRow struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	Description *string `json:"description"`
	LogoUrl     *string `json:"logo_url"`
	IsVerified  *bool   `json:"is_verified"`
	ZmanimCount int64   `json:"zmanim_count"`
}

func (q *Queries) SearchPublishersWithAlgorithm(ctx context.Context, arg SearchPublishersWithAlgorithmParams) ([]SearchPublishersWithAlgorithmRow, error) {
	rows, err := q.db.Query(ctx, searchPublishersWithAlgorithm, arg.Name, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchPublishersWithAlgorithmRow{}
	for rows.Next() {
		var i SearchPublishersWithAlgorithmRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.LogoUrl,
			&i.IsVerified,
			&i.ZmanimCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePublisherCalculationSettings = `-- name: UpdatePublisherCalculationSettings :one
UPDATE publishers
SET ignore_elevation = $2,
    transliteration_style = $3,
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, ignore_elevation, transliteration_style, updated_at
`

type UpdatePublisherCalculationSettingsParams struct {
	ID                   int32  `json:"id"`
	IgnoreElevation      bool   `json:"ignore_elevation"`
	TransliterationStyle string `json:"transliteration_style"`
}

type UpdatePublisherCalculationSettingsRow struct {
	ID                   int32              `json:"id"`
	IgnoreElevation      bool               `json:"ignore_elevation"`
	TransliterationStyle string             `json:"transliteration_style"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdatePublisherCalculationSettings(ctx context.Context, arg UpdatePublisherCalculationSettingsParams) (UpdatePublisherCalculationSettingsRow, error) {
	row := q.db.QueryRow(ctx, updatePublisherCalculationSettings, arg.ID, arg.IgnoreElevation, arg.TransliterationStyle)
	var i UpdatePublisherCalculationSettingsRow
	err := row.Scan(
		&i.ID,
		&i.IgnoreElevation,
		&i.TransliterationStyle,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePublisherIsGlobal = `-- name: UpdatePublisherIsGlobal :one
UPDATE publishers
SET is_global = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, is_global, updated_at
`

type UpdatePublisherIsGlobalParams struct {
	ID       int32 `json:"id"`
	IsGlobal bool  `json:"is_global"`
}

type UpdatePublisherIsGlobalRow struct {
	ID        int32              `json:"id"`
	IsGlobal  bool               `json:"is_global"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// Update the is_global flag for a publisher
func (q *Queries) UpdatePublisherIsGlobal(ctx context.Context, arg UpdatePublisherIsGlobalParams) (UpdatePublisherIsGlobalRow, error) {
	row := q.db.QueryRow(ctx, updatePublisherIsGlobal, arg.ID, arg.IsGlobal)
	var i UpdatePublisherIsGlobalRow
	err := row.Scan(&i.ID, &i.IsGlobal, &i.UpdatedAt)
	return i, err
}

const updatePublisherLogo = `-- name: UpdatePublisherLogo :one
UPDATE publishers
SET logo_data = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, logo_data
`

type UpdatePublisherLogoParams struct {
	ID       int32   `json:"id"`
	LogoData *string `json:"logo_data"`
}

type UpdatePublisherLogoRow struct {
	ID       int32   `json:"id"`
	LogoData *string `json:"logo_data"`
}

func (q *Queries) UpdatePublisherLogo(ctx context.Context, arg UpdatePublisherLogoParams) (UpdatePublisherLogoRow, error) {
	row := q.db.QueryRow(ctx, updatePublisherLogo, arg.ID, arg.LogoData)
	var i UpdatePublisherLogoRow
	err := row.Scan(&i.ID, &i.LogoData)
	return i, err
}

const updatePublisherProfile = `-- name: UpdatePublisherProfile :one
UPDATE publishers
SET name = COALESCE($1, name),
    contact_email = COALESCE($2, contact_email),
    website = COALESCE($3, website),
    bio = COALESCE($4, bio),
    updated_at = NOW()
WHERE id = $5
RETURNING id, clerk_user_id, name, contact_email, description, bio,
          website, logo_url, logo_data, status_id, created_at, updated_at
`

type UpdatePublisherProfileParams struct {
	UpdateName    *string `json:"update_name"`
	UpdateEmail   *string `json:"update_email"`
	UpdateWebsite *string `json:"update_website"`
	UpdateBio     *string `json:"update_bio"`
	ID            int32   `json:"id"`
}

type UpdatePublisherProfileRow struct {
	ID           int32              `json:"id"`
	ClerkUserID  *string            `json:"clerk_user_id"`
	Name         string             `json:"name"`
	ContactEmail string             `json:"contact_email"`
	Description  *string            `json:"description"`
	Bio          *string            `json:"bio"`
	Website      *string            `json:"website"`
	LogoUrl      *string            `json:"logo_url"`
	LogoData     *string            `json:"logo_data"`
	StatusID     int16              `json:"status_id"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdatePublisherProfile(ctx context.Context, arg UpdatePublisherProfileParams) (UpdatePublisherProfileRow, error) {
	row := q.db.QueryRow(ctx, updatePublisherProfile,
		arg.UpdateName,
		arg.UpdateEmail,
		arg.UpdateWebsite,
		arg.UpdateBio,
		arg.ID,
	)
	var i UpdatePublisherProfileRow
	err := row.Scan(
		&i.ID,
		&i.ClerkUserID,
		&i.Name,
		&i.ContactEmail,
		&i.Description,
		&i.Bio,
		&i.Website,
		&i.LogoUrl,
		&i.LogoData,
		&i.StatusID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePublisherProfileByClerkUserID = `-- name: UpdatePublisherProfileByClerkUserID :one
UPDATE publishers
SET name = COALESCE($1, name),
    contact_email = COALESCE($2, contact_email),
    website = COALESCE($3, website),
    bio = COALESCE($4, bio),
    updated_at = NOW()
WHERE clerk_user_id = $5
RETURNING id, clerk_user_id, name, contact_email, description, bio,
          website, logo_url, logo_data, status_id, created_at, updated_at
`

type UpdatePublisherProfileByClerkUserIDParams struct {
	UpdateName    *string `json:"update_name"`
	UpdateEmail   *string `json:"update_email"`
	UpdateWebsite *string `json:"update_website"`
	UpdateBio     *string `json:"update_bio"`
	ClerkUserID   *string `json:"clerk_user_id"`
}

type UpdatePublisherProfileByClerkUserIDRow struct {
	ID           int32              `json:"id"`
	ClerkUserID  *string            `json:"clerk_user_id"`
	Name         string             `json:"name"`
	ContactEmail string             `json:"contact_email"`
	Description  *string            `json:"description"`
	Bio          *string            `json:"bio"`
	Website      *string            `json:"website"`
	LogoUrl      *string            `json:"logo_url"`
	LogoData     *string            `json:"logo_data"`
	StatusID     int16              `json:"status_id"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdatePublisherProfileByClerkUserID(ctx context.Context, arg UpdatePublisherProfileByClerkUserIDParams) (UpdatePublisherProfileByClerkUserIDRow, error) {
	row := q.db.QueryRow(ctx, updatePublisherProfileByClerkUserID,
		arg.UpdateName,
		arg.UpdateEmail,
		arg.UpdateWebsite,
		arg.UpdateBio,
		arg.ClerkUserID,
	)
	var i UpdatePublisherProfileByClerkUserIDRow
	err := row.Scan(
		&i.ID,
		&i.ClerkUserID,
		&i.Name,
		&i.ContactEmail,
		&i.Description,
		&i.Bio,
		&i.Website,
		&i.LogoUrl,
		&i.LogoData,
		&i.StatusID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePublisherStatus = `-- name: UpdatePublisherStatus :one
WITH updated AS (
    UPDATE publishers
    SET status_id = $2, updated_at = NOW()
    WHERE publishers.id = $1
    RETURNING id, clerk_user_id, name, contact_email, description, bio,
              website, logo_url, logo_data, status_id, created_at, updated_at
)
SELECT u.id, u.clerk_user_id, u.name, u.contact_email, u.description, u.bio,
       u.website, u.logo_url, u.logo_data, u.status_id,
       ps.key as status_key,
       ps.display_name_hebrew as status_display_hebrew,
       ps.display_name_english as status_display_english,
       u.created_at, u.updated_at
FROM updated u
JOIN publisher_statuses ps ON ps.id = u.status_id
`

type UpdatePublisherStatusParams struct {
	ID       int32 `json:"id"`
	StatusID int16 `json:"status_id"`
}

type UpdatePublisherStatusRow struct {
	ID                   int32              `json:"id"`
	ClerkUserID          *string            `json:"clerk_user_id"`
	Name                 string             `json:"name"`
	ContactEmail         string             `json:"contact_email"`
	Description          *string            `json:"description"`
	Bio                  *string            `json:"bio"`
	Website              *string            `json:"website"`
	LogoUrl              *string            `json:"logo_url"`
	LogoData             *string            `json:"logo_data"`
	StatusID             int16              `json:"status_id"`
	StatusKey            string             `json:"status_key"`
	StatusDisplayHebrew  string             `json:"status_display_hebrew"`
	StatusDisplayEnglish string             `json:"status_display_english"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdatePublisherStatus(ctx context.Context, arg UpdatePublisherStatusParams) (UpdatePublisherStatusRow, error) {
	row := q.db.QueryRow(ctx, updatePublisherStatus, arg.ID, arg.StatusID)
	var i UpdatePublisherStatusRow
	err := row.Scan(
		&i.ID,
		&i.ClerkUserID,
		&i.Name,
		&i.ContactEmail,
		&i.Description,
		&i.Bio,
		&i.Website,
		&i.LogoUrl,
		&i.LogoData,
		&i.StatusID,
		&i.StatusKey,
		&i.StatusDisplayHebrew,
		&i.StatusDisplayEnglish,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePublisherTransliterationStyle = `-- name: UpdatePublisherTransliterationStyle :one
UPDATE publishers
SET transliteration_style = $2,
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, transliteration_style, updated_at
`

type UpdatePublisherTransliterationStyleParams struct {
	ID                   int32  `json:"id"`
	TransliterationStyle string `json:"transliteration_style"`
}

type UpdatePublisherTransliterationStyleRow struct {
	ID                   int32              `json:"id"`
	TransliterationStyle string             `json:"transliteration_style"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

// Update publisher's preferred English transliteration style
func (q *Queries) UpdatePublisherTransliterationStyle(ctx context.Context, arg UpdatePublisherTransliterationStyleParams) (UpdatePublisherTransliterationStyleRow, error) {
	row := q.db.QueryRow(ctx, updatePublisherTransliterationStyle, arg.ID, arg.TransliterationStyle)
	var i UpdatePublisherTransliterationStyleRow
	err := row.Scan(&i.ID, &i.TransliterationStyle, &i.UpdatedAt)
	return i, err
}
