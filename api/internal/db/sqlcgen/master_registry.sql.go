// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: master_registry.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addMasterZmanFromRequest = `-- name: AddMasterZmanFromRequest :one
INSERT INTO master_zmanim_registry (
    zman_key,
    canonical_hebrew_name,
    canonical_english_name,
    time_category_id,
    default_formula_dsl,
    is_core,
    description
)
SELECT
    zrr.requested_key,
    zrr.requested_hebrew_name,
    zrr.requested_english_name,
    zrr.time_category_id,
    zrr.requested_formula_dsl,
    false,
    'Added from publisher request'
FROM zman_registry_requests zrr
WHERE zrr.id = $1
RETURNING id, zman_key, canonical_hebrew_name, canonical_english_name, time_category_id,
    default_formula_dsl, is_core, created_at, updated_at
`

type AddMasterZmanFromRequestRow struct {
	ID                   int32              `json:"id"`
	ZmanKey              string             `json:"zman_key"`
	CanonicalHebrewName  string             `json:"canonical_hebrew_name"`
	CanonicalEnglishName string             `json:"canonical_english_name"`
	TimeCategoryID       *int32             `json:"time_category_id"`
	DefaultFormulaDsl    *string            `json:"default_formula_dsl"`
	IsCore               *bool              `json:"is_core"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) AddMasterZmanFromRequest(ctx context.Context, id int32) (AddMasterZmanFromRequestRow, error) {
	row := q.db.QueryRow(ctx, addMasterZmanFromRequest, id)
	var i AddMasterZmanFromRequestRow
	err := row.Scan(
		&i.ID,
		&i.ZmanKey,
		&i.CanonicalHebrewName,
		&i.CanonicalEnglishName,
		&i.TimeCategoryID,
		&i.DefaultFormulaDsl,
		&i.IsCore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const adminCreateMasterZman = `-- name: AdminCreateMasterZman :one
INSERT INTO master_zmanim_registry (
    zman_key, canonical_hebrew_name, canonical_english_name,
    transliteration, description, halachic_notes, halachic_source,
    time_category_id, default_formula_dsl, is_core,
    is_hidden
) VALUES (
    $1, $2, $3, $4, $5, $6, $7,
    (SELECT id FROM time_categories WHERE key = $8),
    $9, $10, $11
)
RETURNING id, zman_key, canonical_hebrew_name, canonical_english_name,
    transliteration, description, halachic_notes, halachic_source,
    time_category_id, default_formula_dsl, is_core,
    COALESCE(is_hidden, false), created_at, updated_at
`

type AdminCreateMasterZmanParams struct {
	ZmanKey              string  `json:"zman_key"`
	CanonicalHebrewName  string  `json:"canonical_hebrew_name"`
	CanonicalEnglishName string  `json:"canonical_english_name"`
	Transliteration      *string `json:"transliteration"`
	Description          *string `json:"description"`
	HalachicNotes        *string `json:"halachic_notes"`
	HalachicSource       *string `json:"halachic_source"`
	Key                  string  `json:"key"`
	DefaultFormulaDsl    *string `json:"default_formula_dsl"`
	IsCore               *bool   `json:"is_core"`
	IsHidden             bool    `json:"is_hidden"`
}

type AdminCreateMasterZmanRow struct {
	ID                   int32              `json:"id"`
	ZmanKey              string             `json:"zman_key"`
	CanonicalHebrewName  string             `json:"canonical_hebrew_name"`
	CanonicalEnglishName string             `json:"canonical_english_name"`
	Transliteration      *string            `json:"transliteration"`
	Description          *string            `json:"description"`
	HalachicNotes        *string            `json:"halachic_notes"`
	HalachicSource       *string            `json:"halachic_source"`
	TimeCategoryID       *int32             `json:"time_category_id"`
	DefaultFormulaDsl    *string            `json:"default_formula_dsl"`
	IsCore               *bool              `json:"is_core"`
	IsHidden             bool               `json:"is_hidden"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) AdminCreateMasterZman(ctx context.Context, arg AdminCreateMasterZmanParams) (AdminCreateMasterZmanRow, error) {
	row := q.db.QueryRow(ctx, adminCreateMasterZman,
		arg.ZmanKey,
		arg.CanonicalHebrewName,
		arg.CanonicalEnglishName,
		arg.Transliteration,
		arg.Description,
		arg.HalachicNotes,
		arg.HalachicSource,
		arg.Key,
		arg.DefaultFormulaDsl,
		arg.IsCore,
		arg.IsHidden,
	)
	var i AdminCreateMasterZmanRow
	err := row.Scan(
		&i.ID,
		&i.ZmanKey,
		&i.CanonicalHebrewName,
		&i.CanonicalEnglishName,
		&i.Transliteration,
		&i.Description,
		&i.HalachicNotes,
		&i.HalachicSource,
		&i.TimeCategoryID,
		&i.DefaultFormulaDsl,
		&i.IsCore,
		&i.IsHidden,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const adminCreateMasterZmanWithAudit = `-- name: AdminCreateMasterZmanWithAudit :one
INSERT INTO master_zmanim_registry (
    zman_key, canonical_hebrew_name, canonical_english_name,
    transliteration, description, halachic_notes, halachic_source,
    time_category_id, default_formula_dsl, is_core,
    is_hidden
) VALUES (
    $1, $2, $3, $4, $5, $6, $7,
    (SELECT tc.id FROM time_categories tc WHERE tc.key = $8),
    $9, $10, $11
)
RETURNING id, zman_key, canonical_hebrew_name, canonical_english_name,
    transliteration, description, halachic_notes, halachic_source,
    time_category_id, default_formula_dsl, is_core,
    COALESCE(is_hidden, false) as is_hidden, created_at, updated_at
`

type AdminCreateMasterZmanWithAuditParams struct {
	ZmanKey              string  `json:"zman_key"`
	CanonicalHebrewName  string  `json:"canonical_hebrew_name"`
	CanonicalEnglishName string  `json:"canonical_english_name"`
	Transliteration      *string `json:"transliteration"`
	Description          *string `json:"description"`
	HalachicNotes        *string `json:"halachic_notes"`
	HalachicSource       *string `json:"halachic_source"`
	Key                  string  `json:"key"`
	DefaultFormulaDsl    *string `json:"default_formula_dsl"`
	IsCore               *bool   `json:"is_core"`
	IsHidden             bool    `json:"is_hidden"`
}

type AdminCreateMasterZmanWithAuditRow struct {
	ID                   int32              `json:"id"`
	ZmanKey              string             `json:"zman_key"`
	CanonicalHebrewName  string             `json:"canonical_hebrew_name"`
	CanonicalEnglishName string             `json:"canonical_english_name"`
	Transliteration      *string            `json:"transliteration"`
	Description          *string            `json:"description"`
	HalachicNotes        *string            `json:"halachic_notes"`
	HalachicSource       *string            `json:"halachic_source"`
	TimeCategoryID       *int32             `json:"time_category_id"`
	DefaultFormulaDsl    *string            `json:"default_formula_dsl"`
	IsCore               *bool              `json:"is_core"`
	IsHidden             bool               `json:"is_hidden"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

// Create master zman with audit fields
func (q *Queries) AdminCreateMasterZmanWithAudit(ctx context.Context, arg AdminCreateMasterZmanWithAuditParams) (AdminCreateMasterZmanWithAuditRow, error) {
	row := q.db.QueryRow(ctx, adminCreateMasterZmanWithAudit,
		arg.ZmanKey,
		arg.CanonicalHebrewName,
		arg.CanonicalEnglishName,
		arg.Transliteration,
		arg.Description,
		arg.HalachicNotes,
		arg.HalachicSource,
		arg.Key,
		arg.DefaultFormulaDsl,
		arg.IsCore,
		arg.IsHidden,
	)
	var i AdminCreateMasterZmanWithAuditRow
	err := row.Scan(
		&i.ID,
		&i.ZmanKey,
		&i.CanonicalHebrewName,
		&i.CanonicalEnglishName,
		&i.Transliteration,
		&i.Description,
		&i.HalachicNotes,
		&i.HalachicSource,
		&i.TimeCategoryID,
		&i.DefaultFormulaDsl,
		&i.IsCore,
		&i.IsHidden,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const adminDeleteMasterZman = `-- name: AdminDeleteMasterZman :exec
DELETE FROM master_zmanim_registry WHERE id = $1
`

func (q *Queries) AdminDeleteMasterZman(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, adminDeleteMasterZman, id)
	return err
}

const adminGetAllMasterZmanim = `-- name: AdminGetAllMasterZmanim :many

SELECT mr.id, mr.zman_key, mr.canonical_hebrew_name, mr.canonical_english_name,
    mr.transliteration, mr.description, mr.halachic_notes, mr.halachic_source,
    tc.key as time_category, mr.default_formula_dsl, mr.is_core,
    COALESCE(mr.is_hidden, false) as is_hidden,
    mr.created_at, mr.updated_at
FROM master_zmanim_registry mr
LEFT JOIN time_categories tc ON mr.time_category_id = tc.id
WHERE ($1 = true OR COALESCE(mr.is_hidden, false) = false)
ORDER BY tc.sort_order, mr.canonical_hebrew_name
`

type AdminGetAllMasterZmanimRow struct {
	ID                   int32              `json:"id"`
	ZmanKey              string             `json:"zman_key"`
	CanonicalHebrewName  string             `json:"canonical_hebrew_name"`
	CanonicalEnglishName string             `json:"canonical_english_name"`
	Transliteration      *string            `json:"transliteration"`
	Description          *string            `json:"description"`
	HalachicNotes        *string            `json:"halachic_notes"`
	HalachicSource       *string            `json:"halachic_source"`
	TimeCategory         *string            `json:"time_category"`
	DefaultFormulaDsl    *string            `json:"default_formula_dsl"`
	IsCore               *bool              `json:"is_core"`
	IsHidden             bool               `json:"is_hidden"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

// ============================================
// ADMIN QUERIES
// ============================================
// Get all master zmanim for admin with optional include_hidden filter
func (q *Queries) AdminGetAllMasterZmanim(ctx context.Context, dollar_1 interface{}) ([]AdminGetAllMasterZmanimRow, error) {
	rows, err := q.db.Query(ctx, adminGetAllMasterZmanim, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminGetAllMasterZmanimRow{}
	for rows.Next() {
		var i AdminGetAllMasterZmanimRow
		if err := rows.Scan(
			&i.ID,
			&i.ZmanKey,
			&i.CanonicalHebrewName,
			&i.CanonicalEnglishName,
			&i.Transliteration,
			&i.Description,
			&i.HalachicNotes,
			&i.HalachicSource,
			&i.TimeCategory,
			&i.DefaultFormulaDsl,
			&i.IsCore,
			&i.IsHidden,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetAllZmanRequests = `-- name: AdminGetAllZmanRequests :many
SELECT
    zrr.id, zrr.publisher_id, zrr.requested_key, zrr.requested_hebrew_name, zrr.requested_english_name,
    zrr.requested_formula_dsl, tc.key as time_category, zrr.description, rs.key as status,
    zrr.reviewed_by, zrr.reviewed_at, zrr.reviewer_notes, zrr.created_at,
    zrr.publisher_name, zrr.publisher_email, p.name as submitter_name
FROM zman_registry_requests zrr
LEFT JOIN publishers p ON zrr.publisher_id = p.id
LEFT JOIN time_categories tc ON zrr.time_category_id = tc.id
LEFT JOIN request_statuses rs ON zrr.status_id = rs.id
ORDER BY zrr.created_at DESC
`

type AdminGetAllZmanRequestsRow struct {
	ID                   int32              `json:"id"`
	PublisherID          int32              `json:"publisher_id"`
	RequestedKey         string             `json:"requested_key"`
	RequestedHebrewName  string             `json:"requested_hebrew_name"`
	RequestedEnglishName string             `json:"requested_english_name"`
	RequestedFormulaDsl  *string            `json:"requested_formula_dsl"`
	TimeCategory         *string            `json:"time_category"`
	Description          *string            `json:"description"`
	Status               *string            `json:"status"`
	ReviewedBy           *string            `json:"reviewed_by"`
	ReviewedAt           pgtype.Timestamptz `json:"reviewed_at"`
	ReviewerNotes        *string            `json:"reviewer_notes"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	PublisherName        *string            `json:"publisher_name"`
	PublisherEmail       *string            `json:"publisher_email"`
	SubmitterName        *string            `json:"submitter_name"`
}

// Get all registry requests without status filter
func (q *Queries) AdminGetAllZmanRequests(ctx context.Context) ([]AdminGetAllZmanRequestsRow, error) {
	rows, err := q.db.Query(ctx, adminGetAllZmanRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminGetAllZmanRequestsRow{}
	for rows.Next() {
		var i AdminGetAllZmanRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.RequestedKey,
			&i.RequestedHebrewName,
			&i.RequestedEnglishName,
			&i.RequestedFormulaDsl,
			&i.TimeCategory,
			&i.Description,
			&i.Status,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.ReviewerNotes,
			&i.CreatedAt,
			&i.PublisherName,
			&i.PublisherEmail,
			&i.SubmitterName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetMasterZmanByID = `-- name: AdminGetMasterZmanByID :one
SELECT mr.id, mr.zman_key, mr.canonical_hebrew_name, mr.canonical_english_name,
    mr.transliteration, mr.description, mr.halachic_notes, mr.halachic_source,
    tc.key as time_category, mr.default_formula_dsl, mr.is_core,
    COALESCE(mr.is_hidden, false) as is_hidden,
    mr.created_at, mr.updated_at
FROM master_zmanim_registry mr
LEFT JOIN time_categories tc ON mr.time_category_id = tc.id
WHERE mr.id = $1
`

type AdminGetMasterZmanByIDRow struct {
	ID                   int32              `json:"id"`
	ZmanKey              string             `json:"zman_key"`
	CanonicalHebrewName  string             `json:"canonical_hebrew_name"`
	CanonicalEnglishName string             `json:"canonical_english_name"`
	Transliteration      *string            `json:"transliteration"`
	Description          *string            `json:"description"`
	HalachicNotes        *string            `json:"halachic_notes"`
	HalachicSource       *string            `json:"halachic_source"`
	TimeCategory         *string            `json:"time_category"`
	DefaultFormulaDsl    *string            `json:"default_formula_dsl"`
	IsCore               *bool              `json:"is_core"`
	IsHidden             bool               `json:"is_hidden"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) AdminGetMasterZmanByID(ctx context.Context, id int32) (AdminGetMasterZmanByIDRow, error) {
	row := q.db.QueryRow(ctx, adminGetMasterZmanByID, id)
	var i AdminGetMasterZmanByIDRow
	err := row.Scan(
		&i.ID,
		&i.ZmanKey,
		&i.CanonicalHebrewName,
		&i.CanonicalEnglishName,
		&i.Transliteration,
		&i.Description,
		&i.HalachicNotes,
		&i.HalachicSource,
		&i.TimeCategory,
		&i.DefaultFormulaDsl,
		&i.IsCore,
		&i.IsHidden,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const adminGetMasterZmanimByCategory = `-- name: AdminGetMasterZmanimByCategory :many
SELECT mr.id, mr.zman_key, mr.canonical_hebrew_name, mr.canonical_english_name,
    mr.transliteration, mr.description, mr.halachic_notes, mr.halachic_source,
    tc.key as time_category, mr.default_formula_dsl, mr.is_core,
    COALESCE(mr.is_hidden, false) as is_hidden,
    mr.created_at, mr.updated_at
FROM master_zmanim_registry mr
LEFT JOIN time_categories tc ON mr.time_category_id = tc.id
WHERE tc.key = $1 AND ($2 = true OR COALESCE(mr.is_hidden, false) = false)
ORDER BY mr.canonical_hebrew_name
`

type AdminGetMasterZmanimByCategoryParams struct {
	Key     string      `json:"key"`
	Column2 interface{} `json:"column_2"`
}

type AdminGetMasterZmanimByCategoryRow struct {
	ID                   int32              `json:"id"`
	ZmanKey              string             `json:"zman_key"`
	CanonicalHebrewName  string             `json:"canonical_hebrew_name"`
	CanonicalEnglishName string             `json:"canonical_english_name"`
	Transliteration      *string            `json:"transliteration"`
	Description          *string            `json:"description"`
	HalachicNotes        *string            `json:"halachic_notes"`
	HalachicSource       *string            `json:"halachic_source"`
	TimeCategory         *string            `json:"time_category"`
	DefaultFormulaDsl    *string            `json:"default_formula_dsl"`
	IsCore               *bool              `json:"is_core"`
	IsHidden             bool               `json:"is_hidden"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

// Get master zmanim by category for admin with optional include_hidden filter
func (q *Queries) AdminGetMasterZmanimByCategory(ctx context.Context, arg AdminGetMasterZmanimByCategoryParams) ([]AdminGetMasterZmanimByCategoryRow, error) {
	rows, err := q.db.Query(ctx, adminGetMasterZmanimByCategory, arg.Key, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminGetMasterZmanimByCategoryRow{}
	for rows.Next() {
		var i AdminGetMasterZmanimByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.ZmanKey,
			&i.CanonicalHebrewName,
			&i.CanonicalEnglishName,
			&i.Transliteration,
			&i.Description,
			&i.HalachicNotes,
			&i.HalachicSource,
			&i.TimeCategory,
			&i.DefaultFormulaDsl,
			&i.IsCore,
			&i.IsHidden,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetZmanRequestsByStatus = `-- name: AdminGetZmanRequestsByStatus :many
SELECT
    zrr.id, zrr.publisher_id, zrr.requested_key, zrr.requested_hebrew_name, zrr.requested_english_name,
    zrr.requested_formula_dsl, tc.key as time_category, zrr.description, rs.key as status,
    zrr.reviewed_by, zrr.reviewed_at, zrr.reviewer_notes, zrr.created_at,
    zrr.publisher_name, zrr.publisher_email, p.name as submitter_name
FROM zman_registry_requests zrr
LEFT JOIN publishers p ON zrr.publisher_id = p.id
LEFT JOIN time_categories tc ON zrr.time_category_id = tc.id
LEFT JOIN request_statuses rs ON zrr.status_id = rs.id
WHERE rs.key = $1
ORDER BY zrr.created_at DESC
`

type AdminGetZmanRequestsByStatusRow struct {
	ID                   int32              `json:"id"`
	PublisherID          int32              `json:"publisher_id"`
	RequestedKey         string             `json:"requested_key"`
	RequestedHebrewName  string             `json:"requested_hebrew_name"`
	RequestedEnglishName string             `json:"requested_english_name"`
	RequestedFormulaDsl  *string            `json:"requested_formula_dsl"`
	TimeCategory         *string            `json:"time_category"`
	Description          *string            `json:"description"`
	Status               *string            `json:"status"`
	ReviewedBy           *string            `json:"reviewed_by"`
	ReviewedAt           pgtype.Timestamptz `json:"reviewed_at"`
	ReviewerNotes        *string            `json:"reviewer_notes"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	PublisherName        *string            `json:"publisher_name"`
	PublisherEmail       *string            `json:"publisher_email"`
	SubmitterName        *string            `json:"submitter_name"`
}

// Get registry requests filtered by status
func (q *Queries) AdminGetZmanRequestsByStatus(ctx context.Context, key string) ([]AdminGetZmanRequestsByStatusRow, error) {
	rows, err := q.db.Query(ctx, adminGetZmanRequestsByStatus, key)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminGetZmanRequestsByStatusRow{}
	for rows.Next() {
		var i AdminGetZmanRequestsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.RequestedKey,
			&i.RequestedHebrewName,
			&i.RequestedEnglishName,
			&i.RequestedFormulaDsl,
			&i.TimeCategory,
			&i.Description,
			&i.Status,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.ReviewerNotes,
			&i.CreatedAt,
			&i.PublisherName,
			&i.PublisherEmail,
			&i.SubmitterName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminToggleZmanVisibility = `-- name: AdminToggleZmanVisibility :one
UPDATE master_zmanim_registry
SET is_hidden = NOT COALESCE(is_hidden, false), updated_at = NOW()
WHERE id = $1
RETURNING id, is_hidden
`

type AdminToggleZmanVisibilityRow struct {
	ID       int32 `json:"id"`
	IsHidden bool  `json:"is_hidden"`
}

func (q *Queries) AdminToggleZmanVisibility(ctx context.Context, id int32) (AdminToggleZmanVisibilityRow, error) {
	row := q.db.QueryRow(ctx, adminToggleZmanVisibility, id)
	var i AdminToggleZmanVisibilityRow
	err := row.Scan(&i.ID, &i.IsHidden)
	return i, err
}

const adminToggleZmanVisibilityWithAudit = `-- name: AdminToggleZmanVisibilityWithAudit :one
UPDATE master_zmanim_registry mr
SET is_hidden = NOT COALESCE(mr.is_hidden, false), updated_at = NOW()
WHERE mr.id = $1
RETURNING mr.id, mr.zman_key, mr.canonical_hebrew_name, mr.canonical_english_name,
    mr.transliteration, mr.description, mr.halachic_notes, mr.halachic_source,
    mr.time_category_id, mr.default_formula_dsl, mr.is_core,
    COALESCE(mr.is_hidden, false) as is_hidden, mr.created_at, mr.updated_at
`

type AdminToggleZmanVisibilityWithAuditRow struct {
	ID                   int32              `json:"id"`
	ZmanKey              string             `json:"zman_key"`
	CanonicalHebrewName  string             `json:"canonical_hebrew_name"`
	CanonicalEnglishName string             `json:"canonical_english_name"`
	Transliteration      *string            `json:"transliteration"`
	Description          *string            `json:"description"`
	HalachicNotes        *string            `json:"halachic_notes"`
	HalachicSource       *string            `json:"halachic_source"`
	TimeCategoryID       *int32             `json:"time_category_id"`
	DefaultFormulaDsl    *string            `json:"default_formula_dsl"`
	IsCore               *bool              `json:"is_core"`
	IsHidden             bool               `json:"is_hidden"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

// Toggle zman visibility with audit
func (q *Queries) AdminToggleZmanVisibilityWithAudit(ctx context.Context, id int32) (AdminToggleZmanVisibilityWithAuditRow, error) {
	row := q.db.QueryRow(ctx, adminToggleZmanVisibilityWithAudit, id)
	var i AdminToggleZmanVisibilityWithAuditRow
	err := row.Scan(
		&i.ID,
		&i.ZmanKey,
		&i.CanonicalHebrewName,
		&i.CanonicalEnglishName,
		&i.Transliteration,
		&i.Description,
		&i.HalachicNotes,
		&i.HalachicSource,
		&i.TimeCategoryID,
		&i.DefaultFormulaDsl,
		&i.IsCore,
		&i.IsHidden,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const adminUpdateMasterZman = `-- name: AdminUpdateMasterZman :one
UPDATE master_zmanim_registry mr
SET
    canonical_hebrew_name = COALESCE($2, mr.canonical_hebrew_name),
    canonical_english_name = COALESCE($3, mr.canonical_english_name),
    transliteration = COALESCE($4, mr.transliteration),
    description = COALESCE($5, mr.description),
    halachic_notes = COALESCE($6, mr.halachic_notes),
    halachic_source = COALESCE($7, mr.halachic_source),
    time_category_id = COALESCE((SELECT tc.id FROM time_categories tc WHERE tc.key = $8), mr.time_category_id),
    default_formula_dsl = COALESCE($9, mr.default_formula_dsl),
    is_core = COALESCE($10, mr.is_core),
    is_hidden = COALESCE($11, mr.is_hidden),
    updated_at = NOW()
WHERE mr.id = $1
RETURNING mr.id, mr.zman_key, mr.canonical_hebrew_name, mr.canonical_english_name,
    mr.transliteration, mr.description, mr.halachic_notes, mr.halachic_source,
    mr.time_category_id, mr.default_formula_dsl, mr.is_core,
    COALESCE(mr.is_hidden, false), mr.created_at, mr.updated_at
`

type AdminUpdateMasterZmanParams struct {
	ID                   int32   `json:"id"`
	CanonicalHebrewName  *string `json:"canonical_hebrew_name"`
	CanonicalEnglishName *string `json:"canonical_english_name"`
	Transliteration      *string `json:"transliteration"`
	Description          *string `json:"description"`
	HalachicNotes        *string `json:"halachic_notes"`
	HalachicSource       *string `json:"halachic_source"`
	TimeCategory         *string `json:"time_category"`
	DefaultFormulaDsl    *string `json:"default_formula_dsl"`
	IsCore               *bool   `json:"is_core"`
	IsHidden             *bool   `json:"is_hidden"`
}

type AdminUpdateMasterZmanRow struct {
	ID                   int32              `json:"id"`
	ZmanKey              string             `json:"zman_key"`
	CanonicalHebrewName  string             `json:"canonical_hebrew_name"`
	CanonicalEnglishName string             `json:"canonical_english_name"`
	Transliteration      *string            `json:"transliteration"`
	Description          *string            `json:"description"`
	HalachicNotes        *string            `json:"halachic_notes"`
	HalachicSource       *string            `json:"halachic_source"`
	TimeCategoryID       *int32             `json:"time_category_id"`
	DefaultFormulaDsl    *string            `json:"default_formula_dsl"`
	IsCore               *bool              `json:"is_core"`
	IsHidden             bool               `json:"is_hidden"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) AdminUpdateMasterZman(ctx context.Context, arg AdminUpdateMasterZmanParams) (AdminUpdateMasterZmanRow, error) {
	row := q.db.QueryRow(ctx, adminUpdateMasterZman,
		arg.ID,
		arg.CanonicalHebrewName,
		arg.CanonicalEnglishName,
		arg.Transliteration,
		arg.Description,
		arg.HalachicNotes,
		arg.HalachicSource,
		arg.TimeCategory,
		arg.DefaultFormulaDsl,
		arg.IsCore,
		arg.IsHidden,
	)
	var i AdminUpdateMasterZmanRow
	err := row.Scan(
		&i.ID,
		&i.ZmanKey,
		&i.CanonicalHebrewName,
		&i.CanonicalEnglishName,
		&i.Transliteration,
		&i.Description,
		&i.HalachicNotes,
		&i.HalachicSource,
		&i.TimeCategoryID,
		&i.DefaultFormulaDsl,
		&i.IsCore,
		&i.IsHidden,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const adminUpdateMasterZmanSimple = `-- name: AdminUpdateMasterZmanSimple :one
UPDATE master_zmanim_registry mr
SET
    canonical_hebrew_name = COALESCE($2, mr.canonical_hebrew_name),
    canonical_english_name = COALESCE($3, mr.canonical_english_name),
    transliteration = COALESCE($4, mr.transliteration),
    description = COALESCE($5, mr.description),
    halachic_notes = COALESCE($6, mr.halachic_notes),
    halachic_source = COALESCE($7, mr.halachic_source),
    time_category_id = COALESCE(
        (SELECT tc.id FROM time_categories tc WHERE tc.key = $8),
        mr.time_category_id
    ),
    default_formula_dsl = COALESCE($9, mr.default_formula_dsl),
    is_core = COALESCE($10, mr.is_core),
    is_hidden = COALESCE($11, mr.is_hidden),
    updated_at = NOW()
WHERE mr.id = $1
RETURNING mr.id, mr.zman_key, mr.canonical_hebrew_name, mr.canonical_english_name,
    mr.transliteration, mr.description, mr.halachic_notes, mr.halachic_source,
    mr.time_category_id, mr.default_formula_dsl, mr.is_core,
    COALESCE(mr.is_hidden, false) as is_hidden, mr.created_at, mr.updated_at
`

type AdminUpdateMasterZmanSimpleParams struct {
	ID                   int32   `json:"id"`
	CanonicalHebrewName  *string `json:"canonical_hebrew_name"`
	CanonicalEnglishName *string `json:"canonical_english_name"`
	Transliteration      *string `json:"transliteration"`
	Description          *string `json:"description"`
	HalachicNotes        *string `json:"halachic_notes"`
	HalachicSource       *string `json:"halachic_source"`
	TimeCategory         *string `json:"time_category"`
	DefaultFormulaDsl    *string `json:"default_formula_dsl"`
	IsCore               *bool   `json:"is_core"`
	IsHidden             *bool   `json:"is_hidden"`
}

type AdminUpdateMasterZmanSimpleRow struct {
	ID                   int32              `json:"id"`
	ZmanKey              string             `json:"zman_key"`
	CanonicalHebrewName  string             `json:"canonical_hebrew_name"`
	CanonicalEnglishName string             `json:"canonical_english_name"`
	Transliteration      *string            `json:"transliteration"`
	Description          *string            `json:"description"`
	HalachicNotes        *string            `json:"halachic_notes"`
	HalachicSource       *string            `json:"halachic_source"`
	TimeCategoryID       *int32             `json:"time_category_id"`
	DefaultFormulaDsl    *string            `json:"default_formula_dsl"`
	IsCore               *bool              `json:"is_core"`
	IsHidden             bool               `json:"is_hidden"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

// Update master zman with all fields (non-dynamic version)
func (q *Queries) AdminUpdateMasterZmanSimple(ctx context.Context, arg AdminUpdateMasterZmanSimpleParams) (AdminUpdateMasterZmanSimpleRow, error) {
	row := q.db.QueryRow(ctx, adminUpdateMasterZmanSimple,
		arg.ID,
		arg.CanonicalHebrewName,
		arg.CanonicalEnglishName,
		arg.Transliteration,
		arg.Description,
		arg.HalachicNotes,
		arg.HalachicSource,
		arg.TimeCategory,
		arg.DefaultFormulaDsl,
		arg.IsCore,
		arg.IsHidden,
	)
	var i AdminUpdateMasterZmanSimpleRow
	err := row.Scan(
		&i.ID,
		&i.ZmanKey,
		&i.CanonicalHebrewName,
		&i.CanonicalEnglishName,
		&i.Transliteration,
		&i.Description,
		&i.HalachicNotes,
		&i.HalachicSource,
		&i.TimeCategoryID,
		&i.DefaultFormulaDsl,
		&i.IsCore,
		&i.IsHidden,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const autoAddApprovedZman = `-- name: AutoAddApprovedZman :exec
INSERT INTO publisher_zmanim (
    id, publisher_id, zman_key, hebrew_name, english_name,
    transliteration, description,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, time_category_id,
    dependencies, current_version
)
VALUES (
    gen_random_uuid(), $1, $2, $3, $4, $5, $6, $7,
    NULL, NULL, true, true, false, true,
    (SELECT id FROM time_categories WHERE key = $8),
    '{}', 1
)
ON CONFLICT (publisher_id, zman_key) DO NOTHING
`

type AutoAddApprovedZmanParams struct {
	PublisherID     int32   `json:"publisher_id"`
	ZmanKey         string  `json:"zman_key"`
	HebrewName      string  `json:"hebrew_name"`
	EnglishName     string  `json:"english_name"`
	Transliteration *string `json:"transliteration"`
	Description     *string `json:"description"`
	FormulaDsl      string  `json:"formula_dsl"`
	Key             string  `json:"key"`
}

// Auto-add approved zman to publisher's collection
func (q *Queries) AutoAddApprovedZman(ctx context.Context, arg AutoAddApprovedZmanParams) error {
	_, err := q.db.Exec(ctx, autoAddApprovedZman,
		arg.PublisherID,
		arg.ZmanKey,
		arg.HebrewName,
		arg.EnglishName,
		arg.Transliteration,
		arg.Description,
		arg.FormulaDsl,
		arg.Key,
	)
	return err
}

const checkMasterZmanInUse = `-- name: CheckMasterZmanInUse :one
SELECT EXISTS(SELECT 1 FROM publisher_zmanim WHERE master_zman_id = $1 AND deleted_at IS NULL)
`

func (q *Queries) CheckMasterZmanInUse(ctx context.Context, masterZmanID *int32) (bool, error) {
	row := q.db.QueryRow(ctx, checkMasterZmanInUse, masterZmanID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkPublisherHasMasterZman = `-- name: CheckPublisherHasMasterZman :one
SELECT EXISTS(
    SELECT 1 FROM publisher_zmanim
    WHERE publisher_id = $1
      AND master_zman_id = $2
      AND deleted_at IS NULL
)
`

type CheckPublisherHasMasterZmanParams struct {
	PublisherID  int32  `json:"publisher_id"`
	MasterZmanID *int32 `json:"master_zman_id"`
}

// Check if a publisher has already imported a specific master zman
func (q *Queries) CheckPublisherHasMasterZman(ctx context.Context, arg CheckPublisherHasMasterZmanParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkPublisherHasMasterZman, arg.PublisherID, arg.MasterZmanID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const copyPublisherZmanFromExample = `-- name: CopyPublisherZmanFromExample :one
INSERT INTO publisher_zmanim (
    publisher_id,
    master_zman_id,
    copied_from_publisher_id,
    zman_key,
    hebrew_name,
    english_name,
    description,
    formula_dsl,
    time_category_id,
    is_visible,
    is_enabled,
    created_at,
    updated_at
) VALUES (
    $1,  -- publisher_id
    $2,  -- master_zman_id
    $3,  -- copied_from_publisher_id (source publisher.id)
    $4,  -- zman_key
    $5,  -- hebrew_name
    $6,  -- english_name
    $7,  -- description
    $8,  -- formula_dsl
    $9,  -- time_category_id
    true, -- is_visible
    true, -- is_enabled
    NOW(),
    NOW()
) RETURNING id, zman_key
`

type CopyPublisherZmanFromExampleParams struct {
	PublisherID           int32   `json:"publisher_id"`
	MasterZmanID          *int32  `json:"master_zman_id"`
	CopiedFromPublisherID *int32  `json:"copied_from_publisher_id"`
	ZmanKey               string  `json:"zman_key"`
	HebrewName            string  `json:"hebrew_name"`
	EnglishName           string  `json:"english_name"`
	Description           *string `json:"description"`
	FormulaDsl            string  `json:"formula_dsl"`
	TimeCategoryID        *int32  `json:"time_category_id"`
}

type CopyPublisherZmanFromExampleRow struct {
	ID      int32  `json:"id"`
	ZmanKey string `json:"zman_key"`
}

// Create a copied publisher zman (independent copy from another publisher)
func (q *Queries) CopyPublisherZmanFromExample(ctx context.Context, arg CopyPublisherZmanFromExampleParams) (CopyPublisherZmanFromExampleRow, error) {
	row := q.db.QueryRow(ctx, copyPublisherZmanFromExample,
		arg.PublisherID,
		arg.MasterZmanID,
		arg.CopiedFromPublisherID,
		arg.ZmanKey,
		arg.HebrewName,
		arg.EnglishName,
		arg.Description,
		arg.FormulaDsl,
		arg.TimeCategoryID,
	)
	var i CopyPublisherZmanFromExampleRow
	err := row.Scan(&i.ID, &i.ZmanKey)
	return i, err
}

const countMasterZmanimForRegistry = `-- name: CountMasterZmanimForRegistry :one
SELECT COUNT(*)
FROM master_zmanim_registry mr
LEFT JOIN time_categories tc ON mr.time_category_id = tc.id
WHERE
    COALESCE(mr.is_hidden, false) = false
    AND ($2::text[] IS NULL OR mr.category = ANY($2::text[]))
    AND ($3::text[] IS NULL OR mr.shita = ANY($3::text[]))
    AND (
        $4::text IS NULL
        OR mr.canonical_hebrew_name ILIKE '%' || $4 || '%'
        OR mr.canonical_english_name ILIKE '%' || $4 || '%'
        OR mr.default_formula_dsl ILIKE '%' || $4 || '%'
        OR mr.zman_key ILIKE '%' || $4 || '%'
        OR mr.transliteration ILIKE '%' || $4 || '%'
    )
    AND (
        $5::text IS NULL
        OR ($5 = 'available' AND NOT EXISTS(SELECT 1 FROM publisher_zmanim pz WHERE pz.publisher_id = $1 AND pz.master_zman_id = mr.id))
        OR ($5 = 'imported' AND EXISTS(SELECT 1 FROM publisher_zmanim pz WHERE pz.publisher_id = $1 AND pz.master_zman_id = mr.id))
    )
`

type CountMasterZmanimForRegistryParams struct {
	PublisherID int32    `json:"publisher_id"`
	Categories  []string `json:"categories"`
	Shitas      []string `json:"shitas"`
	Search      *string  `json:"search"`
	Status      *string  `json:"status"`
}

// Count total master zmanim matching filters (for pagination)
func (q *Queries) CountMasterZmanimForRegistry(ctx context.Context, arg CountMasterZmanimForRegistryParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMasterZmanimForRegistry,
		arg.PublisherID,
		arg.Categories,
		arg.Shitas,
		arg.Search,
		arg.Status,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublisherZmanimForExamples = `-- name: CountPublisherZmanimForExamples :one
SELECT COUNT(*)
FROM publisher_zmanim pz
JOIN master_zmanim_registry mr ON pz.master_zman_id = mr.id
WHERE pz.publisher_id = $1
  AND pz.deleted_at IS NULL
  AND pz.is_visible = true
  AND ($2::text IS NULL OR mr.category = $2::text)
  AND ($3::text IS NULL OR mr.shita = $3::text)
  AND (
      $4::text IS NULL
      OR pz.hebrew_name ILIKE '%' || $4 || '%'
      OR pz.english_name ILIKE '%' || $4 || '%'
      OR pz.zman_key ILIKE '%' || $4 || '%'
  )
`

type CountPublisherZmanimForExamplesParams struct {
	PublisherID int32   `json:"publisher_id"`
	Category    *string `json:"category"`
	Shita       *string `json:"shita"`
	Search      *string `json:"search"`
}

// Count publisher's zmanim matching filters
func (q *Queries) CountPublisherZmanimForExamples(ctx context.Context, arg CountPublisherZmanimForExamplesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPublisherZmanimForExamples,
		arg.PublisherID,
		arg.Category,
		arg.Shita,
		arg.Search,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInitialZmanVersion = `-- name: CreateInitialZmanVersion :exec
INSERT INTO publisher_zman_versions (publisher_zman_id, version_number, formula_dsl)
VALUES ($1, 1, $2)
`

type CreateInitialZmanVersionParams struct {
	PublisherZmanID int32   `json:"publisher_zman_id"`
	FormulaDsl      *string `json:"formula_dsl"`
}

// Create initial version for a new publisher zman
func (q *Queries) CreateInitialZmanVersion(ctx context.Context, arg CreateInitialZmanVersionParams) error {
	_, err := q.db.Exec(ctx, createInitialZmanVersion, arg.PublisherZmanID, arg.FormulaDsl)
	return err
}

const createPublisherZmanFromMasterWithFormula = `-- name: CreatePublisherZmanFromMasterWithFormula :one
INSERT INTO publisher_zmanim (
    publisher_id, zman_key, hebrew_name, english_name,
    transliteration, description,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, time_category_id,
    dependencies, master_zman_id, current_version
)
SELECT
    $1,
    mr.zman_key,
    mr.canonical_hebrew_name,
    mr.canonical_english_name,
    mr.transliteration,
    mr.description,
    $3,
    NULL,
    NULL,
    true,
    true,
    false,
    false,
    mr.time_category_id,
    '{}',
    mr.id,
    1
FROM master_zmanim_registry mr
WHERE mr.id = $2
RETURNING id, publisher_id, zman_key, hebrew_name, english_name,
    transliteration, description, formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, time_category_id,
    dependencies, created_at, updated_at, master_zman_id, current_version
`

type CreatePublisherZmanFromMasterWithFormulaParams struct {
	PublisherID int32  `json:"publisher_id"`
	ID          int32  `json:"id"`
	FormulaDsl  string `json:"formula_dsl"`
}

type CreatePublisherZmanFromMasterWithFormulaRow struct {
	ID               int32              `json:"id"`
	PublisherID      int32              `json:"publisher_id"`
	ZmanKey          string             `json:"zman_key"`
	HebrewName       string             `json:"hebrew_name"`
	EnglishName      string             `json:"english_name"`
	Transliteration  *string            `json:"transliteration"`
	Description      *string            `json:"description"`
	FormulaDsl       string             `json:"formula_dsl"`
	AiExplanation    *string            `json:"ai_explanation"`
	PublisherComment *string            `json:"publisher_comment"`
	IsEnabled        bool               `json:"is_enabled"`
	IsVisible        bool               `json:"is_visible"`
	IsPublished      bool               `json:"is_published"`
	IsCustom         bool               `json:"is_custom"`
	TimeCategoryID   *int32             `json:"time_category_id"`
	Dependencies     []string           `json:"dependencies"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	MasterZmanID     *int32             `json:"master_zman_id"`
	CurrentVersion   *int32             `json:"current_version"`
}

// Create publisher zman from master registry with custom formula
func (q *Queries) CreatePublisherZmanFromMasterWithFormula(ctx context.Context, arg CreatePublisherZmanFromMasterWithFormulaParams) (CreatePublisherZmanFromMasterWithFormulaRow, error) {
	row := q.db.QueryRow(ctx, createPublisherZmanFromMasterWithFormula, arg.PublisherID, arg.ID, arg.FormulaDsl)
	var i CreatePublisherZmanFromMasterWithFormulaRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.Transliteration,
		&i.Description,
		&i.FormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsCustom,
		&i.TimeCategoryID,
		&i.Dependencies,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MasterZmanID,
		&i.CurrentVersion,
	)
	return i, err
}

const createPublisherZmanFromRegistry = `-- name: CreatePublisherZmanFromRegistry :one
INSERT INTO publisher_zmanim (
    id, publisher_id, zman_key, hebrew_name, english_name,
    transliteration, description,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, time_category_id,
    dependencies, master_zman_id, current_version
)
SELECT
    gen_random_uuid() AS id,
    $1 AS publisher_id,
    mr.zman_key AS zman_key,
    mr.canonical_hebrew_name AS hebrew_name,
    mr.canonical_english_name AS english_name,
    mr.transliteration AS transliteration,
    mr.description AS description,
    COALESCE($3, mr.default_formula_dsl) AS formula_dsl,
    NULL AS ai_explanation,
    NULL AS publisher_comment,
    true AS is_enabled,
    true AS is_visible,
    false AS is_published,
    false AS is_custom,
    tc.id AS time_category_id,
    '{}'::text[] AS dependencies,
    mr.id AS master_zman_id,
    1 AS current_version
FROM master_zmanim_registry mr
LEFT JOIN time_categories tc ON mr.time_category_id = tc.id
WHERE mr.id = $2
RETURNING id, publisher_id, zman_key, hebrew_name, english_name,
    transliteration, description, formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, time_category_id,
    dependencies, created_at, updated_at, master_zman_id, current_version
`

type CreatePublisherZmanFromRegistryParams struct {
	PublisherID int32   `json:"publisher_id"`
	ID          int32   `json:"id"`
	FormulaDsl  *string `json:"formula_dsl"`
}

type CreatePublisherZmanFromRegistryRow struct {
	ID               int32              `json:"id"`
	PublisherID      int32              `json:"publisher_id"`
	ZmanKey          string             `json:"zman_key"`
	HebrewName       string             `json:"hebrew_name"`
	EnglishName      string             `json:"english_name"`
	Transliteration  *string            `json:"transliteration"`
	Description      *string            `json:"description"`
	FormulaDsl       string             `json:"formula_dsl"`
	AiExplanation    *string            `json:"ai_explanation"`
	PublisherComment *string            `json:"publisher_comment"`
	IsEnabled        bool               `json:"is_enabled"`
	IsVisible        bool               `json:"is_visible"`
	IsPublished      bool               `json:"is_published"`
	IsCustom         bool               `json:"is_custom"`
	TimeCategoryID   *int32             `json:"time_category_id"`
	Dependencies     []string           `json:"dependencies"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	MasterZmanID     *int32             `json:"master_zman_id"`
	CurrentVersion   *int32             `json:"current_version"`
}

func (q *Queries) CreatePublisherZmanFromRegistry(ctx context.Context, arg CreatePublisherZmanFromRegistryParams) (CreatePublisherZmanFromRegistryRow, error) {
	row := q.db.QueryRow(ctx, createPublisherZmanFromRegistry, arg.PublisherID, arg.ID, arg.FormulaDsl)
	var i CreatePublisherZmanFromRegistryRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.Transliteration,
		&i.Description,
		&i.FormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsCustom,
		&i.TimeCategoryID,
		&i.Dependencies,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MasterZmanID,
		&i.CurrentVersion,
	)
	return i, err
}

const createVersionForRollback = `-- name: CreateVersionForRollback :exec
INSERT INTO publisher_zman_versions (publisher_zman_id, version_number, formula_dsl, created_by)
SELECT
    pz.id,
    COALESCE((SELECT MAX(version_number) FROM publisher_zman_versions WHERE publisher_zman_id = pz.id), 0) + 1,
    $3,
    $4
FROM publisher_zmanim pz
WHERE pz.publisher_id = $1 AND pz.zman_key = $2
`

type CreateVersionForRollbackParams struct {
	PublisherID int32   `json:"publisher_id"`
	ZmanKey     string  `json:"zman_key"`
	FormulaDsl  *string `json:"formula_dsl"`
	CreatedBy   *string `json:"created_by"`
}

// Create a new version entry for rollback
func (q *Queries) CreateVersionForRollback(ctx context.Context, arg CreateVersionForRollbackParams) error {
	_, err := q.db.Exec(ctx, createVersionForRollback,
		arg.PublisherID,
		arg.ZmanKey,
		arg.FormulaDsl,
		arg.CreatedBy,
	)
	return err
}

const createZmanRegistryRequest = `-- name: CreateZmanRegistryRequest :one

INSERT INTO zman_registry_requests (
    publisher_id,
    requested_key,
    requested_hebrew_name,
    requested_english_name,
    requested_formula_dsl,
    time_category_id,
    description,
    status_id
) VALUES (
    $1, $2, $3, $4, $5,
    (SELECT tc.id FROM time_categories tc WHERE tc.key = $6),
    $7,
    (SELECT rs.id FROM request_statuses rs WHERE rs.key = 'pending')
)
RETURNING id, publisher_id, requested_key, requested_hebrew_name, requested_english_name,
    requested_formula_dsl, time_category_id, description, status_id, created_at
`

type CreateZmanRegistryRequestParams struct {
	PublisherID          int32   `json:"publisher_id"`
	RequestedKey         string  `json:"requested_key"`
	RequestedHebrewName  string  `json:"requested_hebrew_name"`
	RequestedEnglishName string  `json:"requested_english_name"`
	RequestedFormulaDsl  *string `json:"requested_formula_dsl"`
	Key                  string  `json:"key"`
	Description          *string `json:"description"`
}

type CreateZmanRegistryRequestRow struct {
	ID                   int32              `json:"id"`
	PublisherID          int32              `json:"publisher_id"`
	RequestedKey         string             `json:"requested_key"`
	RequestedHebrewName  string             `json:"requested_hebrew_name"`
	RequestedEnglishName string             `json:"requested_english_name"`
	RequestedFormulaDsl  *string            `json:"requested_formula_dsl"`
	TimeCategoryID       int32              `json:"time_category_id"`
	Description          *string            `json:"description"`
	StatusID             int16              `json:"status_id"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
}

// ============================================
// ZMAN REGISTRY REQUESTS
// ============================================
func (q *Queries) CreateZmanRegistryRequest(ctx context.Context, arg CreateZmanRegistryRequestParams) (CreateZmanRegistryRequestRow, error) {
	row := q.db.QueryRow(ctx, createZmanRegistryRequest,
		arg.PublisherID,
		arg.RequestedKey,
		arg.RequestedHebrewName,
		arg.RequestedEnglishName,
		arg.RequestedFormulaDsl,
		arg.Key,
		arg.Description,
	)
	var i CreateZmanRegistryRequestRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.RequestedKey,
		&i.RequestedHebrewName,
		&i.RequestedEnglishName,
		&i.RequestedFormulaDsl,
		&i.TimeCategoryID,
		&i.Description,
		&i.StatusID,
		&i.CreatedAt,
	)
	return i, err
}

const createZmanRegistryRequestFull = `-- name: CreateZmanRegistryRequestFull :one
INSERT INTO zman_registry_requests (
    publisher_id, requested_key, requested_hebrew_name, requested_english_name,
    transliteration, requested_formula_dsl, time_category_id, description,
    halachic_notes, halachic_source, auto_add_on_approval, status_id
) VALUES (
    $1, $2, $3, $4, $5, $6,
    (SELECT tc.id FROM time_categories tc WHERE tc.key = $7),
    $8, $9, $10, $11,
    (SELECT rs.id FROM request_statuses rs WHERE rs.key = 'pending')
)
RETURNING id, publisher_id, requested_key, requested_hebrew_name, requested_english_name,
    requested_formula_dsl, time_category_id, description, status_id, created_at
`

type CreateZmanRegistryRequestFullParams struct {
	PublisherID          int32   `json:"publisher_id"`
	RequestedKey         string  `json:"requested_key"`
	RequestedHebrewName  string  `json:"requested_hebrew_name"`
	RequestedEnglishName string  `json:"requested_english_name"`
	Transliteration      *string `json:"transliteration"`
	RequestedFormulaDsl  *string `json:"requested_formula_dsl"`
	Key                  string  `json:"key"`
	Description          *string `json:"description"`
	HalachicNotes        *string `json:"halachic_notes"`
	HalachicSource       *string `json:"halachic_source"`
	AutoAddOnApproval    *bool   `json:"auto_add_on_approval"`
}

type CreateZmanRegistryRequestFullRow struct {
	ID                   int32              `json:"id"`
	PublisherID          int32              `json:"publisher_id"`
	RequestedKey         string             `json:"requested_key"`
	RequestedHebrewName  string             `json:"requested_hebrew_name"`
	RequestedEnglishName string             `json:"requested_english_name"`
	RequestedFormulaDsl  *string            `json:"requested_formula_dsl"`
	TimeCategoryID       int32              `json:"time_category_id"`
	Description          *string            `json:"description"`
	StatusID             int16              `json:"status_id"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
}

// Create a new zman registry request with all fields
func (q *Queries) CreateZmanRegistryRequestFull(ctx context.Context, arg CreateZmanRegistryRequestFullParams) (CreateZmanRegistryRequestFullRow, error) {
	row := q.db.QueryRow(ctx, createZmanRegistryRequestFull,
		arg.PublisherID,
		arg.RequestedKey,
		arg.RequestedHebrewName,
		arg.RequestedEnglishName,
		arg.Transliteration,
		arg.RequestedFormulaDsl,
		arg.Key,
		arg.Description,
		arg.HalachicNotes,
		arg.HalachicSource,
		arg.AutoAddOnApproval,
	)
	var i CreateZmanRegistryRequestFullRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.RequestedKey,
		&i.RequestedHebrewName,
		&i.RequestedEnglishName,
		&i.RequestedFormulaDsl,
		&i.TimeCategoryID,
		&i.Description,
		&i.StatusID,
		&i.CreatedAt,
	)
	return i, err
}

const createZmanVersion = `-- name: CreateZmanVersion :one
INSERT INTO publisher_zman_versions (
    publisher_zman_id,
    version_number,
    formula_dsl,
    created_by
)
SELECT
    pz.id,
    COALESCE((SELECT MAX(version_number) FROM publisher_zman_versions WHERE publisher_zman_id = pz.id), 0) + 1,
    $3,
    $4
FROM publisher_zmanim pz
WHERE pz.publisher_id = $1 AND pz.zman_key = $2
RETURNING id, publisher_zman_id, version_number, formula_dsl, created_by, created_at
`

type CreateZmanVersionParams struct {
	PublisherID int32   `json:"publisher_id"`
	ZmanKey     string  `json:"zman_key"`
	FormulaDsl  *string `json:"formula_dsl"`
	CreatedBy   *string `json:"created_by"`
}

type CreateZmanVersionRow struct {
	ID              int32              `json:"id"`
	PublisherZmanID int32              `json:"publisher_zman_id"`
	VersionNumber   int32              `json:"version_number"`
	FormulaDsl      *string            `json:"formula_dsl"`
	CreatedBy       *string            `json:"created_by"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateZmanVersion(ctx context.Context, arg CreateZmanVersionParams) (CreateZmanVersionRow, error) {
	row := q.db.QueryRow(ctx, createZmanVersion,
		arg.PublisherID,
		arg.ZmanKey,
		arg.FormulaDsl,
		arg.CreatedBy,
	)
	var i CreateZmanVersionRow
	err := row.Scan(
		&i.ID,
		&i.PublisherZmanID,
		&i.VersionNumber,
		&i.FormulaDsl,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const deleteMasterZmanTags = `-- name: DeleteMasterZmanTags :exec

DELETE FROM master_zman_tags WHERE master_zman_id = $1
`

// ============================================
// TAG MANAGEMENT QUERIES
// ============================================
func (q *Queries) DeleteMasterZmanTags(ctx context.Context, masterZmanID int32) error {
	_, err := q.db.Exec(ctx, deleteMasterZmanTags, masterZmanID)
	return err
}

const getAllAstronomicalPrimitives = `-- name: GetAllAstronomicalPrimitives :many

SELECT
    ap.id, ap.variable_name, ap.display_name, ap.description, ap.formula_dsl,
    pc.key as category,
    ap.sort_order, ap.created_at, ap.updated_at
FROM astronomical_primitives ap
LEFT JOIN primitive_categories pc ON ap.category_id = pc.id
ORDER BY ap.sort_order, ap.variable_name
`

type GetAllAstronomicalPrimitivesRow struct {
	ID           int32              `json:"id"`
	VariableName string             `json:"variable_name"`
	DisplayName  string             `json:"display_name"`
	Description  *string            `json:"description"`
	FormulaDsl   string             `json:"formula_dsl"`
	Category     *string            `json:"category"`
	SortOrder    *int32             `json:"sort_order"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

// ============================================
// ASTRONOMICAL PRIMITIVES QUERIES
// ============================================
func (q *Queries) GetAllAstronomicalPrimitives(ctx context.Context) ([]GetAllAstronomicalPrimitivesRow, error) {
	rows, err := q.db.Query(ctx, getAllAstronomicalPrimitives)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllAstronomicalPrimitivesRow{}
	for rows.Next() {
		var i GetAllAstronomicalPrimitivesRow
		if err := rows.Scan(
			&i.ID,
			&i.VariableName,
			&i.DisplayName,
			&i.Description,
			&i.FormulaDsl,
			&i.Category,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllMasterZmanim = `-- name: GetAllMasterZmanim :many


SELECT
    mr.id, mr.zman_key, mr.canonical_hebrew_name, mr.canonical_english_name,
    mr.transliteration, mr.description, mr.halachic_notes, mr.halachic_source,
    tc.key as time_category, mr.default_formula_dsl, mr.is_core,
    mr.created_at, mr.updated_at
FROM master_zmanim_registry mr
LEFT JOIN time_categories tc ON mr.time_category_id = tc.id
ORDER BY
    tc.sort_order,
    mr.canonical_hebrew_name
`

type GetAllMasterZmanimRow struct {
	ID                   int32              `json:"id"`
	ZmanKey              string             `json:"zman_key"`
	CanonicalHebrewName  string             `json:"canonical_hebrew_name"`
	CanonicalEnglishName string             `json:"canonical_english_name"`
	Transliteration      *string            `json:"transliteration"`
	Description          *string            `json:"description"`
	HalachicNotes        *string            `json:"halachic_notes"`
	HalachicSource       *string            `json:"halachic_source"`
	TimeCategory         *string            `json:"time_category"`
	DefaultFormulaDsl    *string            `json:"default_formula_dsl"`
	IsCore               *bool              `json:"is_core"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

// Master Zmanim Registry SQL Queries
// SQLc will generate type-safe Go code from these queries
// ============================================
// MASTER REGISTRY QUERIES
// ============================================
// Orders by time_category (chronological) then hebrew_name
func (q *Queries) GetAllMasterZmanim(ctx context.Context) ([]GetAllMasterZmanimRow, error) {
	rows, err := q.db.Query(ctx, getAllMasterZmanim)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllMasterZmanimRow{}
	for rows.Next() {
		var i GetAllMasterZmanimRow
		if err := rows.Scan(
			&i.ID,
			&i.ZmanKey,
			&i.CanonicalHebrewName,
			&i.CanonicalEnglishName,
			&i.Transliteration,
			&i.Description,
			&i.HalachicNotes,
			&i.HalachicSource,
			&i.TimeCategory,
			&i.DefaultFormulaDsl,
			&i.IsCore,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTags = `-- name: GetAllTags :many

SELECT
    zt.id, zt.tag_key, zt.display_name_hebrew,
    zt.display_name_english_ashkenazi, zt.display_name_english_sephardi,
    tt.key as tag_type, zt.description, zt.color, zt.created_at
FROM zman_tags zt
LEFT JOIN tag_types tt ON zt.tag_type_id = tt.id
WHERE zt.is_hidden = false
ORDER BY tt.sort_order, zt.tag_key
`

type GetAllTagsRow struct {
	ID                          int32              `json:"id"`
	TagKey                      string             `json:"tag_key"`
	DisplayNameHebrew           string             `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string             `json:"display_name_english_ashkenazi"`
	DisplayNameEnglishSephardi  *string            `json:"display_name_english_sephardi"`
	TagType                     *string            `json:"tag_type"`
	Description                 *string            `json:"description"`
	Color                       *string            `json:"color"`
	CreatedAt                   pgtype.Timestamptz `json:"created_at"`
}

// ============================================
// TAG QUERIES
// ============================================
// User-facing query - excludes hidden tags
func (q *Queries) GetAllTags(ctx context.Context) ([]GetAllTagsRow, error) {
	rows, err := q.db.Query(ctx, getAllTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllTagsRow{}
	for rows.Next() {
		var i GetAllTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.TagKey,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglishAshkenazi,
			&i.DisplayNameEnglishSephardi,
			&i.TagType,
			&i.Description,
			&i.Color,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTagsAdmin = `-- name: GetAllTagsAdmin :many
SELECT zt.id, zt.tag_key, zt.display_name_hebrew,
    zt.display_name_english_ashkenazi, zt.display_name_english_sephardi,
    tt.key as tag_type, zt.description, zt.color, zt.created_at,
    zt.is_hidden
FROM zman_tags zt
LEFT JOIN tag_types tt ON zt.tag_type_id = tt.id
ORDER BY tt.sort_order, zt.tag_key
`

type GetAllTagsAdminRow struct {
	ID                          int32              `json:"id"`
	TagKey                      string             `json:"tag_key"`
	DisplayNameHebrew           string             `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string             `json:"display_name_english_ashkenazi"`
	DisplayNameEnglishSephardi  *string            `json:"display_name_english_sephardi"`
	TagType                     *string            `json:"tag_type"`
	Description                 *string            `json:"description"`
	Color                       *string            `json:"color"`
	CreatedAt                   pgtype.Timestamptz `json:"created_at"`
	IsHidden                    bool               `json:"is_hidden"`
}

// Get all zman tags for admin (includes hidden tags and is_hidden flag)
func (q *Queries) GetAllTagsAdmin(ctx context.Context) ([]GetAllTagsAdminRow, error) {
	rows, err := q.db.Query(ctx, getAllTagsAdmin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllTagsAdminRow{}
	for rows.Next() {
		var i GetAllTagsAdminRow
		if err := rows.Scan(
			&i.ID,
			&i.TagKey,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglishAshkenazi,
			&i.DisplayNameEnglishSephardi,
			&i.TagType,
			&i.Description,
			&i.Color,
			&i.CreatedAt,
			&i.IsHidden,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTagsOrdered = `-- name: GetAllTagsOrdered :many

SELECT zt.id, zt.tag_key, zt.display_name_hebrew,
    zt.display_name_english_ashkenazi, zt.display_name_english_sephardi,
    tt.key as tag_type, zt.description, zt.color, zt.created_at
FROM zman_tags zt
LEFT JOIN tag_types tt ON zt.tag_type_id = tt.id
WHERE zt.is_hidden = false
ORDER BY
    CASE tt.key
        WHEN 'event' THEN 1
        WHEN 'timing' THEN 2
        WHEN 'shita' THEN 3
        WHEN 'category' THEN 4
        ELSE 5
    END,
    zt.tag_key
`

type GetAllTagsOrderedRow struct {
	ID                          int32              `json:"id"`
	TagKey                      string             `json:"tag_key"`
	DisplayNameHebrew           string             `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string             `json:"display_name_english_ashkenazi"`
	DisplayNameEnglishSephardi  *string            `json:"display_name_english_sephardi"`
	TagType                     *string            `json:"tag_type"`
	Description                 *string            `json:"description"`
	Color                       *string            `json:"color"`
	CreatedAt                   pgtype.Timestamptz `json:"created_at"`
}

// ============================================
// TAG QUERIES (ADDITIONAL)
// ============================================
// Get all tags with custom sorting by tag type (user-facing - excludes hidden tags)
func (q *Queries) GetAllTagsOrdered(ctx context.Context) ([]GetAllTagsOrderedRow, error) {
	rows, err := q.db.Query(ctx, getAllTagsOrdered)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllTagsOrderedRow{}
	for rows.Next() {
		var i GetAllTagsOrderedRow
		if err := rows.Scan(
			&i.ID,
			&i.TagKey,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglishAshkenazi,
			&i.DisplayNameEnglishSephardi,
			&i.TagType,
			&i.Description,
			&i.Color,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAstronomicalPrimitiveByName = `-- name: GetAstronomicalPrimitiveByName :one
SELECT
    ap.id, ap.variable_name, ap.display_name, ap.description, ap.formula_dsl,
    pc.key as category,
    ap.sort_order, ap.created_at, ap.updated_at
FROM astronomical_primitives ap
LEFT JOIN primitive_categories pc ON ap.category_id = pc.id
WHERE ap.variable_name = $1
`

type GetAstronomicalPrimitiveByNameRow struct {
	ID           int32              `json:"id"`
	VariableName string             `json:"variable_name"`
	DisplayName  string             `json:"display_name"`
	Description  *string            `json:"description"`
	FormulaDsl   string             `json:"formula_dsl"`
	Category     *string            `json:"category"`
	SortOrder    *int32             `json:"sort_order"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetAstronomicalPrimitiveByName(ctx context.Context, variableName string) (GetAstronomicalPrimitiveByNameRow, error) {
	row := q.db.QueryRow(ctx, getAstronomicalPrimitiveByName, variableName)
	var i GetAstronomicalPrimitiveByNameRow
	err := row.Scan(
		&i.ID,
		&i.VariableName,
		&i.DisplayName,
		&i.Description,
		&i.FormulaDsl,
		&i.Category,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAstronomicalPrimitivesByCategory = `-- name: GetAstronomicalPrimitivesByCategory :many
SELECT
    ap.id, ap.variable_name, ap.display_name, ap.description, ap.formula_dsl,
    pc.key as category,
    ap.sort_order, ap.created_at, ap.updated_at
FROM astronomical_primitives ap
LEFT JOIN primitive_categories pc ON ap.category_id = pc.id
WHERE pc.key = $1
ORDER BY ap.sort_order, ap.variable_name
`

type GetAstronomicalPrimitivesByCategoryRow struct {
	ID           int32              `json:"id"`
	VariableName string             `json:"variable_name"`
	DisplayName  string             `json:"display_name"`
	Description  *string            `json:"description"`
	FormulaDsl   string             `json:"formula_dsl"`
	Category     *string            `json:"category"`
	SortOrder    *int32             `json:"sort_order"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetAstronomicalPrimitivesByCategory(ctx context.Context, key string) ([]GetAstronomicalPrimitivesByCategoryRow, error) {
	rows, err := q.db.Query(ctx, getAstronomicalPrimitivesByCategory, key)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAstronomicalPrimitivesByCategoryRow{}
	for rows.Next() {
		var i GetAstronomicalPrimitivesByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.VariableName,
			&i.DisplayName,
			&i.Description,
			&i.FormulaDsl,
			&i.Category,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAstronomicalPrimitivesGrouped = `-- name: GetAstronomicalPrimitivesGrouped :many
SELECT
    ap.id, ap.variable_name, ap.display_name, ap.description, ap.formula_dsl,
    pc.key as category,
    ap.sort_order, ap.created_at, ap.updated_at
FROM astronomical_primitives ap
LEFT JOIN primitive_categories pc ON ap.category_id = pc.id
ORDER BY
    CASE pc.key
        WHEN 'horizon' THEN 1
        WHEN 'civil_twilight' THEN 2
        WHEN 'nautical_twilight' THEN 3
        WHEN 'astronomical_twilight' THEN 4
        WHEN 'solar_position' THEN 5
        ELSE 6
    END,
    ap.sort_order,
    ap.variable_name
`

type GetAstronomicalPrimitivesGroupedRow struct {
	ID           int32              `json:"id"`
	VariableName string             `json:"variable_name"`
	DisplayName  string             `json:"display_name"`
	Description  *string            `json:"description"`
	FormulaDsl   string             `json:"formula_dsl"`
	Category     *string            `json:"category"`
	SortOrder    *int32             `json:"sort_order"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

// Returns primitives with category for grouping in UI
func (q *Queries) GetAstronomicalPrimitivesGrouped(ctx context.Context) ([]GetAstronomicalPrimitivesGroupedRow, error) {
	rows, err := q.db.Query(ctx, getAstronomicalPrimitivesGrouped)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAstronomicalPrimitivesGroupedRow{}
	for rows.Next() {
		var i GetAstronomicalPrimitivesGroupedRow
		if err := rows.Scan(
			&i.ID,
			&i.VariableName,
			&i.DisplayName,
			&i.Description,
			&i.FormulaDsl,
			&i.Category,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeletedPublisherZmanim = `-- name: GetDeletedPublisherZmanim :many
SELECT
    pz.id,
    pz.publisher_id,
    pz.zman_key,
    COALESCE(mr.canonical_hebrew_name, pz.hebrew_name) AS hebrew_name,
    COALESCE(mr.canonical_english_name, pz.english_name) AS english_name,
    pz.formula_dsl,
    pz.deleted_at,
    pz.deleted_by,
    tc.key AS time_category,
    pz.master_zman_id
FROM publisher_zmanim pz
LEFT JOIN master_zmanim_registry mr ON pz.master_zman_id = mr.id
LEFT JOIN time_categories tc ON pz.time_category_id = tc.id
WHERE pz.publisher_id = $1
  AND pz.deleted_at IS NOT NULL
ORDER BY pz.deleted_at DESC
`

type GetDeletedPublisherZmanimRow struct {
	ID           int32              `json:"id"`
	PublisherID  int32              `json:"publisher_id"`
	ZmanKey      string             `json:"zman_key"`
	HebrewName   string             `json:"hebrew_name"`
	EnglishName  string             `json:"english_name"`
	FormulaDsl   string             `json:"formula_dsl"`
	DeletedAt    pgtype.Timestamptz `json:"deleted_at"`
	DeletedBy    *string            `json:"deleted_by"`
	TimeCategory *string            `json:"time_category"`
	MasterZmanID *int32             `json:"master_zman_id"`
}

func (q *Queries) GetDeletedPublisherZmanim(ctx context.Context, publisherID int32) ([]GetDeletedPublisherZmanimRow, error) {
	rows, err := q.db.Query(ctx, getDeletedPublisherZmanim, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDeletedPublisherZmanimRow{}
	for rows.Next() {
		var i GetDeletedPublisherZmanimRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.FormulaDsl,
			&i.DeletedAt,
			&i.DeletedBy,
			&i.TimeCategory,
			&i.MasterZmanID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeletedZmanByKeyForAudit = `-- name: GetDeletedZmanByKeyForAudit :one
SELECT
    pz.id,
    pz.publisher_id,
    pz.zman_key,
    COALESCE(mr.canonical_hebrew_name, pz.hebrew_name) AS hebrew_name,
    COALESCE(mr.canonical_english_name, pz.english_name) AS english_name,
    pz.formula_dsl,
    pz.is_enabled,
    pz.is_visible,
    pz.deleted_at,
    pz.deleted_by,
    tc.key AS time_category,
    pz.master_zman_id
FROM publisher_zmanim pz
LEFT JOIN master_zmanim_registry mr ON pz.master_zman_id = mr.id
LEFT JOIN time_categories tc ON pz.time_category_id = tc.id
WHERE pz.publisher_id = $1 AND pz.zman_key = $2 AND pz.deleted_at IS NOT NULL
`

type GetDeletedZmanByKeyForAuditParams struct {
	PublisherID int32  `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

type GetDeletedZmanByKeyForAuditRow struct {
	ID           int32              `json:"id"`
	PublisherID  int32              `json:"publisher_id"`
	ZmanKey      string             `json:"zman_key"`
	HebrewName   string             `json:"hebrew_name"`
	EnglishName  string             `json:"english_name"`
	FormulaDsl   string             `json:"formula_dsl"`
	IsEnabled    bool               `json:"is_enabled"`
	IsVisible    bool               `json:"is_visible"`
	DeletedAt    pgtype.Timestamptz `json:"deleted_at"`
	DeletedBy    *string            `json:"deleted_by"`
	TimeCategory *string            `json:"time_category"`
	MasterZmanID *int32             `json:"master_zman_id"`
}

// Get a single deleted zman's details for audit logging before restore
func (q *Queries) GetDeletedZmanByKeyForAudit(ctx context.Context, arg GetDeletedZmanByKeyForAuditParams) (GetDeletedZmanByKeyForAuditRow, error) {
	row := q.db.QueryRow(ctx, getDeletedZmanByKeyForAudit, arg.PublisherID, arg.ZmanKey)
	var i GetDeletedZmanByKeyForAuditRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.FormulaDsl,
		&i.IsEnabled,
		&i.IsVisible,
		&i.DeletedAt,
		&i.DeletedBy,
		&i.TimeCategory,
		&i.MasterZmanID,
	)
	return i, err
}

const getDistinctCategories = `-- name: GetDistinctCategories :many
SELECT DISTINCT category
FROM master_zmanim_registry
WHERE category IS NOT NULL AND COALESCE(is_hidden, false) = false
ORDER BY category
`

// Get all distinct non-null categories for filter dropdown
func (q *Queries) GetDistinctCategories(ctx context.Context) ([]*string, error) {
	rows, err := q.db.Query(ctx, getDistinctCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*string{}
	for rows.Next() {
		var category *string
		if err := rows.Scan(&category); err != nil {
			return nil, err
		}
		items = append(items, category)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistinctShitas = `-- name: GetDistinctShitas :many
SELECT DISTINCT shita
FROM master_zmanim_registry
WHERE shita IS NOT NULL AND COALESCE(is_hidden, false) = false
ORDER BY shita
`

// Get all distinct non-null shitas for filter dropdown
func (q *Queries) GetDistinctShitas(ctx context.Context) ([]*string, error) {
	rows, err := q.db.Query(ctx, getDistinctShitas)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*string{}
	for rows.Next() {
		var shita *string
		if err := rows.Scan(&shita); err != nil {
			return nil, err
		}
		items = append(items, shita)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventZmanim = `-- name: GetEventZmanim :many

SELECT mz.id, mz.zman_key, mz.canonical_hebrew_name, mz.canonical_english_name,
    mz.transliteration, mz.description, mz.halachic_notes, mz.halachic_source,
    tc.key as time_category, mz.default_formula_dsl, mz.is_core,
    mz.created_at, mz.updated_at,
    COALESCE(
        (SELECT json_agg(json_build_object(
            'id', t.id,
            'tag_key', t.tag_key,
            'display_name_hebrew', t.display_name_hebrew,
            'display_name_english_ashkenazi', t.display_name_english_ashkenazi,
            'display_name_english_sephardi', t.display_name_english_sephardi,
            'tag_type', tt.key
        ) ORDER BY tt.sort_order, t.tag_key)
        FROM master_zman_tags mt
        JOIN zman_tags t ON mt.tag_id = t.id
        JOIN tag_types tt ON t.tag_type_id = tt.id
        WHERE mt.master_zman_id = mz.id),
        '[]'::json
    ) AS tags
FROM master_zmanim_registry mz
LEFT JOIN time_categories tc ON mz.time_category_id = tc.id
WHERE EXISTS (
    SELECT 1 FROM master_zman_tags mzt
    JOIN zman_tags t ON mzt.tag_id = t.id
    JOIN tag_types tt ON t.tag_type_id = tt.id
    WHERE mzt.master_zman_id = mz.id
    AND tt.key = 'event'
)
AND COALESCE(mz.is_hidden, false) = false
ORDER BY tc.sort_order, mz.canonical_hebrew_name
`

type GetEventZmanimRow struct {
	ID                   int32              `json:"id"`
	ZmanKey              string             `json:"zman_key"`
	CanonicalHebrewName  string             `json:"canonical_hebrew_name"`
	CanonicalEnglishName string             `json:"canonical_english_name"`
	Transliteration      *string            `json:"transliteration"`
	Description          *string            `json:"description"`
	HalachicNotes        *string            `json:"halachic_notes"`
	HalachicSource       *string            `json:"halachic_source"`
	TimeCategory         *string            `json:"time_category"`
	DefaultFormulaDsl    *string            `json:"default_formula_dsl"`
	IsCore               *bool              `json:"is_core"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	Tags                 interface{}        `json:"tags"`
}

// ============================================
// ADDITIONAL MASTER REGISTRY QUERIES
// ============================================
// Get all event zmanim (those with tag_type = 'event')
func (q *Queries) GetEventZmanim(ctx context.Context) ([]GetEventZmanimRow, error) {
	rows, err := q.db.Query(ctx, getEventZmanim)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventZmanimRow{}
	for rows.Next() {
		var i GetEventZmanimRow
		if err := rows.Scan(
			&i.ID,
			&i.ZmanKey,
			&i.CanonicalHebrewName,
			&i.CanonicalEnglishName,
			&i.Transliteration,
			&i.Description,
			&i.HalachicNotes,
			&i.HalachicSource,
			&i.TimeCategory,
			&i.DefaultFormulaDsl,
			&i.IsCore,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEverydayMasterZmanim = `-- name: GetEverydayMasterZmanim :many
SELECT
    mr.id, mr.zman_key, mr.canonical_hebrew_name, mr.canonical_english_name,
    mr.transliteration, mr.description, mr.halachic_notes, mr.halachic_source,
    tc.key as time_category, mr.default_formula_dsl, mr.is_core,
    mr.created_at, mr.updated_at
FROM master_zmanim_registry mr
LEFT JOIN time_categories tc ON mr.time_category_id = tc.id
WHERE NOT EXISTS (
    SELECT 1 FROM master_zman_tags mzt
    JOIN zman_tags t ON mzt.tag_id = t.id
    JOIN tag_types tt ON t.tag_type_id = tt.id
    WHERE mzt.master_zman_id = mr.id
    AND tt.key = 'event'
)
AND COALESCE(mr.is_hidden, false) = false
ORDER BY
    tc.sort_order,
    mr.canonical_hebrew_name
`

type GetEverydayMasterZmanimRow struct {
	ID                   int32              `json:"id"`
	ZmanKey              string             `json:"zman_key"`
	CanonicalHebrewName  string             `json:"canonical_hebrew_name"`
	CanonicalEnglishName string             `json:"canonical_english_name"`
	Transliteration      *string            `json:"transliteration"`
	Description          *string            `json:"description"`
	HalachicNotes        *string            `json:"halachic_notes"`
	HalachicSource       *string            `json:"halachic_source"`
	TimeCategory         *string            `json:"time_category"`
	DefaultFormulaDsl    *string            `json:"default_formula_dsl"`
	IsCore               *bool              `json:"is_core"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

// Get everyday zmanim (excludes event zmanim - those with tag_type = 'event')
func (q *Queries) GetEverydayMasterZmanim(ctx context.Context) ([]GetEverydayMasterZmanimRow, error) {
	rows, err := q.db.Query(ctx, getEverydayMasterZmanim)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEverydayMasterZmanimRow{}
	for rows.Next() {
		var i GetEverydayMasterZmanimRow
		if err := rows.Scan(
			&i.ID,
			&i.ZmanKey,
			&i.CanonicalHebrewName,
			&i.CanonicalEnglishName,
			&i.Transliteration,
			&i.Description,
			&i.HalachicNotes,
			&i.HalachicSource,
			&i.TimeCategory,
			&i.DefaultFormulaDsl,
			&i.IsCore,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHiddenTags = `-- name: GetHiddenTags :many
SELECT zt.id, zt.tag_key, zt.display_name_hebrew,
    zt.display_name_english_ashkenazi, zt.display_name_english_sephardi,
    tt.key as tag_type, zt.description, zt.color, zt.created_at
FROM zman_tags zt
LEFT JOIN tag_types tt ON zt.tag_type_id = tt.id
WHERE zt.is_hidden = true
ORDER BY tt.sort_order, zt.tag_key
`

type GetHiddenTagsRow struct {
	ID                          int32              `json:"id"`
	TagKey                      string             `json:"tag_key"`
	DisplayNameHebrew           string             `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string             `json:"display_name_english_ashkenazi"`
	DisplayNameEnglishSephardi  *string            `json:"display_name_english_sephardi"`
	TagType                     *string            `json:"tag_type"`
	Description                 *string            `json:"description"`
	Color                       *string            `json:"color"`
	CreatedAt                   pgtype.Timestamptz `json:"created_at"`
}

// Get only hidden tags for debugging and admin purposes
func (q *Queries) GetHiddenTags(ctx context.Context) ([]GetHiddenTagsRow, error) {
	rows, err := q.db.Query(ctx, getHiddenTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHiddenTagsRow{}
	for rows.Next() {
		var i GetHiddenTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.TagKey,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglishAshkenazi,
			&i.DisplayNameEnglishSephardi,
			&i.TagType,
			&i.Description,
			&i.Color,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMasterZmanByID = `-- name: GetMasterZmanByID :one
SELECT
    mr.id, mr.zman_key, mr.canonical_hebrew_name, mr.canonical_english_name,
    mr.transliteration, mr.description, mr.halachic_notes, mr.halachic_source,
    tc.key as time_category, mr.default_formula_dsl, mr.is_core,
    mr.created_at, mr.updated_at
FROM master_zmanim_registry mr
LEFT JOIN time_categories tc ON mr.time_category_id = tc.id
WHERE mr.id = $1
`

type GetMasterZmanByIDRow struct {
	ID                   int32              `json:"id"`
	ZmanKey              string             `json:"zman_key"`
	CanonicalHebrewName  string             `json:"canonical_hebrew_name"`
	CanonicalEnglishName string             `json:"canonical_english_name"`
	Transliteration      *string            `json:"transliteration"`
	Description          *string            `json:"description"`
	HalachicNotes        *string            `json:"halachic_notes"`
	HalachicSource       *string            `json:"halachic_source"`
	TimeCategory         *string            `json:"time_category"`
	DefaultFormulaDsl    *string            `json:"default_formula_dsl"`
	IsCore               *bool              `json:"is_core"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetMasterZmanByID(ctx context.Context, id int32) (GetMasterZmanByIDRow, error) {
	row := q.db.QueryRow(ctx, getMasterZmanByID, id)
	var i GetMasterZmanByIDRow
	err := row.Scan(
		&i.ID,
		&i.ZmanKey,
		&i.CanonicalHebrewName,
		&i.CanonicalEnglishName,
		&i.Transliteration,
		&i.Description,
		&i.HalachicNotes,
		&i.HalachicSource,
		&i.TimeCategory,
		&i.DefaultFormulaDsl,
		&i.IsCore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMasterZmanByKey = `-- name: GetMasterZmanByKey :one
SELECT
    mr.id, mr.zman_key, mr.canonical_hebrew_name, mr.canonical_english_name,
    mr.transliteration, mr.description, mr.halachic_notes, mr.halachic_source,
    tc.key as time_category, mr.default_formula_dsl, mr.is_core,
    mr.created_at, mr.updated_at
FROM master_zmanim_registry mr
LEFT JOIN time_categories tc ON mr.time_category_id = tc.id
WHERE mr.zman_key = $1
`

type GetMasterZmanByKeyRow struct {
	ID                   int32              `json:"id"`
	ZmanKey              string             `json:"zman_key"`
	CanonicalHebrewName  string             `json:"canonical_hebrew_name"`
	CanonicalEnglishName string             `json:"canonical_english_name"`
	Transliteration      *string            `json:"transliteration"`
	Description          *string            `json:"description"`
	HalachicNotes        *string            `json:"halachic_notes"`
	HalachicSource       *string            `json:"halachic_source"`
	TimeCategory         *string            `json:"time_category"`
	DefaultFormulaDsl    *string            `json:"default_formula_dsl"`
	IsCore               *bool              `json:"is_core"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetMasterZmanByKey(ctx context.Context, zmanKey string) (GetMasterZmanByKeyRow, error) {
	row := q.db.QueryRow(ctx, getMasterZmanByKey, zmanKey)
	var i GetMasterZmanByKeyRow
	err := row.Scan(
		&i.ID,
		&i.ZmanKey,
		&i.CanonicalHebrewName,
		&i.CanonicalEnglishName,
		&i.Transliteration,
		&i.Description,
		&i.HalachicNotes,
		&i.HalachicSource,
		&i.TimeCategory,
		&i.DefaultFormulaDsl,
		&i.IsCore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMasterZmanDefaultFormula = `-- name: GetMasterZmanDefaultFormula :one
SELECT default_formula_dsl FROM master_zmanim_registry WHERE id = $1
`

// Get default formula from master registry
func (q *Queries) GetMasterZmanDefaultFormula(ctx context.Context, id int32) (*string, error) {
	row := q.db.QueryRow(ctx, getMasterZmanDefaultFormula, id)
	var default_formula_dsl *string
	err := row.Scan(&default_formula_dsl)
	return default_formula_dsl, err
}

const getMasterZmanDocumentation = `-- name: GetMasterZmanDocumentation :one
SELECT
    mr.id,
    mr.zman_key,
    mr.canonical_hebrew_name,
    mr.canonical_english_name,
    mr.transliteration,
    mr.description,
    mr.default_formula_dsl,
    mr.halachic_notes,
    mr.halachic_source,
    mr.full_description,
    mr.formula_explanation,
    mr.usage_context,
    mr.related_zmanim_ids,
    mr.shita,
    mr.category,
    mr.is_core,
    tc.key AS time_category,
    mr.created_at,
    mr.updated_at
FROM master_zmanim_registry mr
LEFT JOIN time_categories tc ON mr.time_category_id = tc.id
WHERE mr.id = $1 AND COALESCE(mr.is_hidden, false) = false
`

type GetMasterZmanDocumentationRow struct {
	ID                   int32              `json:"id"`
	ZmanKey              string             `json:"zman_key"`
	CanonicalHebrewName  string             `json:"canonical_hebrew_name"`
	CanonicalEnglishName string             `json:"canonical_english_name"`
	Transliteration      *string            `json:"transliteration"`
	Description          *string            `json:"description"`
	DefaultFormulaDsl    *string            `json:"default_formula_dsl"`
	HalachicNotes        *string            `json:"halachic_notes"`
	HalachicSource       *string            `json:"halachic_source"`
	FullDescription      *string            `json:"full_description"`
	FormulaExplanation   *string            `json:"formula_explanation"`
	UsageContext         *string            `json:"usage_context"`
	RelatedZmanimIds     []int32            `json:"related_zmanim_ids"`
	Shita                *string            `json:"shita"`
	Category             *string            `json:"category"`
	IsCore               *bool              `json:"is_core"`
	TimeCategory         *string            `json:"time_category"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

// Get full documentation for a master zman (for documentation modal)
func (q *Queries) GetMasterZmanDocumentation(ctx context.Context, id int32) (GetMasterZmanDocumentationRow, error) {
	row := q.db.QueryRow(ctx, getMasterZmanDocumentation, id)
	var i GetMasterZmanDocumentationRow
	err := row.Scan(
		&i.ID,
		&i.ZmanKey,
		&i.CanonicalHebrewName,
		&i.CanonicalEnglishName,
		&i.Transliteration,
		&i.Description,
		&i.DefaultFormulaDsl,
		&i.HalachicNotes,
		&i.HalachicSource,
		&i.FullDescription,
		&i.FormulaExplanation,
		&i.UsageContext,
		&i.RelatedZmanimIds,
		&i.Shita,
		&i.Category,
		&i.IsCore,
		&i.TimeCategory,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMasterZmanForImport = `-- name: GetMasterZmanForImport :one
SELECT
    mr.id,
    mr.zman_key,
    mr.canonical_hebrew_name,
    mr.canonical_english_name,
    mr.transliteration,
    mr.description,
    mr.default_formula_dsl,
    mr.time_category_id,
    mr.category,
    mr.shita,
    mr.is_core
FROM master_zmanim_registry mr
WHERE mr.id = $1 AND COALESCE(mr.is_hidden, false) = false
`

type GetMasterZmanForImportRow struct {
	ID                   int32   `json:"id"`
	ZmanKey              string  `json:"zman_key"`
	CanonicalHebrewName  string  `json:"canonical_hebrew_name"`
	CanonicalEnglishName string  `json:"canonical_english_name"`
	Transliteration      *string `json:"transliteration"`
	Description          *string `json:"description"`
	DefaultFormulaDsl    *string `json:"default_formula_dsl"`
	TimeCategoryID       *int32  `json:"time_category_id"`
	Category             *string `json:"category"`
	Shita                *string `json:"shita"`
	IsCore               *bool   `json:"is_core"`
}

// Get master zman details for import (used by import handler)
func (q *Queries) GetMasterZmanForImport(ctx context.Context, id int32) (GetMasterZmanForImportRow, error) {
	row := q.db.QueryRow(ctx, getMasterZmanForImport, id)
	var i GetMasterZmanForImportRow
	err := row.Scan(
		&i.ID,
		&i.ZmanKey,
		&i.CanonicalHebrewName,
		&i.CanonicalEnglishName,
		&i.Transliteration,
		&i.Description,
		&i.DefaultFormulaDsl,
		&i.TimeCategoryID,
		&i.Category,
		&i.Shita,
		&i.IsCore,
	)
	return i, err
}

const getMasterZmanTagsForDetail = `-- name: GetMasterZmanTagsForDetail :many
SELECT t.id, t.tag_key, t.display_name_hebrew,
    t.display_name_english_ashkenazi, t.display_name_english_sephardi,
    tt.key as tag_type, t.description, t.color, t.created_at
FROM zman_tags t
LEFT JOIN tag_types tt ON t.tag_type_id = tt.id
JOIN master_zman_tags mzt ON t.id = mzt.tag_id
WHERE mzt.master_zman_id = $1 AND t.is_hidden = false
ORDER BY tt.sort_order, t.tag_key
`

type GetMasterZmanTagsForDetailRow struct {
	ID                          int32              `json:"id"`
	TagKey                      string             `json:"tag_key"`
	DisplayNameHebrew           string             `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string             `json:"display_name_english_ashkenazi"`
	DisplayNameEnglishSephardi  *string            `json:"display_name_english_sephardi"`
	TagType                     *string            `json:"tag_type"`
	Description                 *string            `json:"description"`
	Color                       *string            `json:"color"`
	CreatedAt                   pgtype.Timestamptz `json:"created_at"`
}

// Get tags for master zman detail view (user-facing - excludes hidden tags)
func (q *Queries) GetMasterZmanTagsForDetail(ctx context.Context, masterZmanID int32) ([]GetMasterZmanTagsForDetailRow, error) {
	rows, err := q.db.Query(ctx, getMasterZmanTagsForDetail, masterZmanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMasterZmanTagsForDetailRow{}
	for rows.Next() {
		var i GetMasterZmanTagsForDetailRow
		if err := rows.Scan(
			&i.ID,
			&i.TagKey,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglishAshkenazi,
			&i.DisplayNameEnglishSephardi,
			&i.TagType,
			&i.Description,
			&i.Color,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMasterZmanTagsWithDetails = `-- name: GetMasterZmanTagsWithDetails :many
SELECT mzt.master_zman_id, mzt.is_negated, t.id, t.tag_key, t.display_name_hebrew,
    t.display_name_english_ashkenazi, t.display_name_english_sephardi,
    tt.key as tag_type, t.description, t.color, t.created_at
FROM master_zman_tags mzt
JOIN zman_tags t ON t.id = mzt.tag_id
LEFT JOIN tag_types tt ON t.tag_type_id = tt.id
WHERE mzt.master_zman_id = ANY($1::int[]) AND t.is_hidden = false
ORDER BY tt.sort_order, t.tag_key
`

type GetMasterZmanTagsWithDetailsRow struct {
	MasterZmanID                int32              `json:"master_zman_id"`
	IsNegated                   bool               `json:"is_negated"`
	ID                          int32              `json:"id"`
	TagKey                      string             `json:"tag_key"`
	DisplayNameHebrew           string             `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string             `json:"display_name_english_ashkenazi"`
	DisplayNameEnglishSephardi  *string            `json:"display_name_english_sephardi"`
	TagType                     *string            `json:"tag_type"`
	Description                 *string            `json:"description"`
	Color                       *string            `json:"color"`
	CreatedAt                   pgtype.Timestamptz `json:"created_at"`
}

// Get tags for multiple zmanim with full tag details (user-facing - excludes hidden tags)
func (q *Queries) GetMasterZmanTagsWithDetails(ctx context.Context, dollar_1 []int32) ([]GetMasterZmanTagsWithDetailsRow, error) {
	rows, err := q.db.Query(ctx, getMasterZmanTagsWithDetails, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMasterZmanTagsWithDetailsRow{}
	for rows.Next() {
		var i GetMasterZmanTagsWithDetailsRow
		if err := rows.Scan(
			&i.MasterZmanID,
			&i.IsNegated,
			&i.ID,
			&i.TagKey,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglishAshkenazi,
			&i.DisplayNameEnglishSephardi,
			&i.TagType,
			&i.Description,
			&i.Color,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMasterZmanimByCategory = `-- name: GetMasterZmanimByCategory :many
SELECT
    mr.id, mr.zman_key, mr.canonical_hebrew_name, mr.canonical_english_name,
    mr.transliteration, mr.description, mr.halachic_notes, mr.halachic_source,
    tc.key as time_category, mr.default_formula_dsl, mr.is_core,
    mr.created_at, mr.updated_at
FROM master_zmanim_registry mr
LEFT JOIN time_categories tc ON mr.time_category_id = tc.id
WHERE tc.key = $1
ORDER BY mr.canonical_hebrew_name
`

type GetMasterZmanimByCategoryRow struct {
	ID                   int32              `json:"id"`
	ZmanKey              string             `json:"zman_key"`
	CanonicalHebrewName  string             `json:"canonical_hebrew_name"`
	CanonicalEnglishName string             `json:"canonical_english_name"`
	Transliteration      *string            `json:"transliteration"`
	Description          *string            `json:"description"`
	HalachicNotes        *string            `json:"halachic_notes"`
	HalachicSource       *string            `json:"halachic_source"`
	TimeCategory         *string            `json:"time_category"`
	DefaultFormulaDsl    *string            `json:"default_formula_dsl"`
	IsCore               *bool              `json:"is_core"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetMasterZmanimByCategory(ctx context.Context, key string) ([]GetMasterZmanimByCategoryRow, error) {
	rows, err := q.db.Query(ctx, getMasterZmanimByCategory, key)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMasterZmanimByCategoryRow{}
	for rows.Next() {
		var i GetMasterZmanimByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.ZmanKey,
			&i.CanonicalHebrewName,
			&i.CanonicalEnglishName,
			&i.Transliteration,
			&i.Description,
			&i.HalachicNotes,
			&i.HalachicSource,
			&i.TimeCategory,
			&i.DefaultFormulaDsl,
			&i.IsCore,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMasterZmanimByTag = `-- name: GetMasterZmanimByTag :many
SELECT
    mr.id, mr.zman_key, mr.canonical_hebrew_name, mr.canonical_english_name,
    mr.transliteration, mr.description, mr.halachic_notes, mr.halachic_source,
    tc.key as time_category, mr.default_formula_dsl, mr.is_core,
    mr.created_at, mr.updated_at
FROM master_zmanim_registry mr
LEFT JOIN time_categories tc ON mr.time_category_id = tc.id
JOIN master_zman_tags mzt ON mr.id = mzt.master_zman_id
JOIN zman_tags zt ON zt.id = mzt.tag_id
WHERE zt.tag_key = $1
ORDER BY tc.sort_order, mr.canonical_hebrew_name
`

type GetMasterZmanimByTagRow struct {
	ID                   int32              `json:"id"`
	ZmanKey              string             `json:"zman_key"`
	CanonicalHebrewName  string             `json:"canonical_hebrew_name"`
	CanonicalEnglishName string             `json:"canonical_english_name"`
	Transliteration      *string            `json:"transliteration"`
	Description          *string            `json:"description"`
	HalachicNotes        *string            `json:"halachic_notes"`
	HalachicSource       *string            `json:"halachic_source"`
	TimeCategory         *string            `json:"time_category"`
	DefaultFormulaDsl    *string            `json:"default_formula_dsl"`
	IsCore               *bool              `json:"is_core"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetMasterZmanimByTag(ctx context.Context, tagKey string) ([]GetMasterZmanimByTagRow, error) {
	rows, err := q.db.Query(ctx, getMasterZmanimByTag, tagKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMasterZmanimByTagRow{}
	for rows.Next() {
		var i GetMasterZmanimByTagRow
		if err := rows.Scan(
			&i.ID,
			&i.ZmanKey,
			&i.CanonicalHebrewName,
			&i.CanonicalEnglishName,
			&i.Transliteration,
			&i.Description,
			&i.HalachicNotes,
			&i.HalachicSource,
			&i.TimeCategory,
			&i.DefaultFormulaDsl,
			&i.IsCore,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMasterZmanimFormulasByKeys = `-- name: GetMasterZmanimFormulasByKeys :many
SELECT
    mr.zman_key,
    mr.default_formula_dsl
FROM master_zmanim_registry mr
WHERE mr.zman_key = ANY($1::text[])
  AND mr.default_formula_dsl IS NOT NULL
`

type GetMasterZmanimFormulasByKeysRow struct {
	ZmanKey           string  `json:"zman_key"`
	DefaultFormulaDsl *string `json:"default_formula_dsl"`
}

// Get master zmanim formulas by their keys for resolving @references in formulas
func (q *Queries) GetMasterZmanimFormulasByKeys(ctx context.Context, dollar_1 []string) ([]GetMasterZmanimFormulasByKeysRow, error) {
	rows, err := q.db.Query(ctx, getMasterZmanimFormulasByKeys, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMasterZmanimFormulasByKeysRow{}
	for rows.Next() {
		var i GetMasterZmanimFormulasByKeysRow
		if err := rows.Scan(&i.ZmanKey, &i.DefaultFormulaDsl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMasterZmanimGroupedByCategory = `-- name: GetMasterZmanimGroupedByCategory :many
SELECT
    tc.key as time_category,
    json_agg(
        json_build_object(
            'id', mr.id,
            'zman_key', mr.zman_key,
            'canonical_hebrew_name', mr.canonical_hebrew_name,
            'canonical_english_name', mr.canonical_english_name,
            'transliteration', mr.transliteration,
            'default_formula_dsl', mr.default_formula_dsl,
            'is_core', mr.is_core
        ) ORDER BY mr.canonical_hebrew_name
    ) as zmanim
FROM master_zmanim_registry mr
LEFT JOIN time_categories tc ON mr.time_category_id = tc.id
GROUP BY tc.key, tc.sort_order
ORDER BY tc.sort_order
`

type GetMasterZmanimGroupedByCategoryRow struct {
	TimeCategory *string `json:"time_category"`
	Zmanim       []byte  `json:"zmanim"`
}

func (q *Queries) GetMasterZmanimGroupedByCategory(ctx context.Context) ([]GetMasterZmanimGroupedByCategoryRow, error) {
	rows, err := q.db.Query(ctx, getMasterZmanimGroupedByCategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMasterZmanimGroupedByCategoryRow{}
	for rows.Next() {
		var i GetMasterZmanimGroupedByCategoryRow
		if err := rows.Scan(&i.TimeCategory, &i.Zmanim); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherByIdForExamples = `-- name: GetPublisherByIdForExamples :one
SELECT
    p.id,
    p.name,
    p.description
FROM publishers p
WHERE p.id = $1
  AND p.deleted_at IS NULL
`

type GetPublisherByIdForExamplesRow struct {
	ID          int32   `json:"id"`
	Name        string  `json:"name"`
	Description *string `json:"description"`
}

// Get a single publisher by ID for display
func (q *Queries) GetPublisherByIdForExamples(ctx context.Context, id int32) (GetPublisherByIdForExamplesRow, error) {
	row := q.db.QueryRow(ctx, getPublisherByIdForExamples, id)
	var i GetPublisherByIdForExamplesRow
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const getPublisherCoverageLocalities = `-- name: GetPublisherCoverageLocalities :many
SELECT DISTINCT
    gl.id,
    gl.name,
    gc.name AS country_name,
    gl.timezone
FROM publisher_coverage pc
JOIN geo_localities gl ON pc.locality_id = gl.id
LEFT JOIN geo_countries gc ON gl.country_id = gc.id
WHERE pc.publisher_id = $1
  AND pc.deleted_at IS NULL
ORDER BY gc.name, gl.name
LIMIT 500
`

type GetPublisherCoverageLocalitiesRow struct {
	ID          int32   `json:"id"`
	Name        string  `json:"name"`
	CountryName *string `json:"country_name"`
	Timezone    string  `json:"timezone"`
}

// Get localities where a publisher has coverage
func (q *Queries) GetPublisherCoverageLocalities(ctx context.Context, publisherID int32) ([]GetPublisherCoverageLocalitiesRow, error) {
	rows, err := q.db.Query(ctx, getPublisherCoverageLocalities, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherCoverageLocalitiesRow{}
	for rows.Next() {
		var i GetPublisherCoverageLocalitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CountryName,
			&i.Timezone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherZmanDocumentation = `-- name: GetPublisherZmanDocumentation :one

SELECT
    pz.id,
    pz.zman_key,
    pz.hebrew_name,
    pz.english_name,
    pz.description,
    pz.formula_dsl,
    pz.halachic_notes,
    pz.master_zman_id,
    mr.canonical_hebrew_name as master_hebrew_name,
    mr.canonical_english_name as master_english_name,
    mr.zman_key as master_zman_key,
    pz.linked_publisher_zman_id,
    lpz.publisher_id as linked_publisher_id,
    lp.name as linked_publisher_name,
    pz.copied_from_publisher_id,
    cp.name as copied_from_publisher_name,
    pub.id as publisher_id,
    pub.name as publisher_name,
    pub.is_verified as publisher_is_verified,
    pz.created_at,
    pz.updated_at
FROM publisher_zmanim pz
JOIN publishers pub ON pz.publisher_id = pub.id
LEFT JOIN master_zmanim_registry mr ON pz.master_zman_id = mr.id
LEFT JOIN publisher_zmanim lpz ON pz.linked_publisher_zman_id = lpz.id
LEFT JOIN publishers lp ON lpz.publisher_id = lp.id
LEFT JOIN publishers cp ON pz.copied_from_publisher_id = cp.id
WHERE pz.id = $1
  AND pz.deleted_at IS NULL
`

type GetPublisherZmanDocumentationRow struct {
	ID                      int32              `json:"id"`
	ZmanKey                 string             `json:"zman_key"`
	HebrewName              string             `json:"hebrew_name"`
	EnglishName             string             `json:"english_name"`
	Description             *string            `json:"description"`
	FormulaDsl              string             `json:"formula_dsl"`
	HalachicNotes           *string            `json:"halachic_notes"`
	MasterZmanID            *int32             `json:"master_zman_id"`
	MasterHebrewName        *string            `json:"master_hebrew_name"`
	MasterEnglishName       *string            `json:"master_english_name"`
	MasterZmanKey           *string            `json:"master_zman_key"`
	LinkedPublisherZmanID   *int32             `json:"linked_publisher_zman_id"`
	LinkedPublisherID       *int32             `json:"linked_publisher_id"`
	LinkedPublisherName     *string            `json:"linked_publisher_name"`
	CopiedFromPublisherID   *int32             `json:"copied_from_publisher_id"`
	CopiedFromPublisherName *string            `json:"copied_from_publisher_name"`
	PublisherID             int32              `json:"publisher_id"`
	PublisherName           string             `json:"publisher_name"`
	PublisherIsVerified     bool               `json:"publisher_is_verified"`
	CreatedAt               pgtype.Timestamptz `json:"created_at"`
	UpdatedAt               pgtype.Timestamptz `json:"updated_at"`
}

// ============================================
// PUBLISHER ZMAN DOCUMENTATION (Story 11.4)
// ============================================
// Get publisher zman details including source attribution and master reference
func (q *Queries) GetPublisherZmanDocumentation(ctx context.Context, id int32) (GetPublisherZmanDocumentationRow, error) {
	row := q.db.QueryRow(ctx, getPublisherZmanDocumentation, id)
	var i GetPublisherZmanDocumentationRow
	err := row.Scan(
		&i.ID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.Description,
		&i.FormulaDsl,
		&i.HalachicNotes,
		&i.MasterZmanID,
		&i.MasterHebrewName,
		&i.MasterEnglishName,
		&i.MasterZmanKey,
		&i.LinkedPublisherZmanID,
		&i.LinkedPublisherID,
		&i.LinkedPublisherName,
		&i.CopiedFromPublisherID,
		&i.CopiedFromPublisherName,
		&i.PublisherID,
		&i.PublisherName,
		&i.PublisherIsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPublisherZmanForLinkCopy = `-- name: GetPublisherZmanForLinkCopy :one
SELECT
    pz.id,
    pz.publisher_id,
    pz.zman_key,
    pz.hebrew_name,
    pz.english_name,
    pz.description,
    pz.formula_dsl,
    pz.master_zman_id,
    p.name AS source_publisher_name,
    -- Get time_category_id from publisher zman or master registry
    COALESCE(pz.time_category_id, mr.time_category_id) AS time_category_id
FROM publisher_zmanim pz
JOIN publishers p ON pz.publisher_id = p.id
LEFT JOIN master_zmanim_registry mr ON pz.master_zman_id = mr.id
WHERE pz.id = $1
  AND pz.deleted_at IS NULL
  AND pz.is_visible = true
  AND p.is_verified = true
`

type GetPublisherZmanForLinkCopyRow struct {
	ID                  int32   `json:"id"`
	PublisherID         int32   `json:"publisher_id"`
	ZmanKey             string  `json:"zman_key"`
	HebrewName          string  `json:"hebrew_name"`
	EnglishName         string  `json:"english_name"`
	Description         *string `json:"description"`
	FormulaDsl          string  `json:"formula_dsl"`
	MasterZmanID        *int32  `json:"master_zman_id"`
	SourcePublisherName string  `json:"source_publisher_name"`
	TimeCategoryID      *int32  `json:"time_category_id"`
}

// Get a publisher zman by ID for linking/copying
func (q *Queries) GetPublisherZmanForLinkCopy(ctx context.Context, id int32) (GetPublisherZmanForLinkCopyRow, error) {
	row := q.db.QueryRow(ctx, getPublisherZmanForLinkCopy, id)
	var i GetPublisherZmanForLinkCopyRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.Description,
		&i.FormulaDsl,
		&i.MasterZmanID,
		&i.SourcePublisherName,
		&i.TimeCategoryID,
	)
	return i, err
}

const getPublisherZmanWithRegistry = `-- name: GetPublisherZmanWithRegistry :one
SELECT
    pz.id,
    pz.publisher_id,
    pz.zman_key,
    COALESCE(mr.canonical_hebrew_name, pz.hebrew_name) AS hebrew_name,
    COALESCE(mr.canonical_english_name, pz.english_name) AS english_name,
    mr.transliteration,
    pz.formula_dsl,
    mr.default_formula_dsl,
    pz.ai_explanation,
    pz.publisher_comment,
    pz.is_enabled,
    pz.is_visible,
    pz.is_published,
    COALESCE(pz.is_custom, false) AS is_custom,
    tc.key AS time_category,
    pz.dependencies,
    pz.current_version,
    pz.created_at,
    pz.updated_at,
    pz.master_zman_id,
    mr.description AS zman_description,
    mr.halachic_notes,
    mr.is_core
FROM publisher_zmanim pz
LEFT JOIN master_zmanim_registry mr ON pz.master_zman_id = mr.id
LEFT JOIN time_categories tc ON mr.time_category_id = tc.id
WHERE pz.publisher_id = $1
  AND pz.zman_key = $2
  AND pz.deleted_at IS NULL
`

type GetPublisherZmanWithRegistryParams struct {
	PublisherID int32  `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

type GetPublisherZmanWithRegistryRow struct {
	ID                int32              `json:"id"`
	PublisherID       int32              `json:"publisher_id"`
	ZmanKey           string             `json:"zman_key"`
	HebrewName        string             `json:"hebrew_name"`
	EnglishName       string             `json:"english_name"`
	Transliteration   *string            `json:"transliteration"`
	FormulaDsl        string             `json:"formula_dsl"`
	DefaultFormulaDsl *string            `json:"default_formula_dsl"`
	AiExplanation     *string            `json:"ai_explanation"`
	PublisherComment  *string            `json:"publisher_comment"`
	IsEnabled         bool               `json:"is_enabled"`
	IsVisible         bool               `json:"is_visible"`
	IsPublished       bool               `json:"is_published"`
	IsCustom          bool               `json:"is_custom"`
	TimeCategory      *string            `json:"time_category"`
	Dependencies      []string           `json:"dependencies"`
	CurrentVersion    *int32             `json:"current_version"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	MasterZmanID      *int32             `json:"master_zman_id"`
	ZmanDescription   *string            `json:"zman_description"`
	HalachicNotes     *string            `json:"halachic_notes"`
	IsCore            *bool              `json:"is_core"`
}

func (q *Queries) GetPublisherZmanWithRegistry(ctx context.Context, arg GetPublisherZmanWithRegistryParams) (GetPublisherZmanWithRegistryRow, error) {
	row := q.db.QueryRow(ctx, getPublisherZmanWithRegistry, arg.PublisherID, arg.ZmanKey)
	var i GetPublisherZmanWithRegistryRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.Transliteration,
		&i.FormulaDsl,
		&i.DefaultFormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsCustom,
		&i.TimeCategory,
		&i.Dependencies,
		&i.CurrentVersion,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MasterZmanID,
		&i.ZmanDescription,
		&i.HalachicNotes,
		&i.IsCore,
	)
	return i, err
}

const getPublisherZmanimWithRegistry = `-- name: GetPublisherZmanimWithRegistry :many

SELECT
    pz.id,
    pz.publisher_id,
    pz.zman_key,
    COALESCE(mr.canonical_hebrew_name, pz.hebrew_name) AS hebrew_name,
    COALESCE(mr.canonical_english_name, pz.english_name) AS english_name,
    mr.transliteration,
    pz.formula_dsl,
    mr.default_formula_dsl,
    pz.ai_explanation,
    pz.publisher_comment,
    pz.is_enabled,
    pz.is_visible,
    pz.is_published,
    COALESCE(pz.is_custom, false) AS is_custom,
    tc.key AS time_category,
    pz.dependencies,
    pz.current_version,
    pz.created_at,
    pz.updated_at,
    pz.master_zman_id,
    mr.description AS zman_description,
    mr.halachic_notes,
    mr.is_core
FROM publisher_zmanim pz
LEFT JOIN master_zmanim_registry mr ON pz.master_zman_id = mr.id
LEFT JOIN time_categories tc ON mr.time_category_id = tc.id
WHERE pz.publisher_id = $1
  AND pz.deleted_at IS NULL
ORDER BY
    tc.sort_order,
    pz.hebrew_name
`

type GetPublisherZmanimWithRegistryRow struct {
	ID                int32              `json:"id"`
	PublisherID       int32              `json:"publisher_id"`
	ZmanKey           string             `json:"zman_key"`
	HebrewName        string             `json:"hebrew_name"`
	EnglishName       string             `json:"english_name"`
	Transliteration   *string            `json:"transliteration"`
	FormulaDsl        string             `json:"formula_dsl"`
	DefaultFormulaDsl *string            `json:"default_formula_dsl"`
	AiExplanation     *string            `json:"ai_explanation"`
	PublisherComment  *string            `json:"publisher_comment"`
	IsEnabled         bool               `json:"is_enabled"`
	IsVisible         bool               `json:"is_visible"`
	IsPublished       bool               `json:"is_published"`
	IsCustom          bool               `json:"is_custom"`
	TimeCategory      *string            `json:"time_category"`
	Dependencies      []string           `json:"dependencies"`
	CurrentVersion    *int32             `json:"current_version"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	MasterZmanID      *int32             `json:"master_zman_id"`
	ZmanDescription   *string            `json:"zman_description"`
	HalachicNotes     *string            `json:"halachic_notes"`
	IsCore            *bool              `json:"is_core"`
}

// ============================================
// PUBLISHER ZMANIM WITH REGISTRY (new model)
// ============================================
func (q *Queries) GetPublisherZmanimWithRegistry(ctx context.Context, publisherID int32) ([]GetPublisherZmanimWithRegistryRow, error) {
	rows, err := q.db.Query(ctx, getPublisherZmanimWithRegistry, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherZmanimWithRegistryRow{}
	for rows.Next() {
		var i GetPublisherZmanimWithRegistryRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.Transliteration,
			&i.FormulaDsl,
			&i.DefaultFormulaDsl,
			&i.AiExplanation,
			&i.PublisherComment,
			&i.IsEnabled,
			&i.IsVisible,
			&i.IsPublished,
			&i.IsCustom,
			&i.TimeCategory,
			&i.Dependencies,
			&i.CurrentVersion,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MasterZmanID,
			&i.ZmanDescription,
			&i.HalachicNotes,
			&i.IsCore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRelatedZmanimDetails = `-- name: GetRelatedZmanimDetails :many
SELECT
    id,
    zman_key,
    canonical_hebrew_name,
    canonical_english_name,
    transliteration
FROM master_zmanim_registry
WHERE id = ANY($1::bigint[])
  AND COALESCE(is_hidden, false) = false
ORDER BY canonical_english_name
`

type GetRelatedZmanimDetailsRow struct {
	ID                   int32   `json:"id"`
	ZmanKey              string  `json:"zman_key"`
	CanonicalHebrewName  string  `json:"canonical_hebrew_name"`
	CanonicalEnglishName string  `json:"canonical_english_name"`
	Transliteration      *string `json:"transliteration"`
}

// Get basic info for related zmanim (by array of IDs)
func (q *Queries) GetRelatedZmanimDetails(ctx context.Context, dollar_1 []int64) ([]GetRelatedZmanimDetailsRow, error) {
	rows, err := q.db.Query(ctx, getRelatedZmanimDetails, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRelatedZmanimDetailsRow{}
	for rows.Next() {
		var i GetRelatedZmanimDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.ZmanKey,
			&i.CanonicalHebrewName,
			&i.CanonicalEnglishName,
			&i.Transliteration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagByTagKey = `-- name: GetTagByTagKey :one
SELECT
    zt.id, zt.tag_key, zt.display_name_hebrew,
    zt.display_name_english_ashkenazi, zt.display_name_english_sephardi,
    tt.key as tag_type, zt.description, zt.color, zt.created_at
FROM zman_tags zt
LEFT JOIN tag_types tt ON zt.tag_type_id = tt.id
WHERE zt.tag_key = $1
`

type GetTagByTagKeyRow struct {
	ID                          int32              `json:"id"`
	TagKey                      string             `json:"tag_key"`
	DisplayNameHebrew           string             `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string             `json:"display_name_english_ashkenazi"`
	DisplayNameEnglishSephardi  *string            `json:"display_name_english_sephardi"`
	TagType                     *string            `json:"tag_type"`
	Description                 *string            `json:"description"`
	Color                       *string            `json:"color"`
	CreatedAt                   pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetTagByTagKey(ctx context.Context, tagKey string) (GetTagByTagKeyRow, error) {
	row := q.db.QueryRow(ctx, getTagByTagKey, tagKey)
	var i GetTagByTagKeyRow
	err := row.Scan(
		&i.ID,
		&i.TagKey,
		&i.DisplayNameHebrew,
		&i.DisplayNameEnglishAshkenazi,
		&i.DisplayNameEnglishSephardi,
		&i.TagType,
		&i.Description,
		&i.Color,
		&i.CreatedAt,
	)
	return i, err
}

const getTagsByType = `-- name: GetTagsByType :many
SELECT
    zt.id, zt.tag_key, zt.display_name_hebrew,
    zt.display_name_english_ashkenazi, zt.display_name_english_sephardi,
    tt.key as tag_type, zt.description, zt.color, zt.created_at
FROM zman_tags zt
LEFT JOIN tag_types tt ON zt.tag_type_id = tt.id
WHERE tt.key = $1 AND zt.is_hidden = false
ORDER BY zt.tag_key
`

type GetTagsByTypeRow struct {
	ID                          int32              `json:"id"`
	TagKey                      string             `json:"tag_key"`
	DisplayNameHebrew           string             `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string             `json:"display_name_english_ashkenazi"`
	DisplayNameEnglishSephardi  *string            `json:"display_name_english_sephardi"`
	TagType                     *string            `json:"tag_type"`
	Description                 *string            `json:"description"`
	Color                       *string            `json:"color"`
	CreatedAt                   pgtype.Timestamptz `json:"created_at"`
}

// User-facing query - excludes hidden tags
func (q *Queries) GetTagsByType(ctx context.Context, key string) ([]GetTagsByTypeRow, error) {
	rows, err := q.db.Query(ctx, getTagsByType, key)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTagsByTypeRow{}
	for rows.Next() {
		var i GetTagsByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.TagKey,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglishAshkenazi,
			&i.DisplayNameEnglishSephardi,
			&i.TagType,
			&i.Description,
			&i.Color,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsForMasterZman = `-- name: GetTagsForMasterZman :many
SELECT
    zt.id, zt.tag_key, zt.display_name_hebrew,
    zt.display_name_english_ashkenazi, zt.display_name_english_sephardi,
    tt.key as tag_type, zt.description, zt.color, zt.created_at
FROM zman_tags zt
LEFT JOIN tag_types tt ON zt.tag_type_id = tt.id
JOIN master_zman_tags mzt ON zt.id = mzt.tag_id
WHERE mzt.master_zman_id = $1 AND zt.is_hidden = false
ORDER BY tt.sort_order, zt.tag_key
`

type GetTagsForMasterZmanRow struct {
	ID                          int32              `json:"id"`
	TagKey                      string             `json:"tag_key"`
	DisplayNameHebrew           string             `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string             `json:"display_name_english_ashkenazi"`
	DisplayNameEnglishSephardi  *string            `json:"display_name_english_sephardi"`
	TagType                     *string            `json:"tag_type"`
	Description                 *string            `json:"description"`
	Color                       *string            `json:"color"`
	CreatedAt                   pgtype.Timestamptz `json:"created_at"`
}

// User-facing query - excludes hidden tags
func (q *Queries) GetTagsForMasterZman(ctx context.Context, masterZmanID int32) ([]GetTagsForMasterZmanRow, error) {
	rows, err := q.db.Query(ctx, getTagsForMasterZman, masterZmanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTagsForMasterZmanRow{}
	for rows.Next() {
		var i GetTagsForMasterZmanRow
		if err := rows.Scan(
			&i.ID,
			&i.TagKey,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglishAshkenazi,
			&i.DisplayNameEnglishSephardi,
			&i.TagType,
			&i.Description,
			&i.Color,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVersionFormula = `-- name: GetVersionFormula :one

SELECT pzv.formula_dsl
FROM publisher_zman_versions pzv
JOIN publisher_zmanim pz ON pz.id = pzv.publisher_zman_id
WHERE pz.publisher_id = $1 AND pz.zman_key = $2 AND pzv.version_number = $3
`

type GetVersionFormulaParams struct {
	PublisherID   int32  `json:"publisher_id"`
	ZmanKey       string `json:"zman_key"`
	VersionNumber int32  `json:"version_number"`
}

// ============================================
// ADDITIONAL QUERIES FOR MASTER_REGISTRY HANDLER
// ============================================
// Get formula from a specific version for rollback
func (q *Queries) GetVersionFormula(ctx context.Context, arg GetVersionFormulaParams) (*string, error) {
	row := q.db.QueryRow(ctx, getVersionFormula, arg.PublisherID, arg.ZmanKey, arg.VersionNumber)
	var formula_dsl *string
	err := row.Scan(&formula_dsl)
	return formula_dsl, err
}

const getZmanContextForAI = `-- name: GetZmanContextForAI :one

SELECT
    mr.zman_key,
    mr.canonical_hebrew_name,
    mr.canonical_english_name,
    mr.transliteration,
    mr.description,
    mr.halachic_notes,
    mr.halachic_source,
    tc.key AS time_category,
    mr.default_formula_dsl,
    mr.is_core,
    pz.formula_dsl AS publisher_formula,
    pz.publisher_comment,
    pz.ai_explanation AS existing_explanation,
    pz.is_enabled,
    pz.is_visible,
    pz.is_published,
    COALESCE(
        (SELECT json_agg(json_build_object(
            'name', t.tag_key,
            'type', tt.key,
            'hebrew', t.display_name_hebrew,
            'english', t.display_name_english
        ))
        FROM master_zman_tags mzt
        JOIN zman_tags t ON mzt.tag_id = t.id
        JOIN tag_types tt ON t.tag_type_id = tt.id
        WHERE mzt.master_zman_id = mr.id),
        '[]'::json
    ) AS tags
FROM master_zmanim_registry mr
LEFT JOIN time_categories tc ON mr.time_category_id = tc.id
LEFT JOIN publisher_zmanim pz ON pz.master_zman_id = mr.id
    AND pz.publisher_id = $2
    AND pz.deleted_at IS NULL
WHERE mr.zman_key = $1
`

type GetZmanContextForAIParams struct {
	ZmanKey     string `json:"zman_key"`
	PublisherID *int32 `json:"publisher_id"`
}

type GetZmanContextForAIRow struct {
	ZmanKey              string      `json:"zman_key"`
	CanonicalHebrewName  string      `json:"canonical_hebrew_name"`
	CanonicalEnglishName string      `json:"canonical_english_name"`
	Transliteration      *string     `json:"transliteration"`
	Description          *string     `json:"description"`
	HalachicNotes        *string     `json:"halachic_notes"`
	HalachicSource       *string     `json:"halachic_source"`
	TimeCategory         *string     `json:"time_category"`
	DefaultFormulaDsl    *string     `json:"default_formula_dsl"`
	IsCore               *bool       `json:"is_core"`
	PublisherFormula     *string     `json:"publisher_formula"`
	PublisherComment     *string     `json:"publisher_comment"`
	ExistingExplanation  *string     `json:"existing_explanation"`
	IsEnabled            *bool       `json:"is_enabled"`
	IsVisible            *bool       `json:"is_visible"`
	IsPublished          *bool       `json:"is_published"`
	Tags                 interface{} `json:"tags"`
}

// ============================================
// AI CONTEXT QUERIES
// ============================================
// Get enriched zman context for AI formula generation/explanation
// Returns master registry data, publisher-specific data (if publisher_id provided), and tags as JSON
func (q *Queries) GetZmanContextForAI(ctx context.Context, arg GetZmanContextForAIParams) (GetZmanContextForAIRow, error) {
	row := q.db.QueryRow(ctx, getZmanContextForAI, arg.ZmanKey, arg.PublisherID)
	var i GetZmanContextForAIRow
	err := row.Scan(
		&i.ZmanKey,
		&i.CanonicalHebrewName,
		&i.CanonicalEnglishName,
		&i.Transliteration,
		&i.Description,
		&i.HalachicNotes,
		&i.HalachicSource,
		&i.TimeCategory,
		&i.DefaultFormulaDsl,
		&i.IsCore,
		&i.PublisherFormula,
		&i.PublisherComment,
		&i.ExistingExplanation,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.Tags,
	)
	return i, err
}

const getZmanRegistryRequestByID = `-- name: GetZmanRegistryRequestByID :one
SELECT
    zrr.id, zrr.publisher_id, zrr.requested_key, zrr.requested_hebrew_name, zrr.requested_english_name,
    zrr.requested_formula_dsl, tc.key as time_category, zrr.description, rs.key as status,
    zrr.reviewed_by, zrr.reviewed_at, zrr.reviewer_notes, zrr.created_at
FROM zman_registry_requests zrr
LEFT JOIN time_categories tc ON zrr.time_category_id = tc.id
LEFT JOIN request_statuses rs ON zrr.status_id = rs.id
WHERE zrr.id = $1
`

type GetZmanRegistryRequestByIDRow struct {
	ID                   int32              `json:"id"`
	PublisherID          int32              `json:"publisher_id"`
	RequestedKey         string             `json:"requested_key"`
	RequestedHebrewName  string             `json:"requested_hebrew_name"`
	RequestedEnglishName string             `json:"requested_english_name"`
	RequestedFormulaDsl  *string            `json:"requested_formula_dsl"`
	TimeCategory         *string            `json:"time_category"`
	Description          *string            `json:"description"`
	Status               *string            `json:"status"`
	ReviewedBy           *string            `json:"reviewed_by"`
	ReviewedAt           pgtype.Timestamptz `json:"reviewed_at"`
	ReviewerNotes        *string            `json:"reviewer_notes"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetZmanRegistryRequestByID(ctx context.Context, id int32) (GetZmanRegistryRequestByIDRow, error) {
	row := q.db.QueryRow(ctx, getZmanRegistryRequestByID, id)
	var i GetZmanRegistryRequestByIDRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.RequestedKey,
		&i.RequestedHebrewName,
		&i.RequestedEnglishName,
		&i.RequestedFormulaDsl,
		&i.TimeCategory,
		&i.Description,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewerNotes,
		&i.CreatedAt,
	)
	return i, err
}

const getZmanRegistryRequests = `-- name: GetZmanRegistryRequests :many
SELECT
    zrr.id, zrr.publisher_id, zrr.requested_key, zrr.requested_hebrew_name, zrr.requested_english_name,
    zrr.requested_formula_dsl, tc.key as time_category, zrr.description, rs.key as status,
    zrr.reviewed_by, zrr.reviewed_at, zrr.reviewer_notes, zrr.created_at
FROM zman_registry_requests zrr
LEFT JOIN time_categories tc ON zrr.time_category_id = tc.id
LEFT JOIN request_statuses rs ON zrr.status_id = rs.id
WHERE rs.key = COALESCE($1, rs.key)
ORDER BY zrr.created_at DESC
`

type GetZmanRegistryRequestsRow struct {
	ID                   int32              `json:"id"`
	PublisherID          int32              `json:"publisher_id"`
	RequestedKey         string             `json:"requested_key"`
	RequestedHebrewName  string             `json:"requested_hebrew_name"`
	RequestedEnglishName string             `json:"requested_english_name"`
	RequestedFormulaDsl  *string            `json:"requested_formula_dsl"`
	TimeCategory         *string            `json:"time_category"`
	Description          *string            `json:"description"`
	Status               *string            `json:"status"`
	ReviewedBy           *string            `json:"reviewed_by"`
	ReviewedAt           pgtype.Timestamptz `json:"reviewed_at"`
	ReviewerNotes        *string            `json:"reviewer_notes"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetZmanRegistryRequests(ctx context.Context, status *string) ([]GetZmanRegistryRequestsRow, error) {
	rows, err := q.db.Query(ctx, getZmanRegistryRequests, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetZmanRegistryRequestsRow{}
	for rows.Next() {
		var i GetZmanRegistryRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.RequestedKey,
			&i.RequestedHebrewName,
			&i.RequestedEnglishName,
			&i.RequestedFormulaDsl,
			&i.TimeCategory,
			&i.Description,
			&i.Status,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.ReviewerNotes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getZmanVersion = `-- name: GetZmanVersion :one
SELECT
    pzv.id,
    pzv.publisher_zman_id,
    pzv.version_number,
    pzv.formula_dsl,
    pzv.created_by,
    pzv.created_at
FROM publisher_zman_versions pzv
JOIN publisher_zmanim pz ON pz.id = pzv.publisher_zman_id
WHERE pz.publisher_id = $1 AND pz.zman_key = $2 AND pzv.version_number = $3
`

type GetZmanVersionParams struct {
	PublisherID   int32  `json:"publisher_id"`
	ZmanKey       string `json:"zman_key"`
	VersionNumber int32  `json:"version_number"`
}

type GetZmanVersionRow struct {
	ID              int32              `json:"id"`
	PublisherZmanID int32              `json:"publisher_zman_id"`
	VersionNumber   int32              `json:"version_number"`
	FormulaDsl      *string            `json:"formula_dsl"`
	CreatedBy       *string            `json:"created_by"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetZmanVersion(ctx context.Context, arg GetZmanVersionParams) (GetZmanVersionRow, error) {
	row := q.db.QueryRow(ctx, getZmanVersion, arg.PublisherID, arg.ZmanKey, arg.VersionNumber)
	var i GetZmanVersionRow
	err := row.Scan(
		&i.ID,
		&i.PublisherZmanID,
		&i.VersionNumber,
		&i.FormulaDsl,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getZmanVersionHistory = `-- name: GetZmanVersionHistory :many

SELECT
    pzv.id,
    pzv.publisher_zman_id,
    pzv.version_number,
    pzv.formula_dsl,
    pzv.created_by,
    pzv.created_at
FROM publisher_zman_versions pzv
JOIN publisher_zmanim pz ON pz.id = pzv.publisher_zman_id
WHERE pz.publisher_id = $1 AND pz.zman_key = $2
ORDER BY pzv.version_number DESC
LIMIT 7
`

type GetZmanVersionHistoryParams struct {
	PublisherID int32  `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

type GetZmanVersionHistoryRow struct {
	ID              int32              `json:"id"`
	PublisherZmanID int32              `json:"publisher_zman_id"`
	VersionNumber   int32              `json:"version_number"`
	FormulaDsl      *string            `json:"formula_dsl"`
	CreatedBy       *string            `json:"created_by"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

// ============================================
// VERSION HISTORY QUERIES
// ============================================
func (q *Queries) GetZmanVersionHistory(ctx context.Context, arg GetZmanVersionHistoryParams) ([]GetZmanVersionHistoryRow, error) {
	rows, err := q.db.Query(ctx, getZmanVersionHistory, arg.PublisherID, arg.ZmanKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetZmanVersionHistoryRow{}
	for rows.Next() {
		var i GetZmanVersionHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherZmanID,
			&i.VersionNumber,
			&i.FormulaDsl,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const importEverydayZmanimFromRegistry = `-- name: ImportEverydayZmanimFromRegistry :many
INSERT INTO publisher_zmanim (
    publisher_id, zman_key, hebrew_name, english_name,
    transliteration, description,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, time_category_id,
    dependencies, master_zman_id, current_version
)
SELECT
    $1,
    mr.zman_key,
    mr.canonical_hebrew_name,
    mr.canonical_english_name,
    mr.transliteration,
    mr.description,
    mr.default_formula_dsl,
    NULL,
    NULL,
    true,
    true,
    false,
    false,
    tc.id,
    '{}',
    mr.id,
    1
FROM master_zmanim_registry mr
LEFT JOIN time_categories tc ON mr.time_category_id = tc.id
WHERE NOT EXISTS (
    SELECT 1 FROM master_zman_tags mzt
    JOIN zman_tags t ON mzt.tag_id = t.id
    JOIN tag_types tt ON t.tag_type_id = tt.id
    WHERE mzt.master_zman_id = mr.id
    AND tt.key = 'event'
)
AND COALESCE(mr.is_hidden, false) = false
ON CONFLICT (publisher_id, zman_key) DO NOTHING
RETURNING id, publisher_id, zman_key, hebrew_name, english_name,
    transliteration, description, formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, time_category_id,
    dependencies, created_at, updated_at, master_zman_id, current_version
`

type ImportEverydayZmanimFromRegistryRow struct {
	ID               int32              `json:"id"`
	PublisherID      int32              `json:"publisher_id"`
	ZmanKey          string             `json:"zman_key"`
	HebrewName       string             `json:"hebrew_name"`
	EnglishName      string             `json:"english_name"`
	Transliteration  *string            `json:"transliteration"`
	Description      *string            `json:"description"`
	FormulaDsl       string             `json:"formula_dsl"`
	AiExplanation    *string            `json:"ai_explanation"`
	PublisherComment *string            `json:"publisher_comment"`
	IsEnabled        bool               `json:"is_enabled"`
	IsVisible        bool               `json:"is_visible"`
	IsPublished      bool               `json:"is_published"`
	IsCustom         bool               `json:"is_custom"`
	TimeCategoryID   *int32             `json:"time_category_id"`
	Dependencies     []string           `json:"dependencies"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	MasterZmanID     *int32             `json:"master_zman_id"`
	CurrentVersion   *int32             `json:"current_version"`
}

// Import all everyday zmanim (excludes event zmanim - those with tag_type = 'event') for a publisher
// Used when importing "defaults" for a new publisher
func (q *Queries) ImportEverydayZmanimFromRegistry(ctx context.Context, publisherID int32) ([]ImportEverydayZmanimFromRegistryRow, error) {
	rows, err := q.db.Query(ctx, importEverydayZmanimFromRegistry, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ImportEverydayZmanimFromRegistryRow{}
	for rows.Next() {
		var i ImportEverydayZmanimFromRegistryRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.Transliteration,
			&i.Description,
			&i.FormulaDsl,
			&i.AiExplanation,
			&i.PublisherComment,
			&i.IsEnabled,
			&i.IsVisible,
			&i.IsPublished,
			&i.IsCustom,
			&i.TimeCategoryID,
			&i.Dependencies,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MasterZmanID,
			&i.CurrentVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const importZmanimFromRegistryByKeys = `-- name: ImportZmanimFromRegistryByKeys :many
INSERT INTO publisher_zmanim (
    publisher_id, zman_key, hebrew_name, english_name,
    transliteration, description,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, time_category_id,
    dependencies, master_zman_id, current_version
)
SELECT
    $1,
    mr.zman_key,
    mr.canonical_hebrew_name,
    mr.canonical_english_name,
    mr.transliteration,
    mr.description,
    mr.default_formula_dsl,
    NULL,
    NULL,
    true,
    true,
    false,
    false,
    tc.id,
    '{}',
    mr.id,
    1
FROM master_zmanim_registry mr
LEFT JOIN time_categories tc ON mr.time_category_id = tc.id
WHERE mr.zman_key = ANY($2::text[])
ON CONFLICT (publisher_id, zman_key) DO NOTHING
RETURNING id, publisher_id, zman_key, hebrew_name, english_name,
    transliteration, description, formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, time_category_id,
    dependencies, created_at, updated_at, master_zman_id, current_version
`

type ImportZmanimFromRegistryByKeysParams struct {
	PublisherID int32    `json:"publisher_id"`
	Column2     []string `json:"column_2"`
}

type ImportZmanimFromRegistryByKeysRow struct {
	ID               int32              `json:"id"`
	PublisherID      int32              `json:"publisher_id"`
	ZmanKey          string             `json:"zman_key"`
	HebrewName       string             `json:"hebrew_name"`
	EnglishName      string             `json:"english_name"`
	Transliteration  *string            `json:"transliteration"`
	Description      *string            `json:"description"`
	FormulaDsl       string             `json:"formula_dsl"`
	AiExplanation    *string            `json:"ai_explanation"`
	PublisherComment *string            `json:"publisher_comment"`
	IsEnabled        bool               `json:"is_enabled"`
	IsVisible        bool               `json:"is_visible"`
	IsPublished      bool               `json:"is_published"`
	IsCustom         bool               `json:"is_custom"`
	TimeCategoryID   *int32             `json:"time_category_id"`
	Dependencies     []string           `json:"dependencies"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	MasterZmanID     *int32             `json:"master_zman_id"`
	CurrentVersion   *int32             `json:"current_version"`
}

func (q *Queries) ImportZmanimFromRegistryByKeys(ctx context.Context, arg ImportZmanimFromRegistryByKeysParams) ([]ImportZmanimFromRegistryByKeysRow, error) {
	rows, err := q.db.Query(ctx, importZmanimFromRegistryByKeys, arg.PublisherID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ImportZmanimFromRegistryByKeysRow{}
	for rows.Next() {
		var i ImportZmanimFromRegistryByKeysRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.Transliteration,
			&i.Description,
			&i.FormulaDsl,
			&i.AiExplanation,
			&i.PublisherComment,
			&i.IsEnabled,
			&i.IsVisible,
			&i.IsPublished,
			&i.IsCustom,
			&i.TimeCategoryID,
			&i.Dependencies,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MasterZmanID,
			&i.CurrentVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertMasterZmanTag = `-- name: InsertMasterZmanTag :exec
INSERT INTO master_zman_tags (master_zman_id, tag_id, is_negated)
VALUES ($1, $2, $3)
ON CONFLICT (master_zman_id, tag_id) DO UPDATE SET is_negated = EXCLUDED.is_negated
`

type InsertMasterZmanTagParams struct {
	MasterZmanID int32 `json:"master_zman_id"`
	TagID        int32 `json:"tag_id"`
	IsNegated    bool  `json:"is_negated"`
}

func (q *Queries) InsertMasterZmanTag(ctx context.Context, arg InsertMasterZmanTagParams) error {
	_, err := q.db.Exec(ctx, insertMasterZmanTag, arg.MasterZmanID, arg.TagID, arg.IsNegated)
	return err
}

const insertZmanRequestExistingTag = `-- name: InsertZmanRequestExistingTag :exec
INSERT INTO zman_request_tags (request_id, tag_id, is_new_tag_request)
VALUES ($1, $2, false)
`

type InsertZmanRequestExistingTagParams struct {
	RequestID int32  `json:"request_id"`
	TagID     *int32 `json:"tag_id"`
}

// Insert reference to existing tag for a request
func (q *Queries) InsertZmanRequestExistingTag(ctx context.Context, arg InsertZmanRequestExistingTagParams) error {
	_, err := q.db.Exec(ctx, insertZmanRequestExistingTag, arg.RequestID, arg.TagID)
	return err
}

const insertZmanRequestNewTag = `-- name: InsertZmanRequestNewTag :exec
INSERT INTO zman_request_tags (request_id, requested_tag_name, requested_tag_type, is_new_tag_request)
VALUES ($1, $2, $3, true)
`

type InsertZmanRequestNewTagParams struct {
	RequestID        int32   `json:"request_id"`
	RequestedTagName *string `json:"requested_tag_name"`
	RequestedTagType *string `json:"requested_tag_type"`
}

// Insert new tag request for a zman request
func (q *Queries) InsertZmanRequestNewTag(ctx context.Context, arg InsertZmanRequestNewTagParams) error {
	_, err := q.db.Exec(ctx, insertZmanRequestNewTag, arg.RequestID, arg.RequestedTagName, arg.RequestedTagType)
	return err
}

const linkPublisherZmanFromExample = `-- name: LinkPublisherZmanFromExample :one
INSERT INTO publisher_zmanim (
    publisher_id,
    master_zman_id,
    linked_publisher_zman_id,
    zman_key,
    hebrew_name,
    english_name,
    description,
    formula_dsl,
    time_category_id,
    is_visible,
    is_enabled,
    created_at,
    updated_at
) VALUES (
    $1,  -- publisher_id
    $2,  -- master_zman_id
    $3,  -- linked_publisher_zman_id (source publisher_zman.id)
    $4,  -- zman_key
    $5,  -- hebrew_name
    $6,  -- english_name
    $7,  -- description
    $8,  -- formula_dsl
    $9,  -- time_category_id
    true, -- is_visible
    true, -- is_enabled
    NOW(),
    NOW()
) RETURNING id, zman_key
`

type LinkPublisherZmanFromExampleParams struct {
	PublisherID           int32   `json:"publisher_id"`
	MasterZmanID          *int32  `json:"master_zman_id"`
	LinkedPublisherZmanID *int32  `json:"linked_publisher_zman_id"`
	ZmanKey               string  `json:"zman_key"`
	HebrewName            string  `json:"hebrew_name"`
	EnglishName           string  `json:"english_name"`
	Description           *string `json:"description"`
	FormulaDsl            string  `json:"formula_dsl"`
	TimeCategoryID        *int32  `json:"time_category_id"`
}

type LinkPublisherZmanFromExampleRow struct {
	ID      int32  `json:"id"`
	ZmanKey string `json:"zman_key"`
}

// Create a linked publisher zman (from another publisher's zman)
func (q *Queries) LinkPublisherZmanFromExample(ctx context.Context, arg LinkPublisherZmanFromExampleParams) (LinkPublisherZmanFromExampleRow, error) {
	row := q.db.QueryRow(ctx, linkPublisherZmanFromExample,
		arg.PublisherID,
		arg.MasterZmanID,
		arg.LinkedPublisherZmanID,
		arg.ZmanKey,
		arg.HebrewName,
		arg.EnglishName,
		arg.Description,
		arg.FormulaDsl,
		arg.TimeCategoryID,
	)
	var i LinkPublisherZmanFromExampleRow
	err := row.Scan(&i.ID, &i.ZmanKey)
	return i, err
}

const listMasterZmanimForRegistry = `-- name: ListMasterZmanimForRegistry :many

SELECT
    mr.id,
    mr.zman_key,
    mr.canonical_hebrew_name,
    mr.canonical_english_name,
    mr.transliteration,
    mr.description,
    mr.default_formula_dsl,
    mr.category,
    mr.shita,
    mr.is_core,
    tc.key AS time_category,
    mr.created_at,
    -- Check if publisher already imported this master zman (includes deleted items)
    EXISTS(
        SELECT 1 FROM publisher_zmanim pz
        WHERE pz.publisher_id = $1
          AND pz.master_zman_id = mr.id
    ) AS already_imported,
    -- Check if the existing imported zman is deleted (if it exists)
    EXISTS(
        SELECT 1 FROM publisher_zmanim pz
        WHERE pz.publisher_id = $1
          AND pz.master_zman_id = mr.id
          AND pz.deleted_at IS NOT NULL
    ) AS existing_is_deleted
FROM master_zmanim_registry mr
LEFT JOIN time_categories tc ON mr.time_category_id = tc.id
WHERE
    COALESCE(mr.is_hidden, false) = false
    AND ($4::text[] IS NULL OR mr.category = ANY($4::text[]))
    AND ($5::text[] IS NULL OR mr.shita = ANY($5::text[]))
    AND (
        $6::text IS NULL
        OR mr.canonical_hebrew_name ILIKE '%' || $6 || '%'
        OR mr.canonical_english_name ILIKE '%' || $6 || '%'
        OR mr.default_formula_dsl ILIKE '%' || $6 || '%'
        OR mr.zman_key ILIKE '%' || $6 || '%'
        OR mr.transliteration ILIKE '%' || $6 || '%'
    )
    AND (
        $7::text IS NULL
        OR ($7 = 'available' AND NOT EXISTS(SELECT 1 FROM publisher_zmanim pz WHERE pz.publisher_id = $1 AND pz.master_zman_id = mr.id))
        OR ($7 = 'imported' AND EXISTS(SELECT 1 FROM publisher_zmanim pz WHERE pz.publisher_id = $1 AND pz.master_zman_id = mr.id))
    )
ORDER BY tc.sort_order, mr.canonical_english_name
LIMIT $2 OFFSET $3
`

type ListMasterZmanimForRegistryParams struct {
	PublisherID int32    `json:"publisher_id"`
	Limit       int32    `json:"limit"`
	Offset      int32    `json:"offset"`
	Categories  []string `json:"categories"`
	Shitas      []string `json:"shitas"`
	Search      *string  `json:"search"`
	Status      *string  `json:"status"`
}

type ListMasterZmanimForRegistryRow struct {
	ID                   int32              `json:"id"`
	ZmanKey              string             `json:"zman_key"`
	CanonicalHebrewName  string             `json:"canonical_hebrew_name"`
	CanonicalEnglishName string             `json:"canonical_english_name"`
	Transliteration      *string            `json:"transliteration"`
	Description          *string            `json:"description"`
	DefaultFormulaDsl    *string            `json:"default_formula_dsl"`
	Category             *string            `json:"category"`
	Shita                *string            `json:"shita"`
	IsCore               *bool              `json:"is_core"`
	TimeCategory         *string            `json:"time_category"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	AlreadyImported      bool               `json:"already_imported"`
	ExistingIsDeleted    bool               `json:"existing_is_deleted"`
}

// ============================================
// MASTER REGISTRY BROWSER (Story 11.1)
// ============================================
// List all master zmanim for the registry browser with filters, search, and import status
// Parameters: publisher_id, categories (array), shitas (array), search, status, limit, offset
func (q *Queries) ListMasterZmanimForRegistry(ctx context.Context, arg ListMasterZmanimForRegistryParams) ([]ListMasterZmanimForRegistryRow, error) {
	rows, err := q.db.Query(ctx, listMasterZmanimForRegistry,
		arg.PublisherID,
		arg.Limit,
		arg.Offset,
		arg.Categories,
		arg.Shitas,
		arg.Search,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMasterZmanimForRegistryRow{}
	for rows.Next() {
		var i ListMasterZmanimForRegistryRow
		if err := rows.Scan(
			&i.ID,
			&i.ZmanKey,
			&i.CanonicalHebrewName,
			&i.CanonicalEnglishName,
			&i.Transliteration,
			&i.Description,
			&i.DefaultFormulaDsl,
			&i.Category,
			&i.Shita,
			&i.IsCore,
			&i.TimeCategory,
			&i.CreatedAt,
			&i.AlreadyImported,
			&i.ExistingIsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublisherZmanimForExamples = `-- name: ListPublisherZmanimForExamples :many
SELECT
    pz.id,
    pz.zman_key,
    pz.hebrew_name,
    pz.english_name,
    pz.description,
    pz.formula_dsl,
    pz.master_zman_id,
    mr.canonical_english_name AS master_english_name,
    mr.canonical_hebrew_name AS master_hebrew_name,
    mr.category,
    mr.shita,
    -- Check if current publisher already has this master zman (includes deleted items)
    EXISTS(
        SELECT 1 FROM publisher_zmanim cpz
        WHERE cpz.publisher_id = $1
          AND cpz.master_zman_id = pz.master_zman_id
    ) AS already_have_master,
    -- Check if the existing zman is deleted (if it exists)
    EXISTS(
        SELECT 1 FROM publisher_zmanim cpz
        WHERE cpz.publisher_id = $1
          AND cpz.master_zman_id = pz.master_zman_id
          AND cpz.deleted_at IS NOT NULL
    ) AS existing_is_deleted
FROM publisher_zmanim pz
JOIN master_zmanim_registry mr ON pz.master_zman_id = mr.id
WHERE pz.publisher_id = $2
  AND pz.deleted_at IS NULL
  AND pz.is_visible = true
  AND ($5::text IS NULL OR mr.category = $5::text)
  AND ($6::text IS NULL OR mr.shita = $6::text)
  AND (
      $7::text IS NULL
      OR pz.hebrew_name ILIKE '%' || $7 || '%'
      OR pz.english_name ILIKE '%' || $7 || '%'
      OR pz.zman_key ILIKE '%' || $7 || '%'
  )
ORDER BY mr.category, pz.english_name
LIMIT $3 OFFSET $4
`

type ListPublisherZmanimForExamplesParams struct {
	PublisherID   int32   `json:"publisher_id"`
	PublisherID_2 int32   `json:"publisher_id_2"`
	Limit         int32   `json:"limit"`
	Offset        int32   `json:"offset"`
	Category      *string `json:"category"`
	Shita         *string `json:"shita"`
	Search        *string `json:"search"`
}

type ListPublisherZmanimForExamplesRow struct {
	ID                int32   `json:"id"`
	ZmanKey           string  `json:"zman_key"`
	HebrewName        string  `json:"hebrew_name"`
	EnglishName       string  `json:"english_name"`
	Description       *string `json:"description"`
	FormulaDsl        string  `json:"formula_dsl"`
	MasterZmanID      *int32  `json:"master_zman_id"`
	MasterEnglishName string  `json:"master_english_name"`
	MasterHebrewName  string  `json:"master_hebrew_name"`
	Category          *string `json:"category"`
	Shita             *string `json:"shita"`
	AlreadyHaveMaster bool    `json:"already_have_master"`
	ExistingIsDeleted bool    `json:"existing_is_deleted"`
}

// List a publisher's zmanim with ownership check against current publisher
// Returns whether the current publisher already has each master zman (active or deleted)
func (q *Queries) ListPublisherZmanimForExamples(ctx context.Context, arg ListPublisherZmanimForExamplesParams) ([]ListPublisherZmanimForExamplesRow, error) {
	rows, err := q.db.Query(ctx, listPublisherZmanimForExamples,
		arg.PublisherID,
		arg.PublisherID_2,
		arg.Limit,
		arg.Offset,
		arg.Category,
		arg.Shita,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPublisherZmanimForExamplesRow{}
	for rows.Next() {
		var i ListPublisherZmanimForExamplesRow
		if err := rows.Scan(
			&i.ID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.Description,
			&i.FormulaDsl,
			&i.MasterZmanID,
			&i.MasterEnglishName,
			&i.MasterHebrewName,
			&i.Category,
			&i.Shita,
			&i.AlreadyHaveMaster,
			&i.ExistingIsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listValidatedPublishers = `-- name: ListValidatedPublishers :many

SELECT
    p.id,
    p.name,
    p.description
FROM publishers p
WHERE p.is_verified = true
  AND p.status_id = (SELECT id FROM publisher_statuses WHERE key = 'active')
  AND p.deleted_at IS NULL
ORDER BY p.name
`

type ListValidatedPublishersRow struct {
	ID          int32   `json:"id"`
	Name        string  `json:"name"`
	Description *string `json:"description"`
}

// ============================================
// PUBLISHER EXAMPLES BROWSER (Story 11.3)
// ============================================
// Get all verified/active publishers for the publisher examples browser
func (q *Queries) ListValidatedPublishers(ctx context.Context) ([]ListValidatedPublishersRow, error) {
	rows, err := q.db.Query(ctx, listValidatedPublishers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListValidatedPublishersRow{}
	for rows.Next() {
		var i ListValidatedPublishersRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const permanentDeletePublisherZman = `-- name: PermanentDeletePublisherZman :exec
DELETE FROM publisher_zmanim
WHERE publisher_id = $1 AND zman_key = $2 AND deleted_at IS NOT NULL
`

type PermanentDeletePublisherZmanParams struct {
	PublisherID int32  `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

func (q *Queries) PermanentDeletePublisherZman(ctx context.Context, arg PermanentDeletePublisherZmanParams) error {
	_, err := q.db.Exec(ctx, permanentDeletePublisherZman, arg.PublisherID, arg.ZmanKey)
	return err
}

const permanentDeleteZman = `-- name: PermanentDeleteZman :exec
DELETE FROM publisher_zmanim
WHERE publisher_id = $1 AND zman_key = $2 AND deleted_at IS NOT NULL
`

type PermanentDeleteZmanParams struct {
	PublisherID int32  `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

func (q *Queries) PermanentDeleteZman(ctx context.Context, arg PermanentDeleteZmanParams) error {
	_, err := q.db.Exec(ctx, permanentDeleteZman, arg.PublisherID, arg.ZmanKey)
	return err
}

const restorePublisherZman = `-- name: RestorePublisherZman :one
UPDATE publisher_zmanim
SET deleted_at = NULL, deleted_by = NULL, updated_at = NOW()
WHERE publisher_id = $1 AND zman_key = $2 AND deleted_at IS NOT NULL
RETURNING id, publisher_id, zman_key, hebrew_name, english_name,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, time_category_id,
    dependencies, created_at, updated_at, master_zman_id, current_version
`

type RestorePublisherZmanParams struct {
	PublisherID int32  `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

type RestorePublisherZmanRow struct {
	ID               int32              `json:"id"`
	PublisherID      int32              `json:"publisher_id"`
	ZmanKey          string             `json:"zman_key"`
	HebrewName       string             `json:"hebrew_name"`
	EnglishName      string             `json:"english_name"`
	FormulaDsl       string             `json:"formula_dsl"`
	AiExplanation    *string            `json:"ai_explanation"`
	PublisherComment *string            `json:"publisher_comment"`
	IsEnabled        bool               `json:"is_enabled"`
	IsVisible        bool               `json:"is_visible"`
	IsPublished      bool               `json:"is_published"`
	IsCustom         bool               `json:"is_custom"`
	TimeCategoryID   *int32             `json:"time_category_id"`
	Dependencies     []string           `json:"dependencies"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	MasterZmanID     *int32             `json:"master_zman_id"`
	CurrentVersion   *int32             `json:"current_version"`
}

func (q *Queries) RestorePublisherZman(ctx context.Context, arg RestorePublisherZmanParams) (RestorePublisherZmanRow, error) {
	row := q.db.QueryRow(ctx, restorePublisherZman, arg.PublisherID, arg.ZmanKey)
	var i RestorePublisherZmanRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.FormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsCustom,
		&i.TimeCategoryID,
		&i.Dependencies,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MasterZmanID,
		&i.CurrentVersion,
	)
	return i, err
}

const restoreZman = `-- name: RestoreZman :one
UPDATE publisher_zmanim
SET deleted_at = NULL, deleted_by = NULL, updated_at = NOW()
WHERE publisher_id = $1 AND zman_key = $2 AND deleted_at IS NOT NULL
RETURNING id, publisher_id, zman_key, hebrew_name, english_name,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, time_category_id,
    dependencies, created_at, updated_at, master_zman_id, current_version
`

type RestoreZmanParams struct {
	PublisherID int32  `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

type RestoreZmanRow struct {
	ID               int32              `json:"id"`
	PublisherID      int32              `json:"publisher_id"`
	ZmanKey          string             `json:"zman_key"`
	HebrewName       string             `json:"hebrew_name"`
	EnglishName      string             `json:"english_name"`
	FormulaDsl       string             `json:"formula_dsl"`
	AiExplanation    *string            `json:"ai_explanation"`
	PublisherComment *string            `json:"publisher_comment"`
	IsEnabled        bool               `json:"is_enabled"`
	IsVisible        bool               `json:"is_visible"`
	IsPublished      bool               `json:"is_published"`
	IsCustom         bool               `json:"is_custom"`
	TimeCategoryID   *int32             `json:"time_category_id"`
	Dependencies     []string           `json:"dependencies"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	MasterZmanID     *int32             `json:"master_zman_id"`
	CurrentVersion   *int32             `json:"current_version"`
}

func (q *Queries) RestoreZman(ctx context.Context, arg RestoreZmanParams) (RestoreZmanRow, error) {
	row := q.db.QueryRow(ctx, restoreZman, arg.PublisherID, arg.ZmanKey)
	var i RestoreZmanRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.FormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsCustom,
		&i.TimeCategoryID,
		&i.Dependencies,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MasterZmanID,
		&i.CurrentVersion,
	)
	return i, err
}

const reviewZmanRegistryRequest = `-- name: ReviewZmanRegistryRequest :one
UPDATE zman_registry_requests
SET status_id = (SELECT rs.id FROM request_statuses rs WHERE rs.key = $2),
    reviewed_by = $3,
    reviewed_at = NOW(),
    reviewer_notes = $4
WHERE zman_registry_requests.id = $1
RETURNING id, publisher_id, requested_key, requested_hebrew_name, requested_english_name,
    requested_formula_dsl, time_category_id, description, status_id,
    reviewed_by, reviewed_at, reviewer_notes, created_at
`

type ReviewZmanRegistryRequestParams struct {
	ID            int32   `json:"id"`
	Key           string  `json:"key"`
	ReviewedBy    *string `json:"reviewed_by"`
	ReviewerNotes *string `json:"reviewer_notes"`
}

type ReviewZmanRegistryRequestRow struct {
	ID                   int32              `json:"id"`
	PublisherID          int32              `json:"publisher_id"`
	RequestedKey         string             `json:"requested_key"`
	RequestedHebrewName  string             `json:"requested_hebrew_name"`
	RequestedEnglishName string             `json:"requested_english_name"`
	RequestedFormulaDsl  *string            `json:"requested_formula_dsl"`
	TimeCategoryID       int32              `json:"time_category_id"`
	Description          *string            `json:"description"`
	StatusID             int16              `json:"status_id"`
	ReviewedBy           *string            `json:"reviewed_by"`
	ReviewedAt           pgtype.Timestamptz `json:"reviewed_at"`
	ReviewerNotes        *string            `json:"reviewer_notes"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
}

// Update request status during review
func (q *Queries) ReviewZmanRegistryRequest(ctx context.Context, arg ReviewZmanRegistryRequestParams) (ReviewZmanRegistryRequestRow, error) {
	row := q.db.QueryRow(ctx, reviewZmanRegistryRequest,
		arg.ID,
		arg.Key,
		arg.ReviewedBy,
		arg.ReviewerNotes,
	)
	var i ReviewZmanRegistryRequestRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.RequestedKey,
		&i.RequestedHebrewName,
		&i.RequestedEnglishName,
		&i.RequestedFormulaDsl,
		&i.TimeCategoryID,
		&i.Description,
		&i.StatusID,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewerNotes,
		&i.CreatedAt,
	)
	return i, err
}

const rollbackPublisherZmanFormula = `-- name: RollbackPublisherZmanFormula :one
UPDATE publisher_zmanim
SET formula_dsl = $3, updated_at = NOW()
WHERE publisher_id = $1 AND zman_key = $2 AND deleted_at IS NULL
RETURNING id, publisher_id, zman_key, hebrew_name, english_name,
    transliteration, description, formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, time_category_id,
    dependencies, created_at, updated_at, master_zman_id, current_version
`

type RollbackPublisherZmanFormulaParams struct {
	PublisherID int32  `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
	FormulaDsl  string `json:"formula_dsl"`
}

type RollbackPublisherZmanFormulaRow struct {
	ID               int32              `json:"id"`
	PublisherID      int32              `json:"publisher_id"`
	ZmanKey          string             `json:"zman_key"`
	HebrewName       string             `json:"hebrew_name"`
	EnglishName      string             `json:"english_name"`
	Transliteration  *string            `json:"transliteration"`
	Description      *string            `json:"description"`
	FormulaDsl       string             `json:"formula_dsl"`
	AiExplanation    *string            `json:"ai_explanation"`
	PublisherComment *string            `json:"publisher_comment"`
	IsEnabled        bool               `json:"is_enabled"`
	IsVisible        bool               `json:"is_visible"`
	IsPublished      bool               `json:"is_published"`
	IsCustom         bool               `json:"is_custom"`
	TimeCategoryID   *int32             `json:"time_category_id"`
	Dependencies     []string           `json:"dependencies"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	MasterZmanID     *int32             `json:"master_zman_id"`
	CurrentVersion   *int32             `json:"current_version"`
}

// Update zman formula during rollback
func (q *Queries) RollbackPublisherZmanFormula(ctx context.Context, arg RollbackPublisherZmanFormulaParams) (RollbackPublisherZmanFormulaRow, error) {
	row := q.db.QueryRow(ctx, rollbackPublisherZmanFormula, arg.PublisherID, arg.ZmanKey, arg.FormulaDsl)
	var i RollbackPublisherZmanFormulaRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.Transliteration,
		&i.Description,
		&i.FormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsCustom,
		&i.TimeCategoryID,
		&i.Dependencies,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MasterZmanID,
		&i.CurrentVersion,
	)
	return i, err
}

const rollbackZmanToVersion = `-- name: RollbackZmanToVersion :one
UPDATE publisher_zmanim pz
SET
    formula_dsl = pzv.formula_dsl,
    current_version = (SELECT COALESCE(MAX(version_number), 0) + 1 FROM publisher_zman_versions WHERE publisher_zman_id = pz.id),
    updated_at = NOW()
FROM publisher_zman_versions pzv
WHERE pz.publisher_id = $1
  AND pz.zman_key = $2
  AND pzv.publisher_zman_id = pz.id
  AND pzv.version_number = $3
RETURNING pz.id, pz.publisher_id, pz.zman_key, pz.formula_dsl, pz.current_version
`

type RollbackZmanToVersionParams struct {
	PublisherID   int32  `json:"publisher_id"`
	ZmanKey       string `json:"zman_key"`
	VersionNumber int32  `json:"version_number"`
}

type RollbackZmanToVersionRow struct {
	ID             int32  `json:"id"`
	PublisherID    int32  `json:"publisher_id"`
	ZmanKey        string `json:"zman_key"`
	FormulaDsl     string `json:"formula_dsl"`
	CurrentVersion *int32 `json:"current_version"`
}

func (q *Queries) RollbackZmanToVersion(ctx context.Context, arg RollbackZmanToVersionParams) (RollbackZmanToVersionRow, error) {
	row := q.db.QueryRow(ctx, rollbackZmanToVersion, arg.PublisherID, arg.ZmanKey, arg.VersionNumber)
	var i RollbackZmanToVersionRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.FormulaDsl,
		&i.CurrentVersion,
	)
	return i, err
}

const searchMasterZmanim = `-- name: SearchMasterZmanim :many
SELECT
    mr.id, mr.zman_key, mr.canonical_hebrew_name, mr.canonical_english_name,
    mr.transliteration, mr.description, mr.halachic_notes, mr.halachic_source,
    tc.key as time_category, mr.default_formula_dsl, mr.is_core,
    mr.created_at, mr.updated_at
FROM master_zmanim_registry mr
LEFT JOIN time_categories tc ON mr.time_category_id = tc.id
WHERE
    mr.canonical_hebrew_name ILIKE '%' || $1 || '%'
    OR mr.canonical_english_name ILIKE '%' || $1 || '%'
    OR mr.transliteration ILIKE '%' || $1 || '%'
    OR mr.zman_key ILIKE '%' || $1 || '%'
ORDER BY
    CASE
        WHEN mr.canonical_english_name ILIKE $1 || '%' THEN 1
        WHEN mr.canonical_hebrew_name ILIKE $1 || '%' THEN 2
        ELSE 3
    END,
    tc.sort_order
LIMIT 50
`

type SearchMasterZmanimRow struct {
	ID                   int32              `json:"id"`
	ZmanKey              string             `json:"zman_key"`
	CanonicalHebrewName  string             `json:"canonical_hebrew_name"`
	CanonicalEnglishName string             `json:"canonical_english_name"`
	Transliteration      *string            `json:"transliteration"`
	Description          *string            `json:"description"`
	HalachicNotes        *string            `json:"halachic_notes"`
	HalachicSource       *string            `json:"halachic_source"`
	TimeCategory         *string            `json:"time_category"`
	DefaultFormulaDsl    *string            `json:"default_formula_dsl"`
	IsCore               *bool              `json:"is_core"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) SearchMasterZmanim(ctx context.Context, dollar_1 *string) ([]SearchMasterZmanimRow, error) {
	rows, err := q.db.Query(ctx, searchMasterZmanim, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchMasterZmanimRow{}
	for rows.Next() {
		var i SearchMasterZmanimRow
		if err := rows.Scan(
			&i.ID,
			&i.ZmanKey,
			&i.CanonicalHebrewName,
			&i.CanonicalEnglishName,
			&i.Transliteration,
			&i.Description,
			&i.HalachicNotes,
			&i.HalachicSource,
			&i.TimeCategory,
			&i.DefaultFormulaDsl,
			&i.IsCore,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeletePublisherZman = `-- name: SoftDeletePublisherZman :one

UPDATE publisher_zmanim
SET deleted_at = NOW(), deleted_by = $3, updated_at = NOW()
WHERE publisher_id = $1 AND zman_key = $2 AND deleted_at IS NULL
RETURNING id, publisher_id, zman_key, deleted_at, deleted_by
`

type SoftDeletePublisherZmanParams struct {
	PublisherID int32   `json:"publisher_id"`
	ZmanKey     string  `json:"zman_key"`
	DeletedBy   *string `json:"deleted_by"`
}

type SoftDeletePublisherZmanRow struct {
	ID          int32              `json:"id"`
	PublisherID int32              `json:"publisher_id"`
	ZmanKey     string             `json:"zman_key"`
	DeletedAt   pgtype.Timestamptz `json:"deleted_at"`
	DeletedBy   *string            `json:"deleted_by"`
}

// ============================================
// SOFT DELETE QUERIES
// ============================================
func (q *Queries) SoftDeletePublisherZman(ctx context.Context, arg SoftDeletePublisherZmanParams) (SoftDeletePublisherZmanRow, error) {
	row := q.db.QueryRow(ctx, softDeletePublisherZman, arg.PublisherID, arg.ZmanKey, arg.DeletedBy)
	var i SoftDeletePublisherZmanRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const softDeletePublisherZmanExec = `-- name: SoftDeletePublisherZmanExec :exec
UPDATE publisher_zmanim
SET deleted_at = NOW(), deleted_by = $3, updated_at = NOW()
WHERE publisher_id = $1 AND zman_key = $2 AND deleted_at IS NULL
`

type SoftDeletePublisherZmanExecParams struct {
	PublisherID int32   `json:"publisher_id"`
	ZmanKey     string  `json:"zman_key"`
	DeletedBy   *string `json:"deleted_by"`
}

// Soft delete a publisher zman (exec version)
func (q *Queries) SoftDeletePublisherZmanExec(ctx context.Context, arg SoftDeletePublisherZmanExecParams) error {
	_, err := q.db.Exec(ctx, softDeletePublisherZmanExec, arg.PublisherID, arg.ZmanKey, arg.DeletedBy)
	return err
}

const softDeleteZman = `-- name: SoftDeleteZman :exec

UPDATE publisher_zmanim
SET deleted_at = NOW(), deleted_by = $3, updated_at = NOW()
WHERE publisher_id = $1 AND zman_key = $2 AND deleted_at IS NULL
`

type SoftDeleteZmanParams struct {
	PublisherID int32   `json:"publisher_id"`
	ZmanKey     string  `json:"zman_key"`
	DeletedBy   *string `json:"deleted_by"`
}

// ============================================
// SOFT DELETE QUERIES (ADDITIONAL)
// ============================================
func (q *Queries) SoftDeleteZman(ctx context.Context, arg SoftDeleteZmanParams) error {
	_, err := q.db.Exec(ctx, softDeleteZman, arg.PublisherID, arg.ZmanKey, arg.DeletedBy)
	return err
}

const updateZmanCurrentVersion = `-- name: UpdateZmanCurrentVersion :exec
UPDATE publisher_zmanim
SET current_version = $3, updated_at = NOW()
WHERE publisher_id = $1 AND zman_key = $2
`

type UpdateZmanCurrentVersionParams struct {
	PublisherID    int32  `json:"publisher_id"`
	ZmanKey        string `json:"zman_key"`
	CurrentVersion *int32 `json:"current_version"`
}

func (q *Queries) UpdateZmanCurrentVersion(ctx context.Context, arg UpdateZmanCurrentVersionParams) error {
	_, err := q.db.Exec(ctx, updateZmanCurrentVersion, arg.PublisherID, arg.ZmanKey, arg.CurrentVersion)
	return err
}

const updateZmanRegistryRequestStatus = `-- name: UpdateZmanRegistryRequestStatus :one
UPDATE zman_registry_requests
SET
    status_id = (SELECT rs.id FROM request_statuses rs WHERE rs.key = $2),
    reviewed_by = $3,
    reviewed_at = NOW(),
    reviewer_notes = $4
WHERE zman_registry_requests.id = $1
RETURNING id, publisher_id, requested_key, requested_hebrew_name, requested_english_name,
    requested_formula_dsl, time_category_id, description, status_id,
    reviewed_by, reviewed_at, reviewer_notes, created_at
`

type UpdateZmanRegistryRequestStatusParams struct {
	ID            int32   `json:"id"`
	Key           string  `json:"key"`
	ReviewedBy    *string `json:"reviewed_by"`
	ReviewerNotes *string `json:"reviewer_notes"`
}

type UpdateZmanRegistryRequestStatusRow struct {
	ID                   int32              `json:"id"`
	PublisherID          int32              `json:"publisher_id"`
	RequestedKey         string             `json:"requested_key"`
	RequestedHebrewName  string             `json:"requested_hebrew_name"`
	RequestedEnglishName string             `json:"requested_english_name"`
	RequestedFormulaDsl  *string            `json:"requested_formula_dsl"`
	TimeCategoryID       int32              `json:"time_category_id"`
	Description          *string            `json:"description"`
	StatusID             int16              `json:"status_id"`
	ReviewedBy           *string            `json:"reviewed_by"`
	ReviewedAt           pgtype.Timestamptz `json:"reviewed_at"`
	ReviewerNotes        *string            `json:"reviewer_notes"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) UpdateZmanRegistryRequestStatus(ctx context.Context, arg UpdateZmanRegistryRequestStatusParams) (UpdateZmanRegistryRequestStatusRow, error) {
	row := q.db.QueryRow(ctx, updateZmanRegistryRequestStatus,
		arg.ID,
		arg.Key,
		arg.ReviewedBy,
		arg.ReviewerNotes,
	)
	var i UpdateZmanRegistryRequestStatusRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.RequestedKey,
		&i.RequestedHebrewName,
		&i.RequestedEnglishName,
		&i.RequestedFormulaDsl,
		&i.TimeCategoryID,
		&i.Description,
		&i.StatusID,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewerNotes,
		&i.CreatedAt,
	)
	return i, err
}

const validateMasterZmanKeyExists = `-- name: ValidateMasterZmanKeyExists :one
SELECT EXISTS(SELECT 1 FROM master_zmanim_registry WHERE zman_key = $1)
`

// Check if a zman key exists in the master registry
func (q *Queries) ValidateMasterZmanKeyExists(ctx context.Context, zmanKey string) (bool, error) {
	row := q.db.QueryRow(ctx, validateMasterZmanKeyExists, zmanKey)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const validatePendingRequestKeyExists = `-- name: ValidatePendingRequestKeyExists :one
SELECT EXISTS(
    SELECT 1 FROM zman_registry_requests zrr
    JOIN request_statuses rs ON zrr.status_id = rs.id
    WHERE zrr.requested_key = $1 AND rs.key = 'pending'
)
`

// Check if a key has a pending request
func (q *Queries) ValidatePendingRequestKeyExists(ctx context.Context, requestedKey string) (bool, error) {
	row := q.db.QueryRow(ctx, validatePendingRequestKeyExists, requestedKey)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
