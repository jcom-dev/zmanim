// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: zmanim.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addTagToPublisherZman = `-- name: AddTagToPublisherZman :exec
INSERT INTO publisher_zman_tags (publisher_zman_id, tag_id, is_negated)
VALUES ($1, $2, $3)
ON CONFLICT (publisher_zman_id, tag_id) DO UPDATE SET is_negated = $3
`

type AddTagToPublisherZmanParams struct {
	PublisherZmanID int32 `json:"publisher_zman_id"`
	TagID           int32 `json:"tag_id"`
	IsNegated       bool  `json:"is_negated"`
}

// Add a tag to a publisher zman (with optional is_negated)
func (q *Queries) AddTagToPublisherZman(ctx context.Context, arg AddTagToPublisherZmanParams) error {
	_, err := q.db.Exec(ctx, addTagToPublisherZman, arg.PublisherZmanID, arg.TagID, arg.IsNegated)
	return err
}

const browsePublicZmanim = `-- name: BrowsePublicZmanim :many

SELECT
    z.id, z.publisher_id, z.zman_key, z.hebrew_name, z.english_name,
    z.formula_dsl,
    z.time_category_id,
    tc.key AS category,
    tc.display_name_hebrew AS category_display_hebrew,
    tc.display_name_english AS category_display_english,
    p.name as publisher_name,
    COUNT(*) OVER (PARTITION BY z.zman_key) as usage_count
FROM publisher_zmanim z
JOIN publishers p ON p.id = z.publisher_id
LEFT JOIN time_categories tc ON z.time_category_id = tc.id
WHERE z.is_visible = true
  AND z.is_published = true
  AND ($1::text IS NULL OR z.hebrew_name ILIKE '%' || $1 || '%' OR z.english_name ILIKE '%' || $1 || '%')
  AND ($2::integer IS NULL OR z.time_category_id = $2)
ORDER BY usage_count DESC, z.hebrew_name
LIMIT 50
`

type BrowsePublicZmanimParams struct {
	Column1 string `json:"column_1"`
	Column2 int32  `json:"column_2"`
}

type BrowsePublicZmanimRow struct {
	ID                     int32   `json:"id"`
	PublisherID            int32   `json:"publisher_id"`
	ZmanKey                string  `json:"zman_key"`
	HebrewName             string  `json:"hebrew_name"`
	EnglishName            string  `json:"english_name"`
	FormulaDsl             string  `json:"formula_dsl"`
	TimeCategoryID         *int32  `json:"time_category_id"`
	Category               *string `json:"category"`
	CategoryDisplayHebrew  *string `json:"category_display_hebrew"`
	CategoryDisplayEnglish *string `json:"category_display_english"`
	PublisherName          string  `json:"publisher_name"`
	UsageCount             int64   `json:"usage_count"`
}

// Browse public zmanim --
func (q *Queries) BrowsePublicZmanim(ctx context.Context, arg BrowsePublicZmanimParams) ([]BrowsePublicZmanimRow, error) {
	rows, err := q.db.Query(ctx, browsePublicZmanim, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BrowsePublicZmanimRow{}
	for rows.Next() {
		var i BrowsePublicZmanimRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.FormulaDsl,
			&i.TimeCategoryID,
			&i.Category,
			&i.CategoryDisplayHebrew,
			&i.CategoryDisplayEnglish,
			&i.PublisherName,
			&i.UsageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

type BulkAddTagsToPublisherZmanParams struct {
	PublisherZmanID int32 `json:"publisher_zman_id"`
	TagID           int32 `json:"tag_id"`
	IsNegated       bool  `json:"is_negated"`
}

const checkPublisherVerified = `-- name: CheckPublisherVerified :one

SELECT p.is_verified FROM publishers p WHERE p.id = $1 AND p.status_id = (SELECT ps.id FROM publisher_statuses ps WHERE ps.key = 'active')
`

// ============================================================================
// Queries for Publisher Zman Linking/Copying
// ============================================================================
// Verify a publisher is active and verified
func (q *Queries) CheckPublisherVerified(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRow(ctx, checkPublisherVerified, id)
	var is_verified bool
	err := row.Scan(&is_verified)
	return is_verified, err
}

const checkZmanKeyExists = `-- name: CheckZmanKeyExists :one
SELECT EXISTS(
    SELECT 1 FROM publisher_zmanim
    WHERE publisher_id = $1 AND zman_key = $2 AND deleted_at IS NULL
) AS exists
`

type CheckZmanKeyExistsParams struct {
	PublisherID int32  `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

// Check if a zman_key already exists for a publisher
func (q *Queries) CheckZmanKeyExists(ctx context.Context, arg CheckZmanKeyExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkZmanKeyExists, arg.PublisherID, arg.ZmanKey)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countPublisherZmanim = `-- name: CountPublisherZmanim :one
SELECT COUNT(*) FROM publisher_zmanim WHERE publisher_id = $1
`

func (q *Queries) CountPublisherZmanim(ctx context.Context, publisherID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countPublisherZmanim, publisherID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLinkedOrCopiedZman = `-- name: CreateLinkedOrCopiedZman :one
INSERT INTO publisher_zmanim (
    publisher_id, zman_key, hebrew_name, english_name,
    formula_dsl, is_enabled, is_visible, is_published, is_custom, time_category_id,
    dependencies, master_zman_id, linked_publisher_zman_id
) VALUES (
    $1, $2, $3, $4, $5, true, true, false, false, $6, $7, $8, $9
)
RETURNING id, created_at, updated_at
`

type CreateLinkedOrCopiedZmanParams struct {
	PublisherID           int32    `json:"publisher_id"`
	ZmanKey               string   `json:"zman_key"`
	HebrewName            string   `json:"hebrew_name"`
	EnglishName           string   `json:"english_name"`
	FormulaDsl            string   `json:"formula_dsl"`
	TimeCategoryID        *int32   `json:"time_category_id"`
	Dependencies          []string `json:"dependencies"`
	MasterZmanID          *int32   `json:"master_zman_id"`
	LinkedPublisherZmanID *int32   `json:"linked_publisher_zman_id"`
}

type CreateLinkedOrCopiedZmanRow struct {
	ID        int32              `json:"id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// Create a new zman from another publisher (linked or copied)
func (q *Queries) CreateLinkedOrCopiedZman(ctx context.Context, arg CreateLinkedOrCopiedZmanParams) (CreateLinkedOrCopiedZmanRow, error) {
	row := q.db.QueryRow(ctx, createLinkedOrCopiedZman,
		arg.PublisherID,
		arg.ZmanKey,
		arg.HebrewName,
		arg.EnglishName,
		arg.FormulaDsl,
		arg.TimeCategoryID,
		arg.Dependencies,
		arg.MasterZmanID,
		arg.LinkedPublisherZmanID,
	)
	var i CreateLinkedOrCopiedZmanRow
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const createPublisherZman = `-- name: CreatePublisherZman :one
INSERT INTO publisher_zmanim (
    id, publisher_id, zman_key, hebrew_name, english_name,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_beta, is_custom, time_category_id,
    dependencies, master_zman_id, linked_publisher_zman_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
)
RETURNING id, publisher_id, zman_key, hebrew_name, english_name,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_beta, is_custom, time_category_id,
    dependencies, master_zman_id, linked_publisher_zman_id,
    created_at, updated_at
`

type CreatePublisherZmanParams struct {
	ID                    int32    `json:"id"`
	PublisherID           int32    `json:"publisher_id"`
	ZmanKey               string   `json:"zman_key"`
	HebrewName            string   `json:"hebrew_name"`
	EnglishName           string   `json:"english_name"`
	FormulaDsl            string   `json:"formula_dsl"`
	AiExplanation         *string  `json:"ai_explanation"`
	PublisherComment      *string  `json:"publisher_comment"`
	IsEnabled             bool     `json:"is_enabled"`
	IsVisible             bool     `json:"is_visible"`
	IsPublished           bool     `json:"is_published"`
	IsBeta                bool     `json:"is_beta"`
	IsCustom              bool     `json:"is_custom"`
	TimeCategoryID        *int32   `json:"time_category_id"`
	Dependencies          []string `json:"dependencies"`
	MasterZmanID          *int32   `json:"master_zman_id"`
	LinkedPublisherZmanID *int32   `json:"linked_publisher_zman_id"`
}

type CreatePublisherZmanRow struct {
	ID                    int32              `json:"id"`
	PublisherID           int32              `json:"publisher_id"`
	ZmanKey               string             `json:"zman_key"`
	HebrewName            string             `json:"hebrew_name"`
	EnglishName           string             `json:"english_name"`
	FormulaDsl            string             `json:"formula_dsl"`
	AiExplanation         *string            `json:"ai_explanation"`
	PublisherComment      *string            `json:"publisher_comment"`
	IsEnabled             bool               `json:"is_enabled"`
	IsVisible             bool               `json:"is_visible"`
	IsPublished           bool               `json:"is_published"`
	IsBeta                bool               `json:"is_beta"`
	IsCustom              bool               `json:"is_custom"`
	TimeCategoryID        *int32             `json:"time_category_id"`
	Dependencies          []string           `json:"dependencies"`
	MasterZmanID          *int32             `json:"master_zman_id"`
	LinkedPublisherZmanID *int32             `json:"linked_publisher_zman_id"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreatePublisherZman(ctx context.Context, arg CreatePublisherZmanParams) (CreatePublisherZmanRow, error) {
	row := q.db.QueryRow(ctx, createPublisherZman,
		arg.ID,
		arg.PublisherID,
		arg.ZmanKey,
		arg.HebrewName,
		arg.EnglishName,
		arg.FormulaDsl,
		arg.AiExplanation,
		arg.PublisherComment,
		arg.IsEnabled,
		arg.IsVisible,
		arg.IsPublished,
		arg.IsBeta,
		arg.IsCustom,
		arg.TimeCategoryID,
		arg.Dependencies,
		arg.MasterZmanID,
		arg.LinkedPublisherZmanID,
	)
	var i CreatePublisherZmanRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.FormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsBeta,
		&i.IsCustom,
		&i.TimeCategoryID,
		&i.Dependencies,
		&i.MasterZmanID,
		&i.LinkedPublisherZmanID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePublisherZman = `-- name: DeletePublisherZman :one
DELETE FROM publisher_zmanim
WHERE publisher_id = $1 AND zman_key = $2 AND is_custom = true
RETURNING id
`

type DeletePublisherZmanParams struct {
	PublisherID int32  `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

// Hard delete for custom zmanim only
func (q *Queries) DeletePublisherZman(ctx context.Context, arg DeletePublisherZmanParams) (int32, error) {
	row := q.db.QueryRow(ctx, deletePublisherZman, arg.PublisherID, arg.ZmanKey)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deletePublisherZmanTags = `-- name: DeletePublisherZmanTags :exec
DELETE FROM publisher_zman_tags WHERE publisher_zman_id = $1
`

// Delete all tags for a publisher zman
func (q *Queries) DeletePublisherZmanTags(ctx context.Context, publisherZmanID int32) error {
	_, err := q.db.Exec(ctx, deletePublisherZmanTags, publisherZmanID)
	return err
}

const fetchPublisherZmanim = `-- name: FetchPublisherZmanim :many

SELECT
    pz.id, pz.publisher_id, pz.zman_key, pz.hebrew_name, pz.english_name,
    pz.transliteration, pz.description,
    COALESCE(linked_pz.formula_dsl, pz.formula_dsl) AS formula_dsl,
    pz.ai_explanation, pz.publisher_comment,
    pz.is_enabled, pz.is_visible, pz.is_published, pz.is_beta, pz.is_custom,
    pz.display_status,
    pz.time_category_id,
    tc.key AS category,
    pz.dependencies, pz.rounding_mode, pz.created_at, pz.updated_at, pz.deleted_at,
    pz.master_zman_id, pz.linked_publisher_zman_id,
    -- Source/original values from registry or linked publisher (for diff/revert UI)
    COALESCE(mr.canonical_hebrew_name, linked_pz.hebrew_name, '') AS source_hebrew_name,
    COALESCE(mr.canonical_english_name, linked_pz.english_name, '') AS source_english_name,
    COALESCE(mr.transliteration, linked_pz.transliteration) AS source_transliteration,
    COALESCE(mr.description, linked_pz.description) AS source_description,
    COALESCE(mr.default_formula_dsl, linked_pz.formula_dsl, '') AS source_formula_dsl,
    -- Check if this zman is an event zman (has event tags or special category tags like category_candle_lighting, category_havdalah, etc.)
    EXISTS (
        SELECT 1 FROM (
            -- Check master zman tags
            SELECT tt.key, zt.tag_key FROM master_zman_tags mzt
            JOIN zman_tags zt ON mzt.tag_id = zt.id
            JOIN tag_types tt ON zt.tag_type_id = tt.id
            WHERE mzt.master_zman_id = pz.master_zman_id
            UNION ALL
            -- Check publisher-specific tags
            SELECT tt.key, zt.tag_key FROM publisher_zman_tags pzt
            JOIN zman_tags zt ON pzt.tag_id = zt.id
            JOIN tag_types tt ON zt.tag_type_id = tt.id
            WHERE pzt.publisher_zman_id = pz.id
        ) all_tags
        WHERE all_tags.key = 'event'
           OR all_tags.tag_key IN ('category_candle_lighting', 'category_havdalah', 'category_fast_start', 'category_fast_end')
    ) AS is_event_zman,
    -- Tags: Publisher tags take precedence over master tags (no duplicates)
    -- If publisher has customized tags, show ONLY publisher tags
    -- Otherwise, show master registry tags
    -- is_modified flag indicates if publisher tag differs from master (different negation or tag doesn't exist in master)
    -- Display name respects publisher's transliteration_style preference
    COALESCE(
        (SELECT json_agg(json_build_object(
            'id', sub.id,
            'tag_key', sub.tag_key,
            'name', sub.name,
            'display_name_hebrew', sub.display_name_hebrew,
            'display_name_english', CASE
                WHEN COALESCE($1::text, 'ashkenazi') = 'sephardi'
                THEN COALESCE(sub.display_name_english_sephardi, sub.display_name_english_ashkenazi)
                ELSE sub.display_name_english_ashkenazi
            END,
            'tag_type', sub.tag_type,
            'is_negated', sub.is_negated,
            'is_modified', sub.is_modified,
            'source_is_negated', sub.source_is_negated
        ) ORDER BY sub.sort_order)
        FROM (
            -- Publisher-specific tags (if any exist, these take full precedence)
            SELECT t.id, t.tag_key, t.name, t.display_name_hebrew,
                   t.display_name_english_ashkenazi, t.display_name_english_sephardi,
                   tt.key AS tag_type, t.sort_order, pzt.is_negated,
                   -- Check if this tag is modified from master registry
                   CASE
                       WHEN mzt.tag_id IS NULL THEN true  -- Tag added by publisher (not in master)
                       WHEN pzt.is_negated != mzt.is_negated THEN true  -- Negation changed
                       ELSE false
                   END AS is_modified,
                   mzt.is_negated AS source_is_negated
            FROM publisher_zman_tags pzt
            JOIN zman_tags t ON pzt.tag_id = t.id
            JOIN tag_types tt ON t.tag_type_id = tt.id
            LEFT JOIN master_zman_tags mzt ON mzt.master_zman_id = pz.master_zman_id
                                            AND mzt.tag_id = pzt.tag_id
            WHERE pzt.publisher_zman_id = pz.id
            UNION ALL
            -- Master tags (only if NO publisher tags exist for this zman)
            SELECT t.id, t.tag_key, t.name, t.display_name_hebrew,
                   t.display_name_english_ashkenazi, t.display_name_english_sephardi,
                   tt.key AS tag_type, t.sort_order, mzt.is_negated,
                   false AS is_modified,  -- Not modified since using master tags
                   mzt.is_negated AS source_is_negated
            FROM master_zman_tags mzt
            JOIN zman_tags t ON mzt.tag_id = t.id
            JOIN tag_types tt ON t.tag_type_id = tt.id
            WHERE mzt.master_zman_id = pz.master_zman_id
              AND NOT EXISTS (SELECT 1 FROM publisher_zman_tags WHERE publisher_zman_id = pz.id)
        ) sub),
        '[]'::json
    ) AS tags,
    CASE WHEN pz.linked_publisher_zman_id IS NOT NULL THEN true ELSE false END AS is_linked,
    linked_pub.name AS linked_source_publisher_name,
    CASE WHEN pz.linked_publisher_zman_id IS NOT NULL AND linked_pz.deleted_at IS NOT NULL
         THEN true ELSE false END AS linked_source_is_deleted,
    COALESCE(mr_tc.key, tc.key, 'uncategorized') AS time_category
FROM publisher_zmanim pz
LEFT JOIN publisher_zmanim linked_pz ON pz.linked_publisher_zman_id = linked_pz.id
LEFT JOIN publishers linked_pub ON linked_pz.publisher_id = linked_pub.id
LEFT JOIN master_zmanim_registry mr ON pz.master_zman_id = mr.id
LEFT JOIN time_categories tc ON pz.time_category_id = tc.id
LEFT JOIN time_categories mr_tc ON mr.time_category_id = mr_tc.id
WHERE pz.publisher_id = $2
  AND ($3::boolean = true OR pz.deleted_at IS NULL)
ORDER BY
    COALESCE(mr_tc.sort_order, tc.sort_order, 99),
    pz.hebrew_name
`

type FetchPublisherZmanimParams struct {
	TransliterationStyle *string `json:"transliteration_style"`
	PublisherID          int32   `json:"publisher_id"`
	IncludeDeleted       *bool   `json:"include_deleted"`
}

type FetchPublisherZmanimRow struct {
	ID                        int32              `json:"id"`
	PublisherID               int32              `json:"publisher_id"`
	ZmanKey                   string             `json:"zman_key"`
	HebrewName                string             `json:"hebrew_name"`
	EnglishName               string             `json:"english_name"`
	Transliteration           *string            `json:"transliteration"`
	Description               *string            `json:"description"`
	FormulaDsl                string             `json:"formula_dsl"`
	AiExplanation             *string            `json:"ai_explanation"`
	PublisherComment          *string            `json:"publisher_comment"`
	IsEnabled                 bool               `json:"is_enabled"`
	IsVisible                 bool               `json:"is_visible"`
	IsPublished               bool               `json:"is_published"`
	IsBeta                    bool               `json:"is_beta"`
	IsCustom                  bool               `json:"is_custom"`
	DisplayStatus             DisplayStatus      `json:"display_status"`
	TimeCategoryID            *int32             `json:"time_category_id"`
	Category                  *string            `json:"category"`
	Dependencies              []string           `json:"dependencies"`
	RoundingMode              string             `json:"rounding_mode"`
	CreatedAt                 pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                 pgtype.Timestamptz `json:"updated_at"`
	DeletedAt                 pgtype.Timestamptz `json:"deleted_at"`
	MasterZmanID              *int32             `json:"master_zman_id"`
	LinkedPublisherZmanID     *int32             `json:"linked_publisher_zman_id"`
	SourceHebrewName          string             `json:"source_hebrew_name"`
	SourceEnglishName         string             `json:"source_english_name"`
	SourceTransliteration     *string            `json:"source_transliteration"`
	SourceDescription         *string            `json:"source_description"`
	SourceFormulaDsl          string             `json:"source_formula_dsl"`
	IsEventZman               bool               `json:"is_event_zman"`
	Tags                      interface{}        `json:"tags"`
	IsLinked                  bool               `json:"is_linked"`
	LinkedSourcePublisherName *string            `json:"linked_source_publisher_name"`
	LinkedSourceIsDeleted     bool               `json:"linked_source_is_deleted"`
	TimeCategory              string             `json:"time_category"`
}

// ============================================================================
// Queries for fetchPublisherZmanim (complex join with tags and source info)
// ============================================================================
// Get all zmanim for a publisher with full tag and source information
// This replaces the raw SQL query in fetchPublisherZmanim function
// @param transliteration_style: 'ashkenazi' (default) or 'sephardi' - controls tag display names
func (q *Queries) FetchPublisherZmanim(ctx context.Context, arg FetchPublisherZmanimParams) ([]FetchPublisherZmanimRow, error) {
	rows, err := q.db.Query(ctx, fetchPublisherZmanim, arg.TransliterationStyle, arg.PublisherID, arg.IncludeDeleted)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchPublisherZmanimRow{}
	for rows.Next() {
		var i FetchPublisherZmanimRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.Transliteration,
			&i.Description,
			&i.FormulaDsl,
			&i.AiExplanation,
			&i.PublisherComment,
			&i.IsEnabled,
			&i.IsVisible,
			&i.IsPublished,
			&i.IsBeta,
			&i.IsCustom,
			&i.DisplayStatus,
			&i.TimeCategoryID,
			&i.Category,
			&i.Dependencies,
			&i.RoundingMode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.MasterZmanID,
			&i.LinkedPublisherZmanID,
			&i.SourceHebrewName,
			&i.SourceEnglishName,
			&i.SourceTransliteration,
			&i.SourceDescription,
			&i.SourceFormulaDsl,
			&i.IsEventZman,
			&i.Tags,
			&i.IsLinked,
			&i.LinkedSourcePublisherName,
			&i.LinkedSourceIsDeleted,
			&i.TimeCategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllMasterZmanimMetadata = `-- name: GetAllMasterZmanimMetadata :many
SELECT
    mr.zman_key,
    COALESCE(tc.key, '') as time_category,
    COALESCE(mr.canonical_hebrew_name, '') as canonical_hebrew_name,
    COALESCE(mr.canonical_english_name, '') as canonical_english_name,
    COALESCE(mr.default_formula_dsl, '') as default_formula_dsl,
    mr.is_core,
    COALESCE(mr.halachic_source, '') as halachic_source
FROM master_zmanim_registry mr
LEFT JOIN time_categories tc ON mr.time_category_id = tc.id
`

type GetAllMasterZmanimMetadataRow struct {
	ZmanKey              string `json:"zman_key"`
	TimeCategory         string `json:"time_category"`
	CanonicalHebrewName  string `json:"canonical_hebrew_name"`
	CanonicalEnglishName string `json:"canonical_english_name"`
	DefaultFormulaDsl    string `json:"default_formula_dsl"`
	IsCore               *bool  `json:"is_core"`
	HalachicSource       string `json:"halachic_source"`
}

// Get metadata for all zmanim from master registry with time category key
func (q *Queries) GetAllMasterZmanimMetadata(ctx context.Context) ([]GetAllMasterZmanimMetadataRow, error) {
	rows, err := q.db.Query(ctx, getAllMasterZmanimMetadata)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllMasterZmanimMetadataRow{}
	for rows.Next() {
		var i GetAllMasterZmanimMetadataRow
		if err := rows.Scan(
			&i.ZmanKey,
			&i.TimeCategory,
			&i.CanonicalHebrewName,
			&i.CanonicalEnglishName,
			&i.DefaultFormulaDsl,
			&i.IsCore,
			&i.HalachicSource,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllZmanimTags = `-- name: GetAllZmanimTags :many
SELECT
    mr.zman_key,
    t.id,
    t.tag_key,
    t.name,
    t.display_name_english_ashkenazi,
    t.display_name_english_sephardi,
    t.display_name_hebrew,
    tt.key AS tag_type,
    t.color,
    t.sort_order,
    COALESCE(mzt.is_negated, false) AS is_negated,
    t.created_at
FROM master_zmanim_registry mr
JOIN master_zman_tags mzt ON mr.id = mzt.master_zman_id
JOIN zman_tags t ON mzt.tag_id = t.id
JOIN tag_types tt ON t.tag_type_id = tt.id
ORDER BY mr.zman_key, tt.key, t.sort_order
`

type GetAllZmanimTagsRow struct {
	ZmanKey                     string             `json:"zman_key"`
	ID                          int32              `json:"id"`
	TagKey                      string             `json:"tag_key"`
	Name                        string             `json:"name"`
	DisplayNameEnglishAshkenazi string             `json:"display_name_english_ashkenazi"`
	DisplayNameEnglishSephardi  *string            `json:"display_name_english_sephardi"`
	DisplayNameHebrew           string             `json:"display_name_hebrew"`
	TagType                     string             `json:"tag_type"`
	Color                       *string            `json:"color"`
	SortOrder                   *int32             `json:"sort_order"`
	IsNegated                   bool               `json:"is_negated"`
	CreatedAt                   pgtype.Timestamptz `json:"created_at"`
}

// Get all tags for all zmanim with tag type key, sort order, and negation status
// Returns both Ashkenazi and Sephardi display names for Go code to select based on context
func (q *Queries) GetAllZmanimTags(ctx context.Context) ([]GetAllZmanimTagsRow, error) {
	rows, err := q.db.Query(ctx, getAllZmanimTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllZmanimTagsRow{}
	for rows.Next() {
		var i GetAllZmanimTagsRow
		if err := rows.Scan(
			&i.ZmanKey,
			&i.ID,
			&i.TagKey,
			&i.Name,
			&i.DisplayNameEnglishAshkenazi,
			&i.DisplayNameEnglishSephardi,
			&i.DisplayNameHebrew,
			&i.TagType,
			&i.Color,
			&i.SortOrder,
			&i.IsNegated,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocalityDetailsForZmanim = `-- name: GetLocalityDetailsForZmanim :one

SELECT l.name, co.name as country, co.code as country_code, r.name as region,
       l.timezone, rc.latitude, rc.longitude, COALESCE(rc.elevation_m, 0) as elevation,
       s.display_hierarchy
FROM geo_localities l
JOIN geo_countries co ON l.country_id = co.id
LEFT JOIN geo_locality_resolved_coords rc ON rc.locality_id = l.id
LEFT JOIN geo_search_index s ON s.entity_type = 'locality' AND s.entity_id = l.id
LEFT JOIN geo_regions r ON s.inherited_region_id = r.id
WHERE l.id = $1
`

type GetLocalityDetailsForZmanimRow struct {
	Name             string   `json:"name"`
	Country          string   `json:"country"`
	CountryCode      string   `json:"country_code"`
	Region           *string  `json:"region"`
	Timezone         string   `json:"timezone"`
	Latitude         *float64 `json:"latitude"`
	Longitude        *float64 `json:"longitude"`
	Elevation        int32    `json:"elevation"`
	DisplayHierarchy *string  `json:"display_hierarchy"`
}

// ============================================================================
// Queries for GetZmanimForCity handler
// ============================================================================
// Get locality details with country, region, and display hierarchy for zmanim calculation
// display_hierarchy contains the full location chain (e.g., "Prestwich, Bury, England, United Kingdom")
// Elevation defaults to 0 if NULL (sea level) - required for accurate zmanim
// Region is resolved from geo_search_index.inherited_region_id (pre-computed during import)
// Coordinates/elevation resolved with priority: admin > default (system-wide only, no publisher context)
func (q *Queries) GetLocalityDetailsForZmanim(ctx context.Context, id int32) (GetLocalityDetailsForZmanimRow, error) {
	row := q.db.QueryRow(ctx, getLocalityDetailsForZmanim, id)
	var i GetLocalityDetailsForZmanimRow
	err := row.Scan(
		&i.Name,
		&i.Country,
		&i.CountryCode,
		&i.Region,
		&i.Timezone,
		&i.Latitude,
		&i.Longitude,
		&i.Elevation,
		&i.DisplayHierarchy,
	)
	return i, err
}

const getPublisherAlgorithm = `-- name: GetPublisherAlgorithm :one
SELECT configuration
FROM algorithms
WHERE publisher_id = $1 AND status = 'published'
LIMIT 1
`

// Get publisher's published algorithm configuration
func (q *Queries) GetPublisherAlgorithm(ctx context.Context, publisherID int32) ([]byte, error) {
	row := q.db.QueryRow(ctx, getPublisherAlgorithm, publisherID)
	var configuration []byte
	err := row.Scan(&configuration)
	return configuration, err
}

const getPublisherBetaZmanim = `-- name: GetPublisherBetaZmanim :many
SELECT zman_key, is_beta
FROM publisher_zmanim
WHERE publisher_id = $1 AND deleted_at IS NULL AND is_beta = true
`

type GetPublisherBetaZmanimRow struct {
	ZmanKey string `json:"zman_key"`
	IsBeta  bool   `json:"is_beta"`
}

// Get beta status for zmanim for a publisher
func (q *Queries) GetPublisherBetaZmanim(ctx context.Context, publisherID int32) ([]GetPublisherBetaZmanimRow, error) {
	rows, err := q.db.Query(ctx, getPublisherBetaZmanim, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherBetaZmanimRow{}
	for rows.Next() {
		var i GetPublisherBetaZmanimRow
		if err := rows.Scan(&i.ZmanKey, &i.IsBeta); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherInfoForZmanim = `-- name: GetPublisherInfoForZmanim :one
SELECT name, logo_data, is_certified FROM publishers WHERE id = $1
`

type GetPublisherInfoForZmanimRow struct {
	Name        string  `json:"name"`
	LogoData    *string `json:"logo_data"`
	IsCertified bool    `json:"is_certified"`
}

// Get publisher info (logo_data is the base64 embedded logo)
func (q *Queries) GetPublisherInfoForZmanim(ctx context.Context, id int32) (GetPublisherInfoForZmanimRow, error) {
	row := q.db.QueryRow(ctx, getPublisherInfoForZmanim, id)
	var i GetPublisherInfoForZmanimRow
	err := row.Scan(&i.Name, &i.LogoData, &i.IsCertified)
	return i, err
}

const getPublisherZmanByID = `-- name: GetPublisherZmanByID :one
SELECT
    pz.id, pz.publisher_id, pz.zman_key, pz.hebrew_name, pz.english_name,
    pz.formula_dsl, pz.ai_explanation, pz.publisher_comment,
    pz.is_enabled, pz.is_visible, pz.is_published, pz.is_custom,
    pz.time_category_id,
    tc.key AS category,
    tc.display_name_hebrew AS category_display_hebrew,
    tc.display_name_english AS category_display_english,
    pz.dependencies, pz.master_zman_id, pz.linked_publisher_zman_id,
    pz.deleted_at, pz.created_at, pz.updated_at,
    p.name AS publisher_name,
    p.is_verified AS publisher_is_verified
FROM publisher_zmanim pz
JOIN publishers p ON p.id = pz.publisher_id
LEFT JOIN time_categories tc ON pz.time_category_id = tc.id
WHERE pz.id = $1
`

type GetPublisherZmanByIDRow struct {
	ID                     int32              `json:"id"`
	PublisherID            int32              `json:"publisher_id"`
	ZmanKey                string             `json:"zman_key"`
	HebrewName             string             `json:"hebrew_name"`
	EnglishName            string             `json:"english_name"`
	FormulaDsl             string             `json:"formula_dsl"`
	AiExplanation          *string            `json:"ai_explanation"`
	PublisherComment       *string            `json:"publisher_comment"`
	IsEnabled              bool               `json:"is_enabled"`
	IsVisible              bool               `json:"is_visible"`
	IsPublished            bool               `json:"is_published"`
	IsCustom               bool               `json:"is_custom"`
	TimeCategoryID         *int32             `json:"time_category_id"`
	Category               *string            `json:"category"`
	CategoryDisplayHebrew  *string            `json:"category_display_hebrew"`
	CategoryDisplayEnglish *string            `json:"category_display_english"`
	Dependencies           []string           `json:"dependencies"`
	MasterZmanID           *int32             `json:"master_zman_id"`
	LinkedPublisherZmanID  *int32             `json:"linked_publisher_zman_id"`
	DeletedAt              pgtype.Timestamptz `json:"deleted_at"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	PublisherName          string             `json:"publisher_name"`
	PublisherIsVerified    bool               `json:"publisher_is_verified"`
}

// Get a specific zman by ID (for linking validation)
func (q *Queries) GetPublisherZmanByID(ctx context.Context, id int32) (GetPublisherZmanByIDRow, error) {
	row := q.db.QueryRow(ctx, getPublisherZmanByID, id)
	var i GetPublisherZmanByIDRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.FormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsCustom,
		&i.TimeCategoryID,
		&i.Category,
		&i.CategoryDisplayHebrew,
		&i.CategoryDisplayEnglish,
		&i.Dependencies,
		&i.MasterZmanID,
		&i.LinkedPublisherZmanID,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublisherName,
		&i.PublisherIsVerified,
	)
	return i, err
}

const getPublisherZmanByKey = `-- name: GetPublisherZmanByKey :one
SELECT
    pz.id, pz.publisher_id, pz.zman_key, pz.hebrew_name, pz.english_name,
    pz.transliteration, pz.description,
    COALESCE(linked_pz.formula_dsl, pz.formula_dsl) AS formula_dsl,
    pz.ai_explanation, pz.publisher_comment,
    pz.is_enabled, pz.is_visible, pz.is_published, pz.is_beta, pz.is_custom,
    pz.display_status,
    pz.dependencies, pz.rounding_mode, pz.created_at, pz.updated_at,
    pz.master_zman_id, pz.linked_publisher_zman_id,
    -- Time category ID and display values
    pz.time_category_id,
    tc.key AS category,
    tc.display_name_hebrew AS category_display_hebrew,
    tc.display_name_english AS category_display_english,
    -- Source/original values from registry or linked publisher (for diff/revert UI)
    COALESCE(mr.canonical_hebrew_name, linked_pz.hebrew_name, '') AS source_hebrew_name,
    COALESCE(mr.canonical_english_name, linked_pz.english_name, '') AS source_english_name,
    COALESCE(mr.transliteration, linked_pz.transliteration) AS source_transliteration,
    COALESCE(mr.description, linked_pz.description) AS source_description,
    COALESCE(mr.default_formula_dsl, linked_pz.formula_dsl, '') AS source_formula_dsl,
    -- Linked source info
    CASE WHEN pz.linked_publisher_zman_id IS NOT NULL THEN true ELSE false END AS is_linked,
    linked_pub.name AS linked_source_publisher_name,
    -- Time category key for consistency
    COALESCE(mr_tc.key, tc.key, 'uncategorized') AS time_category
FROM publisher_zmanim pz
LEFT JOIN time_categories tc ON pz.time_category_id = tc.id
LEFT JOIN publisher_zmanim linked_pz ON pz.linked_publisher_zman_id = linked_pz.id
LEFT JOIN publishers linked_pub ON linked_pz.publisher_id = linked_pub.id
LEFT JOIN master_zmanim_registry mr ON pz.master_zman_id = mr.id
LEFT JOIN time_categories mr_tc ON mr.time_category_id = mr_tc.id
WHERE pz.publisher_id = $1 AND pz.zman_key = $2 AND pz.deleted_at IS NULL
`

type GetPublisherZmanByKeyParams struct {
	PublisherID int32  `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

type GetPublisherZmanByKeyRow struct {
	ID                        int32              `json:"id"`
	PublisherID               int32              `json:"publisher_id"`
	ZmanKey                   string             `json:"zman_key"`
	HebrewName                string             `json:"hebrew_name"`
	EnglishName               string             `json:"english_name"`
	Transliteration           *string            `json:"transliteration"`
	Description               *string            `json:"description"`
	FormulaDsl                string             `json:"formula_dsl"`
	AiExplanation             *string            `json:"ai_explanation"`
	PublisherComment          *string            `json:"publisher_comment"`
	IsEnabled                 bool               `json:"is_enabled"`
	IsVisible                 bool               `json:"is_visible"`
	IsPublished               bool               `json:"is_published"`
	IsBeta                    bool               `json:"is_beta"`
	IsCustom                  bool               `json:"is_custom"`
	DisplayStatus             DisplayStatus      `json:"display_status"`
	Dependencies              []string           `json:"dependencies"`
	RoundingMode              string             `json:"rounding_mode"`
	CreatedAt                 pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                 pgtype.Timestamptz `json:"updated_at"`
	MasterZmanID              *int32             `json:"master_zman_id"`
	LinkedPublisherZmanID     *int32             `json:"linked_publisher_zman_id"`
	TimeCategoryID            *int32             `json:"time_category_id"`
	Category                  *string            `json:"category"`
	CategoryDisplayHebrew     *string            `json:"category_display_hebrew"`
	CategoryDisplayEnglish    *string            `json:"category_display_english"`
	SourceHebrewName          string             `json:"source_hebrew_name"`
	SourceEnglishName         string             `json:"source_english_name"`
	SourceTransliteration     *string            `json:"source_transliteration"`
	SourceDescription         *string            `json:"source_description"`
	SourceFormulaDsl          string             `json:"source_formula_dsl"`
	IsLinked                  bool               `json:"is_linked"`
	LinkedSourcePublisherName *string            `json:"linked_source_publisher_name"`
	TimeCategory              string             `json:"time_category"`
}

func (q *Queries) GetPublisherZmanByKey(ctx context.Context, arg GetPublisherZmanByKeyParams) (GetPublisherZmanByKeyRow, error) {
	row := q.db.QueryRow(ctx, getPublisherZmanByKey, arg.PublisherID, arg.ZmanKey)
	var i GetPublisherZmanByKeyRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.Transliteration,
		&i.Description,
		&i.FormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsBeta,
		&i.IsCustom,
		&i.DisplayStatus,
		&i.Dependencies,
		&i.RoundingMode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MasterZmanID,
		&i.LinkedPublisherZmanID,
		&i.TimeCategoryID,
		&i.Category,
		&i.CategoryDisplayHebrew,
		&i.CategoryDisplayEnglish,
		&i.SourceHebrewName,
		&i.SourceEnglishName,
		&i.SourceTransliteration,
		&i.SourceDescription,
		&i.SourceFormulaDsl,
		&i.IsLinked,
		&i.LinkedSourcePublisherName,
		&i.TimeCategory,
	)
	return i, err
}

const getPublisherZmanIDByKey = `-- name: GetPublisherZmanIDByKey :one

SELECT id FROM publisher_zmanim
WHERE publisher_id = $1 AND zman_key = $2 AND deleted_at IS NULL
`

type GetPublisherZmanIDByKeyParams struct {
	PublisherID int32  `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

// ============================================================================
// Helper Queries for Publisher Zman Operations
// ============================================================================
// Get publisher zman ID by publisher ID and zman key
func (q *Queries) GetPublisherZmanIDByKey(ctx context.Context, arg GetPublisherZmanIDByKeyParams) (int32, error) {
	row := q.db.QueryRow(ctx, getPublisherZmanIDByKey, arg.PublisherID, arg.ZmanKey)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getPublisherZmanTags = `-- name: GetPublisherZmanTags :many

SELECT
    t.id, t.tag_key, t.name, t.display_name_hebrew, t.display_name_english_ashkenazi,
    t.tag_type_id,
    tt.key AS tag_type,
    tt.display_name_hebrew AS tag_type_display_hebrew,
    tt.display_name_english AS tag_type_display_english,
    t.description, t.sort_order, pzt.is_negated
FROM publisher_zman_tags pzt
JOIN zman_tags t ON t.id = pzt.tag_id
LEFT JOIN tag_types tt ON t.tag_type_id = tt.id
WHERE pzt.publisher_zman_id = $1
ORDER BY t.sort_order, t.display_name_english_ashkenazi
`

type GetPublisherZmanTagsRow struct {
	ID                          int32   `json:"id"`
	TagKey                      string  `json:"tag_key"`
	Name                        string  `json:"name"`
	DisplayNameHebrew           string  `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string  `json:"display_name_english_ashkenazi"`
	TagTypeID                   int32   `json:"tag_type_id"`
	TagType                     *string `json:"tag_type"`
	TagTypeDisplayHebrew        *string `json:"tag_type_display_hebrew"`
	TagTypeDisplayEnglish       *string `json:"tag_type_display_english"`
	Description                 *string `json:"description"`
	SortOrder                   *int32  `json:"sort_order"`
	IsNegated                   bool    `json:"is_negated"`
}

// ============================================================================
// Publisher Zman Tags
// ============================================================================
// Get all tags for a specific publisher zman (including is_negated)
func (q *Queries) GetPublisherZmanTags(ctx context.Context, publisherZmanID int32) ([]GetPublisherZmanTagsRow, error) {
	rows, err := q.db.Query(ctx, getPublisherZmanTags, publisherZmanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherZmanTagsRow{}
	for rows.Next() {
		var i GetPublisherZmanTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.TagKey,
			&i.Name,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglishAshkenazi,
			&i.TagTypeID,
			&i.TagType,
			&i.TagTypeDisplayHebrew,
			&i.TagTypeDisplayEnglish,
			&i.Description,
			&i.SortOrder,
			&i.IsNegated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherZmanim = `-- name: GetPublisherZmanim :many


SELECT
    pz.id, pz.publisher_id, pz.zman_key, pz.hebrew_name, pz.english_name,
    pz.transliteration, pz.description,
    -- Resolve formula from linked source if applicable
    COALESCE(linked_pz.formula_dsl, pz.formula_dsl) AS formula_dsl,
    pz.ai_explanation, pz.publisher_comment,
    pz.is_enabled, pz.is_visible, pz.is_published, pz.is_beta, pz.is_custom,
    pz.display_status,
    pz.dependencies, pz.rounding_mode, pz.created_at, pz.updated_at,
    pz.master_zman_id, pz.linked_publisher_zman_id,
    -- Time category ID and display values
    pz.time_category_id,
    tc.key AS category,
    tc.display_name_hebrew AS category_display_hebrew,
    tc.display_name_english AS category_display_english,
    -- Source/original values from registry or linked publisher (for diff/revert UI)
    COALESCE(mr.canonical_hebrew_name, linked_pz.hebrew_name, '') AS source_hebrew_name,
    COALESCE(mr.canonical_english_name, linked_pz.english_name, '') AS source_english_name,
    COALESCE(mr.transliteration, linked_pz.transliteration) AS source_transliteration,
    COALESCE(mr.description, linked_pz.description) AS source_description,
    COALESCE(mr.default_formula_dsl, linked_pz.formula_dsl, '') AS source_formula_dsl,
    -- Check if this zman is an event zman (has event tags or special category tags like category_candle_lighting, category_havdalah, etc.)
    EXISTS (
        SELECT 1 FROM (
            -- Check master zman tags
            SELECT tt.key, zt.tag_key FROM master_zman_tags mzt
            JOIN zman_tags zt ON mzt.tag_id = zt.id
            JOIN tag_types tt ON zt.tag_type_id = tt.id
            WHERE mzt.master_zman_id = pz.master_zman_id
            UNION ALL
            -- Check publisher-specific tags
            SELECT tt.key, zt.tag_key FROM publisher_zman_tags pzt
            JOIN zman_tags zt ON pzt.tag_id = zt.id
            JOIN tag_types tt ON zt.tag_type_id = tt.id
            WHERE pzt.publisher_zman_id = pz.id
        ) all_tags
        WHERE all_tags.key = 'event'
           OR all_tags.tag_key IN ('category_candle_lighting', 'category_havdalah', 'category_fast_start', 'category_fast_end')
    ) AS is_event_zman,
    -- Tags: Publisher tags take precedence over master tags (no duplicates)
    -- If publisher has customized tags, show ONLY publisher tags
    -- Otherwise, show master registry tags
    -- is_modified flag indicates if publisher tag differs from master (different negation or tag doesn't exist in master)
    COALESCE(
        (SELECT json_agg(json_build_object(
            'id', sub.id,
            'tag_key', sub.tag_key,
            'name', sub.name,
            'display_name_hebrew', sub.display_name_hebrew,
            'display_name_english', sub.display_name_english_ashkenazi,
            'tag_type', sub.tag_type,
            'is_negated', sub.is_negated,
            'is_modified', sub.is_modified,
            'source_is_negated', sub.source_is_negated
        ) ORDER BY sub.sort_order)
        FROM (
            -- Publisher-specific tags (if any exist, these take full precedence)
            SELECT t.id, t.tag_key, t.name, t.display_name_hebrew, t.display_name_english_ashkenazi,
                   tt.key AS tag_type, t.sort_order, pzt.is_negated,
                   -- Check if this tag is modified from master registry
                   CASE
                       WHEN mzt.tag_id IS NULL THEN true  -- Tag added by publisher (not in master)
                       WHEN pzt.is_negated != mzt.is_negated THEN true  -- Negation changed
                       ELSE false
                   END AS is_modified,
                   mzt.is_negated AS source_is_negated
            FROM publisher_zman_tags pzt
            JOIN zman_tags t ON pzt.tag_id = t.id
            JOIN tag_types tt ON t.tag_type_id = tt.id
            LEFT JOIN master_zman_tags mzt ON mzt.master_zman_id = pz.master_zman_id
                                            AND mzt.tag_id = pzt.tag_id
            WHERE pzt.publisher_zman_id = pz.id
            UNION ALL
            -- Master tags (only if NO publisher tags exist for this zman)
            SELECT t.id, t.tag_key, t.name, t.display_name_hebrew, t.display_name_english_ashkenazi,
                   tt.key AS tag_type, t.sort_order, mzt.is_negated,
                   false AS is_modified,  -- Not modified since using master tags
                   mzt.is_negated AS source_is_negated
            FROM master_zman_tags mzt
            JOIN zman_tags t ON mzt.tag_id = t.id
            JOIN tag_types tt ON t.tag_type_id = tt.id
            WHERE mzt.master_zman_id = pz.master_zman_id
              AND NOT EXISTS (SELECT 1 FROM publisher_zman_tags WHERE publisher_zman_id = pz.id)
        ) sub),
        '[]'::json
    ) AS tags,
    -- Linked source info
    CASE WHEN pz.linked_publisher_zman_id IS NOT NULL THEN true ELSE false END AS is_linked,
    linked_pub.name AS linked_source_publisher_name,
    CASE WHEN pz.linked_publisher_zman_id IS NOT NULL AND linked_pz.deleted_at IS NOT NULL
         THEN true ELSE false END AS linked_source_is_deleted,
    -- Time category key for ordering (from registry or current)
    COALESCE(mr_tc.key, tc.key, 'uncategorized') AS time_category
FROM publisher_zmanim pz
LEFT JOIN time_categories tc ON pz.time_category_id = tc.id
LEFT JOIN publisher_zmanim linked_pz ON pz.linked_publisher_zman_id = linked_pz.id
LEFT JOIN publishers linked_pub ON linked_pz.publisher_id = linked_pub.id
LEFT JOIN master_zmanim_registry mr ON pz.master_zman_id = mr.id
LEFT JOIN time_categories mr_tc ON mr.time_category_id = mr_tc.id
WHERE pz.publisher_id = $1
  AND pz.deleted_at IS NULL
ORDER BY
    COALESCE(mr_tc.sort_order, tc.sort_order, 99),
    pz.hebrew_name
`

type GetPublisherZmanimRow struct {
	ID                        int32              `json:"id"`
	PublisherID               int32              `json:"publisher_id"`
	ZmanKey                   string             `json:"zman_key"`
	HebrewName                string             `json:"hebrew_name"`
	EnglishName               string             `json:"english_name"`
	Transliteration           *string            `json:"transliteration"`
	Description               *string            `json:"description"`
	FormulaDsl                string             `json:"formula_dsl"`
	AiExplanation             *string            `json:"ai_explanation"`
	PublisherComment          *string            `json:"publisher_comment"`
	IsEnabled                 bool               `json:"is_enabled"`
	IsVisible                 bool               `json:"is_visible"`
	IsPublished               bool               `json:"is_published"`
	IsBeta                    bool               `json:"is_beta"`
	IsCustom                  bool               `json:"is_custom"`
	DisplayStatus             DisplayStatus      `json:"display_status"`
	Dependencies              []string           `json:"dependencies"`
	RoundingMode              string             `json:"rounding_mode"`
	CreatedAt                 pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                 pgtype.Timestamptz `json:"updated_at"`
	MasterZmanID              *int32             `json:"master_zman_id"`
	LinkedPublisherZmanID     *int32             `json:"linked_publisher_zman_id"`
	TimeCategoryID            *int32             `json:"time_category_id"`
	Category                  *string            `json:"category"`
	CategoryDisplayHebrew     *string            `json:"category_display_hebrew"`
	CategoryDisplayEnglish    *string            `json:"category_display_english"`
	SourceHebrewName          string             `json:"source_hebrew_name"`
	SourceEnglishName         string             `json:"source_english_name"`
	SourceTransliteration     *string            `json:"source_transliteration"`
	SourceDescription         *string            `json:"source_description"`
	SourceFormulaDsl          string             `json:"source_formula_dsl"`
	IsEventZman               bool               `json:"is_event_zman"`
	Tags                      interface{}        `json:"tags"`
	IsLinked                  bool               `json:"is_linked"`
	LinkedSourcePublisherName *string            `json:"linked_source_publisher_name"`
	LinkedSourceIsDeleted     bool               `json:"linked_source_is_deleted"`
	TimeCategory              string             `json:"time_category"`
}

// Zmanim SQL Queries
// SQLc will generate type-safe Go code from these queries
// Publisher Zmanim --
// Orders by time_category (chronological) then hebrew_name
func (q *Queries) GetPublisherZmanim(ctx context.Context, publisherID int32) ([]GetPublisherZmanimRow, error) {
	rows, err := q.db.Query(ctx, getPublisherZmanim, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherZmanimRow{}
	for rows.Next() {
		var i GetPublisherZmanimRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.Transliteration,
			&i.Description,
			&i.FormulaDsl,
			&i.AiExplanation,
			&i.PublisherComment,
			&i.IsEnabled,
			&i.IsVisible,
			&i.IsPublished,
			&i.IsBeta,
			&i.IsCustom,
			&i.DisplayStatus,
			&i.Dependencies,
			&i.RoundingMode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MasterZmanID,
			&i.LinkedPublisherZmanID,
			&i.TimeCategoryID,
			&i.Category,
			&i.CategoryDisplayHebrew,
			&i.CategoryDisplayEnglish,
			&i.SourceHebrewName,
			&i.SourceEnglishName,
			&i.SourceTransliteration,
			&i.SourceDescription,
			&i.SourceFormulaDsl,
			&i.IsEventZman,
			&i.Tags,
			&i.IsLinked,
			&i.LinkedSourcePublisherName,
			&i.LinkedSourceIsDeleted,
			&i.TimeCategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherZmanimForLinking = `-- name: GetPublisherZmanimForLinking :many
SELECT
    pz.id, pz.publisher_id, pz.zman_key, pz.hebrew_name, pz.english_name,
    pz.formula_dsl,
    pz.time_category_id,
    tc.key AS category,
    tc.display_name_hebrew AS category_display_hebrew,
    tc.display_name_english AS category_display_english,
    p.name AS publisher_name
FROM publisher_zmanim pz
JOIN publishers p ON p.id = pz.publisher_id
LEFT JOIN time_categories tc ON pz.time_category_id = tc.id
WHERE pz.publisher_id = $1
  AND pz.is_published = true
  AND pz.is_enabled = true
  AND pz.deleted_at IS NULL
  AND ($2::integer IS NULL OR pz.zman_key NOT IN (
      SELECT zman_key FROM publisher_zmanim WHERE publisher_id = $2 AND deleted_at IS NULL
  ))
ORDER BY
    COALESCE(tc.sort_order, 99),
    pz.hebrew_name
`

type GetPublisherZmanimForLinkingParams struct {
	PublisherID int32 `json:"publisher_id"`
	Column2     int32 `json:"column_2"`
}

type GetPublisherZmanimForLinkingRow struct {
	ID                     int32   `json:"id"`
	PublisherID            int32   `json:"publisher_id"`
	ZmanKey                string  `json:"zman_key"`
	HebrewName             string  `json:"hebrew_name"`
	EnglishName            string  `json:"english_name"`
	FormulaDsl             string  `json:"formula_dsl"`
	TimeCategoryID         *int32  `json:"time_category_id"`
	Category               *string `json:"category"`
	CategoryDisplayHebrew  *string `json:"category_display_hebrew"`
	CategoryDisplayEnglish *string `json:"category_display_english"`
	PublisherName          string  `json:"publisher_name"`
}

// Get published zmanim from a specific publisher for copying/linking
// Orders by category chronologically then hebrew_name
func (q *Queries) GetPublisherZmanimForLinking(ctx context.Context, arg GetPublisherZmanimForLinkingParams) ([]GetPublisherZmanimForLinkingRow, error) {
	rows, err := q.db.Query(ctx, getPublisherZmanimForLinking, arg.PublisherID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherZmanimForLinkingRow{}
	for rows.Next() {
		var i GetPublisherZmanimForLinkingRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.FormulaDsl,
			&i.TimeCategoryID,
			&i.Category,
			&i.CategoryDisplayHebrew,
			&i.CategoryDisplayEnglish,
			&i.PublisherName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherZmanimSettings = `-- name: GetPublisherZmanimSettings :many
SELECT zman_key, rounding_mode, is_beta
FROM publisher_zmanim
WHERE publisher_id = $1 AND deleted_at IS NULL
`

type GetPublisherZmanimSettingsRow struct {
	ZmanKey      string `json:"zman_key"`
	RoundingMode string `json:"rounding_mode"`
	IsBeta       bool   `json:"is_beta"`
}

// Get per-zman settings (rounding_mode, is_beta) for all zmanim for a publisher
// Used by public zmanim API to apply publisher settings when displaying times
func (q *Queries) GetPublisherZmanimSettings(ctx context.Context, publisherID int32) ([]GetPublisherZmanimSettingsRow, error) {
	rows, err := q.db.Query(ctx, getPublisherZmanimSettings, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherZmanimSettingsRow{}
	for rows.Next() {
		var i GetPublisherZmanimSettingsRow
		if err := rows.Scan(&i.ZmanKey, &i.RoundingMode, &i.IsBeta); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublishersUsingMasterZman = `-- name: GetPublishersUsingMasterZman :many
SELECT DISTINCT publisher_id
FROM publisher_zmanim
WHERE master_zman_id = $1
  AND deleted_at IS NULL
`

// Get all publisher IDs that have a zman referencing this master registry entry
// Used for cache invalidation when master zman formula changes
func (q *Queries) GetPublishersUsingMasterZman(ctx context.Context, masterZmanID *int32) ([]int32, error) {
	rows, err := q.db.Query(ctx, getPublishersUsingMasterZman, masterZmanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int32{}
	for rows.Next() {
		var publisher_id int32
		if err := rows.Scan(&publisher_id); err != nil {
			return nil, err
		}
		items = append(items, publisher_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSourceZmanForLinking = `-- name: GetSourceZmanForLinking :one
SELECT
    pz.id, pz.publisher_id, pz.zman_key, pz.hebrew_name, pz.english_name,
    pz.formula_dsl,
    tc.key AS category,
    pz.dependencies, pz.master_zman_id,
    p.is_verified
FROM publisher_zmanim pz
JOIN publishers p ON p.id = pz.publisher_id
LEFT JOIN time_categories tc ON pz.time_category_id = tc.id
WHERE pz.id = $1
  AND pz.is_published = true
  AND pz.is_enabled = true
  AND pz.deleted_at IS NULL
`

type GetSourceZmanForLinkingRow struct {
	ID           int32    `json:"id"`
	PublisherID  int32    `json:"publisher_id"`
	ZmanKey      string   `json:"zman_key"`
	HebrewName   string   `json:"hebrew_name"`
	EnglishName  string   `json:"english_name"`
	FormulaDsl   string   `json:"formula_dsl"`
	Category     *string  `json:"category"`
	Dependencies []string `json:"dependencies"`
	MasterZmanID *int32   `json:"master_zman_id"`
	IsVerified   bool     `json:"is_verified"`
}

// Get source zman for copying/linking with publisher verification
func (q *Queries) GetSourceZmanForLinking(ctx context.Context, id int32) (GetSourceZmanForLinkingRow, error) {
	row := q.db.QueryRow(ctx, getSourceZmanForLinking, id)
	var i GetSourceZmanForLinkingRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.FormulaDsl,
		&i.Category,
		&i.Dependencies,
		&i.MasterZmanID,
		&i.IsVerified,
	)
	return i, err
}

const getVerifiedPublishers = `-- name: GetVerifiedPublishers :many

SELECT
    p.id, p.name, p.logo_url,
    COUNT(pz.id) AS zmanim_count
FROM publishers p
JOIN publisher_zmanim pz ON pz.publisher_id = p.id
    AND pz.is_published = true
    AND pz.is_enabled = true
    AND pz.deleted_at IS NULL
WHERE p.is_verified = true
  AND p.status_id = (SELECT id FROM publisher_statuses WHERE key = 'active')
  AND p.id != $1
GROUP BY p.id, p.name, p.logo_url
HAVING COUNT(pz.id) > 0
ORDER BY p.name
`

type GetVerifiedPublishersRow struct {
	ID          int32   `json:"id"`
	Name        string  `json:"name"`
	LogoUrl     *string `json:"logo_url"`
	ZmanimCount int64   `json:"zmanim_count"`
}

// ============================================================================
// Queries for GetVerifiedPublishers
// ============================================================================
// Get verified publishers with zmanim count, excluding specified publisher
func (q *Queries) GetVerifiedPublishers(ctx context.Context, id int32) ([]GetVerifiedPublishersRow, error) {
	rows, err := q.db.Query(ctx, getVerifiedPublishers, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVerifiedPublishersRow{}
	for rows.Next() {
		var i GetVerifiedPublishersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.LogoUrl,
			&i.ZmanimCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVerifiedPublishersForLinking = `-- name: GetVerifiedPublishersForLinking :many

SELECT
    p.id, p.name, p.logo_url,
    COUNT(pz.id) AS zmanim_count
FROM publishers p
JOIN publisher_zmanim pz ON pz.publisher_id = p.id
    AND pz.is_published = true
    AND pz.is_enabled = true
    AND pz.deleted_at IS NULL
WHERE p.is_verified = true
  AND p.status_id = (SELECT id FROM publisher_statuses WHERE key = 'active')
  AND p.id != $1  -- Exclude self
GROUP BY p.id, p.name, p.logo_url
HAVING COUNT(pz.id) > 0
ORDER BY p.name
`

type GetVerifiedPublishersForLinkingRow struct {
	ID          int32   `json:"id"`
	Name        string  `json:"name"`
	LogoUrl     *string `json:"logo_url"`
	ZmanimCount int64   `json:"zmanim_count"`
}

// Linked Zmanim Support --
// Get verified publishers that current publisher can link to (excludes self)
func (q *Queries) GetVerifiedPublishersForLinking(ctx context.Context, id int32) ([]GetVerifiedPublishersForLinkingRow, error) {
	rows, err := q.db.Query(ctx, getVerifiedPublishersForLinking, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVerifiedPublishersForLinkingRow{}
	for rows.Next() {
		var i GetVerifiedPublishersForLinkingRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.LogoUrl,
			&i.ZmanimCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertPublisherZmanFromImport = `-- name: InsertPublisherZmanFromImport :exec
INSERT INTO publisher_zmanim (
    publisher_id,
    zman_key,
    hebrew_name,
    english_name,
    transliteration,
    description,
    formula_dsl,
    ai_explanation,
    publisher_comment,
    is_enabled,
    is_visible,
    is_published,
    is_beta,
    is_custom,
    master_zman_id,
    time_category_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15,
    -- Get time_category_id from master_zmanim_registry if master_zman_id is provided
    COALESCE(
        (SELECT time_category_id FROM master_zmanim_registry WHERE id = $15),
        (SELECT id FROM time_categories WHERE key = 'other')
    )
)
`

type InsertPublisherZmanFromImportParams struct {
	PublisherID      int32   `json:"publisher_id"`
	ZmanKey          string  `json:"zman_key"`
	HebrewName       string  `json:"hebrew_name"`
	EnglishName      string  `json:"english_name"`
	Transliteration  *string `json:"transliteration"`
	Description      *string `json:"description"`
	FormulaDsl       string  `json:"formula_dsl"`
	AiExplanation    *string `json:"ai_explanation"`
	PublisherComment *string `json:"publisher_comment"`
	IsEnabled        bool    `json:"is_enabled"`
	IsVisible        bool    `json:"is_visible"`
	IsPublished      bool    `json:"is_published"`
	IsBeta           bool    `json:"is_beta"`
	IsCustom         bool    `json:"is_custom"`
	MasterZmanID     *int32  `json:"master_zman_id"`
}

// Insert a new publisher zman from import data
func (q *Queries) InsertPublisherZmanFromImport(ctx context.Context, arg InsertPublisherZmanFromImportParams) error {
	_, err := q.db.Exec(ctx, insertPublisherZmanFromImport,
		arg.PublisherID,
		arg.ZmanKey,
		arg.HebrewName,
		arg.EnglishName,
		arg.Transliteration,
		arg.Description,
		arg.FormulaDsl,
		arg.AiExplanation,
		arg.PublisherComment,
		arg.IsEnabled,
		arg.IsVisible,
		arg.IsPublished,
		arg.IsBeta,
		arg.IsCustom,
		arg.MasterZmanID,
	)
	return err
}

const insertPublisherZmanTag = `-- name: InsertPublisherZmanTag :exec
INSERT INTO publisher_zman_tags (publisher_zman_id, tag_id, is_negated)
VALUES ($1, $2, $3)
ON CONFLICT (publisher_zman_id, tag_id) DO UPDATE SET is_negated = $3
`

type InsertPublisherZmanTagParams struct {
	PublisherZmanID int32 `json:"publisher_zman_id"`
	TagID           int32 `json:"tag_id"`
	IsNegated       bool  `json:"is_negated"`
}

// Insert a tag for a publisher zman with is_negated
func (q *Queries) InsertPublisherZmanTag(ctx context.Context, arg InsertPublisherZmanTagParams) error {
	_, err := q.db.Exec(ctx, insertPublisherZmanTag, arg.PublisherZmanID, arg.TagID, arg.IsNegated)
	return err
}

const publishAllZmanim = `-- name: PublishAllZmanim :exec

UPDATE publisher_zmanim
SET is_published = true, updated_at = NOW()
WHERE publisher_id = $1 AND is_enabled = true
`

// Bulk publish/unpublish zmanim --
func (q *Queries) PublishAllZmanim(ctx context.Context, publisherID int32) error {
	_, err := q.db.Exec(ctx, publishAllZmanim, publisherID)
	return err
}

const publishZmanimByKeys = `-- name: PublishZmanimByKeys :exec
UPDATE publisher_zmanim
SET is_published = true, updated_at = NOW()
WHERE publisher_id = $1 AND zman_key = ANY($2::text[])
`

type PublishZmanimByKeysParams struct {
	PublisherID int32    `json:"publisher_id"`
	Column2     []string `json:"column_2"`
}

func (q *Queries) PublishZmanimByKeys(ctx context.Context, arg PublishZmanimByKeysParams) error {
	_, err := q.db.Exec(ctx, publishZmanimByKeys, arg.PublisherID, arg.Column2)
	return err
}

const removeTagFromPublisherZman = `-- name: RemoveTagFromPublisherZman :exec
DELETE FROM publisher_zman_tags
WHERE publisher_zman_id = $1 AND tag_id = $2
`

type RemoveTagFromPublisherZmanParams struct {
	PublisherZmanID int32 `json:"publisher_zman_id"`
	TagID           int32 `json:"tag_id"`
}

// Remove a tag from a publisher zman
func (q *Queries) RemoveTagFromPublisherZman(ctx context.Context, arg RemoveTagFromPublisherZmanParams) error {
	_, err := q.db.Exec(ctx, removeTagFromPublisherZman, arg.PublisherZmanID, arg.TagID)
	return err
}

const setPublisherZmanTags = `-- name: SetPublisherZmanTags :exec
DELETE FROM publisher_zman_tags WHERE publisher_zman_id = $1
`

// Replace all tags for a publisher zman (delete existing, insert new)
// First delete all existing tags for the zman
func (q *Queries) SetPublisherZmanTags(ctx context.Context, publisherZmanID int32) error {
	_, err := q.db.Exec(ctx, setPublisherZmanTags, publisherZmanID)
	return err
}

const unpublishAllZmanim = `-- name: UnpublishAllZmanim :exec
UPDATE publisher_zmanim
SET is_published = false, updated_at = NOW()
WHERE publisher_id = $1
`

func (q *Queries) UnpublishAllZmanim(ctx context.Context, publisherID int32) error {
	_, err := q.db.Exec(ctx, unpublishAllZmanim, publisherID)
	return err
}

const unpublishZmanimByKeys = `-- name: UnpublishZmanimByKeys :exec
UPDATE publisher_zmanim
SET is_published = false, updated_at = NOW()
WHERE publisher_id = $1 AND zman_key = ANY($2::text[])
`

type UnpublishZmanimByKeysParams struct {
	PublisherID int32    `json:"publisher_id"`
	Column2     []string `json:"column_2"`
}

func (q *Queries) UnpublishZmanimByKeys(ctx context.Context, arg UnpublishZmanimByKeysParams) error {
	_, err := q.db.Exec(ctx, unpublishZmanimByKeys, arg.PublisherID, arg.Column2)
	return err
}

const updatePublisherZman = `-- name: UpdatePublisherZman :one
UPDATE publisher_zmanim
SET hebrew_name = COALESCE($3, hebrew_name),
    english_name = COALESCE($4, english_name),
    transliteration = COALESCE($5, transliteration),
    description = COALESCE($6, description),
    formula_dsl = COALESCE($7, formula_dsl),
    ai_explanation = COALESCE($8, ai_explanation),
    publisher_comment = COALESCE($9, publisher_comment),
    is_enabled = COALESCE($10, is_enabled),
    is_visible = COALESCE($11, is_visible),
    is_published = COALESCE($12, is_published),
    is_beta = COALESCE($13, is_beta),
    display_status = COALESCE($14::display_status, display_status),
    certified_at = CASE
        WHEN $13::boolean = false AND is_beta = true THEN NOW()
        ELSE certified_at
    END,
    time_category_id = COALESCE($15, time_category_id),
    dependencies = COALESCE($16, dependencies),
    rounding_mode = COALESCE($17, rounding_mode),
    updated_at = NOW()
WHERE publisher_id = $1 AND zman_key = $2
RETURNING id, publisher_id, zman_key, hebrew_name, english_name,
    transliteration, description, formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_beta, is_custom, display_status, time_category_id,
    dependencies, rounding_mode, created_at, updated_at
`

type UpdatePublisherZmanParams struct {
	PublisherID      int32             `json:"publisher_id"`
	ZmanKey          string            `json:"zman_key"`
	HebrewName       *string           `json:"hebrew_name"`
	EnglishName      *string           `json:"english_name"`
	Transliteration  *string           `json:"transliteration"`
	Description      *string           `json:"description"`
	FormulaDsl       *string           `json:"formula_dsl"`
	AiExplanation    *string           `json:"ai_explanation"`
	PublisherComment *string           `json:"publisher_comment"`
	IsEnabled        *bool             `json:"is_enabled"`
	IsVisible        *bool             `json:"is_visible"`
	IsPublished      *bool             `json:"is_published"`
	IsBeta           *bool             `json:"is_beta"`
	DisplayStatus    NullDisplayStatus `json:"display_status"`
	TimeCategoryID   *int32            `json:"time_category_id"`
	Dependencies     []string          `json:"dependencies"`
	RoundingMode     *string           `json:"rounding_mode"`
}

type UpdatePublisherZmanRow struct {
	ID               int32              `json:"id"`
	PublisherID      int32              `json:"publisher_id"`
	ZmanKey          string             `json:"zman_key"`
	HebrewName       string             `json:"hebrew_name"`
	EnglishName      string             `json:"english_name"`
	Transliteration  *string            `json:"transliteration"`
	Description      *string            `json:"description"`
	FormulaDsl       string             `json:"formula_dsl"`
	AiExplanation    *string            `json:"ai_explanation"`
	PublisherComment *string            `json:"publisher_comment"`
	IsEnabled        bool               `json:"is_enabled"`
	IsVisible        bool               `json:"is_visible"`
	IsPublished      bool               `json:"is_published"`
	IsBeta           bool               `json:"is_beta"`
	IsCustom         bool               `json:"is_custom"`
	DisplayStatus    DisplayStatus      `json:"display_status"`
	TimeCategoryID   *int32             `json:"time_category_id"`
	Dependencies     []string           `json:"dependencies"`
	RoundingMode     string             `json:"rounding_mode"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdatePublisherZman(ctx context.Context, arg UpdatePublisherZmanParams) (UpdatePublisherZmanRow, error) {
	row := q.db.QueryRow(ctx, updatePublisherZman,
		arg.PublisherID,
		arg.ZmanKey,
		arg.HebrewName,
		arg.EnglishName,
		arg.Transliteration,
		arg.Description,
		arg.FormulaDsl,
		arg.AiExplanation,
		arg.PublisherComment,
		arg.IsEnabled,
		arg.IsVisible,
		arg.IsPublished,
		arg.IsBeta,
		arg.DisplayStatus,
		arg.TimeCategoryID,
		arg.Dependencies,
		arg.RoundingMode,
	)
	var i UpdatePublisherZmanRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.Transliteration,
		&i.Description,
		&i.FormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsBeta,
		&i.IsCustom,
		&i.DisplayStatus,
		&i.TimeCategoryID,
		&i.Dependencies,
		&i.RoundingMode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePublisherZmanFromImport = `-- name: UpdatePublisherZmanFromImport :exec

UPDATE publisher_zmanim SET
    hebrew_name = $2,
    english_name = $3,
    transliteration = $4,
    description = $5,
    formula_dsl = $6,
    ai_explanation = $7,
    publisher_comment = $8,
    is_enabled = $9,
    is_visible = $10,
    is_published = $11,
    is_beta = $12,
    updated_at = NOW()
WHERE id = $1
`

type UpdatePublisherZmanFromImportParams struct {
	ID               int32   `json:"id"`
	HebrewName       string  `json:"hebrew_name"`
	EnglishName      string  `json:"english_name"`
	Transliteration  *string `json:"transliteration"`
	Description      *string `json:"description"`
	FormulaDsl       string  `json:"formula_dsl"`
	AiExplanation    *string `json:"ai_explanation"`
	PublisherComment *string `json:"publisher_comment"`
	IsEnabled        bool    `json:"is_enabled"`
	IsVisible        bool    `json:"is_visible"`
	IsPublished      bool    `json:"is_published"`
	IsBeta           bool    `json:"is_beta"`
}

// ============================================================================
// Import/Export Queries
// ============================================================================
// Update an existing publisher zman from import data
func (q *Queries) UpdatePublisherZmanFromImport(ctx context.Context, arg UpdatePublisherZmanFromImportParams) error {
	_, err := q.db.Exec(ctx, updatePublisherZmanFromImport,
		arg.ID,
		arg.HebrewName,
		arg.EnglishName,
		arg.Transliteration,
		arg.Description,
		arg.FormulaDsl,
		arg.AiExplanation,
		arg.PublisherComment,
		arg.IsEnabled,
		arg.IsVisible,
		arg.IsPublished,
		arg.IsBeta,
	)
	return err
}
