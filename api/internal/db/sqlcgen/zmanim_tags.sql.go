// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: zmanim_tags.sql

package sqlcgen

import (
	"context"
)

const checkIfEventZman = `-- name: CheckIfEventZman :one
SELECT EXISTS (
    SELECT 1 FROM (
        -- Check master zman tags
        SELECT tt.key, zt.tag_key
        FROM master_zman_tags mzt
        JOIN zman_tags zt ON mzt.tag_id = zt.id
        JOIN tag_types tt ON zt.tag_type_id = tt.id
        WHERE mzt.master_zman_id = (SELECT pz.master_zman_id FROM publisher_zmanim pz WHERE pz.id = $1)
        UNION ALL
        -- Check publisher-specific tags
        SELECT tt.key, zt.tag_key
        FROM publisher_zman_tags pzt
        JOIN zman_tags zt ON pzt.tag_id = zt.id
        JOIN tag_types tt ON zt.tag_type_id = tt.id
        WHERE pzt.publisher_zman_id = $1
    ) all_tags
    WHERE all_tags.key = 'event'
       OR all_tags.tag_key IN ('category_candle_lighting', 'category_havdalah', 'category_fast_start', 'category_fast_end')
) AS is_event
`

// Checks if a zman has event tags or special category tags (candle lighting, havdalah, fast start/end)
func (q *Queries) CheckIfEventZman(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRow(ctx, checkIfEventZman, id)
	var is_event bool
	err := row.Scan(&is_event)
	return is_event, err
}

const getZmanTags = `-- name: GetZmanTags :many

SELECT
    t.id,
    t.tag_key,
    t.name,
    t.display_name_hebrew,
    t.display_name_english_ashkenazi,
    tt.key AS tag_type,
    t.sort_order,
    COALESCE(pzt.is_negated, mzt.is_negated, false) AS is_negated,
    CASE
        WHEN mzt.tag_id IS NOT NULL THEN 'master'
        ELSE 'publisher'
    END AS tag_source,
    mzt.is_negated AS source_is_negated,
    CASE
        WHEN mzt.tag_id IS NOT NULL
          AND pzt.tag_id IS NOT NULL
          AND COALESCE(pzt.is_negated, false) != COALESCE(mzt.is_negated, false)
        THEN true
        ELSE false
    END AS is_modified
FROM (
    -- Master zman tags (if this zman is linked to master registry)
    SELECT mzt.tag_id, mzt.is_negated, 'master' AS source
    FROM master_zman_tags mzt
    WHERE mzt.master_zman_id = (
        SELECT pz.master_zman_id FROM publisher_zmanim pz WHERE pz.id = $1
    )
    UNION ALL
    -- Publisher-specific tags
    SELECT pzt.tag_id, pzt.is_negated, 'publisher' AS source
    FROM publisher_zman_tags pzt
    WHERE pzt.publisher_zman_id = $1
) tag_refs
JOIN zman_tags t ON tag_refs.tag_id = t.id
JOIN tag_types tt ON t.tag_type_id = tt.id
LEFT JOIN master_zman_tags mzt ON mzt.tag_id = t.id
    AND mzt.master_zman_id = (SELECT pz.master_zman_id FROM publisher_zmanim pz WHERE pz.id = $1)
LEFT JOIN publisher_zman_tags pzt ON pzt.tag_id = t.id AND pzt.publisher_zman_id = $1
ORDER BY t.sort_order
`

type GetZmanTagsRow struct {
	ID                          int32  `json:"id"`
	TagKey                      string `json:"tag_key"`
	Name                        string `json:"name"`
	DisplayNameHebrew           string `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string `json:"display_name_english_ashkenazi"`
	TagType                     string `json:"tag_type"`
	SortOrder                   *int32 `json:"sort_order"`
	IsNegated                   bool   `json:"is_negated"`
	TagSource                   string `json:"tag_source"`
	SourceIsNegated             *bool  `json:"source_is_negated"`
	IsModified                  bool   `json:"is_modified"`
}

// File: zmanim_tags.sql
// Purpose: Separate tag fetching queries (extracted from complex GetPublisherZmanim)
// Pattern: query-decomposition
// Complexity: low (single concept with lookup tables)
// Used by: publisher_zmanim.go handlers
// Fetches all tags for a specific publisher zman with source tracking
// Combines master zman tags (if linked to master registry) with publisher-specific tags
// Includes source_is_negated, is_modified, and tag_source for modification tracking
func (q *Queries) GetZmanTags(ctx context.Context, id int32) ([]GetZmanTagsRow, error) {
	rows, err := q.db.Query(ctx, getZmanTags, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetZmanTagsRow{}
	for rows.Next() {
		var i GetZmanTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.TagKey,
			&i.Name,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglishAshkenazi,
			&i.TagType,
			&i.SortOrder,
			&i.IsNegated,
			&i.TagSource,
			&i.SourceIsNegated,
			&i.IsModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revertPublisherZmanTags = `-- name: RevertPublisherZmanTags :exec
DELETE FROM publisher_zman_tags
WHERE publisher_zman_id = $1
`

// Reverts all publisher zman tags to match master registry state
// Deletes all publisher-specific tags and resets to master defaults
func (q *Queries) RevertPublisherZmanTags(ctx context.Context, publisherZmanID int32) error {
	_, err := q.db.Exec(ctx, revertPublisherZmanTags, publisherZmanID)
	return err
}
