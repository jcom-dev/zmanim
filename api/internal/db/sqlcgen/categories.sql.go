// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: categories.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAllDisplayGroups = `-- name: GetAllDisplayGroups :many

SELECT id, key, display_name_hebrew, display_name_english,
       description, icon_name, color, sort_order, time_categories, created_at
FROM display_groups
ORDER BY sort_order
`

// ============================================================================
// DISPLAY GROUPS
// ============================================================================
// Get all display groups ordered by sort_order
func (q *Queries) GetAllDisplayGroups(ctx context.Context) ([]DisplayGroup, error) {
	rows, err := q.db.Query(ctx, getAllDisplayGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DisplayGroup{}
	for rows.Next() {
		var i DisplayGroup
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglish,
			&i.Description,
			&i.IconName,
			&i.Color,
			&i.SortOrder,
			&i.TimeCategories,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTagTypes = `-- name: GetAllTagTypes :many

SELECT id, key, display_name_hebrew, display_name_english,
       color, sort_order, created_at
FROM tag_types
ORDER BY sort_order
`

type GetAllTagTypesRow struct {
	ID                 int32              `json:"id"`
	Key                string             `json:"key"`
	DisplayNameHebrew  string             `json:"display_name_hebrew"`
	DisplayNameEnglish string             `json:"display_name_english"`
	Color              *string            `json:"color"`
	SortOrder          int32              `json:"sort_order"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
}

// ============================================================================
// TAG TYPES
// ============================================================================
// Get all tag types ordered by sort_order
func (q *Queries) GetAllTagTypes(ctx context.Context) ([]GetAllTagTypesRow, error) {
	rows, err := q.db.Query(ctx, getAllTagTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllTagTypesRow{}
	for rows.Next() {
		var i GetAllTagTypesRow
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglish,
			&i.Color,
			&i.SortOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTimeCategories = `-- name: GetAllTimeCategories :many


SELECT id, key, display_name_hebrew, display_name_english,
       description, icon_name, color, sort_order, is_everyday, created_at
FROM time_categories
ORDER BY sort_order
`

// Queries for time_categories and tag_types tables
// ============================================================================
// TIME CATEGORIES
// ============================================================================
// Get all time categories ordered by sort_order
func (q *Queries) GetAllTimeCategories(ctx context.Context) ([]TimeCategory, error) {
	rows, err := q.db.Query(ctx, getAllTimeCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TimeCategory{}
	for rows.Next() {
		var i TimeCategory
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglish,
			&i.Description,
			&i.IconName,
			&i.Color,
			&i.SortOrder,
			&i.IsEveryday,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDisplayGroupByID = `-- name: GetDisplayGroupByID :one
SELECT id, key, display_name_hebrew, display_name_english,
       description, icon_name, color, sort_order, time_categories, created_at
FROM display_groups
WHERE id = $1
`

// Get a display group by its ID
func (q *Queries) GetDisplayGroupByID(ctx context.Context, id int32) (DisplayGroup, error) {
	row := q.db.QueryRow(ctx, getDisplayGroupByID, id)
	var i DisplayGroup
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.DisplayNameHebrew,
		&i.DisplayNameEnglish,
		&i.Description,
		&i.IconName,
		&i.Color,
		&i.SortOrder,
		&i.TimeCategories,
		&i.CreatedAt,
	)
	return i, err
}

const getDisplayGroupByKey = `-- name: GetDisplayGroupByKey :one
SELECT id, key, display_name_hebrew, display_name_english,
       description, icon_name, color, sort_order, time_categories, created_at
FROM display_groups
WHERE key = $1
`

// Get a display group by its key
func (q *Queries) GetDisplayGroupByKey(ctx context.Context, key string) (DisplayGroup, error) {
	row := q.db.QueryRow(ctx, getDisplayGroupByKey, key)
	var i DisplayGroup
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.DisplayNameHebrew,
		&i.DisplayNameEnglish,
		&i.Description,
		&i.IconName,
		&i.Color,
		&i.SortOrder,
		&i.TimeCategories,
		&i.CreatedAt,
	)
	return i, err
}

const getTagTypeByID = `-- name: GetTagTypeByID :one

SELECT id, key, display_name_hebrew, display_name_english,
       color, sort_order, created_at
FROM tag_types
WHERE id = $1
`

type GetTagTypeByIDRow struct {
	ID                 int32              `json:"id"`
	Key                string             `json:"key"`
	DisplayNameHebrew  string             `json:"display_name_hebrew"`
	DisplayNameEnglish string             `json:"display_name_english"`
	Color              *string            `json:"color"`
	SortOrder          int32              `json:"sort_order"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
}

// Removed: Duplicate of GetTagTypeByKey in lookups.sql
// Get a tag type by its ID
func (q *Queries) GetTagTypeByID(ctx context.Context, id int32) (GetTagTypeByIDRow, error) {
	row := q.db.QueryRow(ctx, getTagTypeByID, id)
	var i GetTagTypeByIDRow
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.DisplayNameHebrew,
		&i.DisplayNameEnglish,
		&i.Color,
		&i.SortOrder,
		&i.CreatedAt,
	)
	return i, err
}

const getTimeCategoryByID = `-- name: GetTimeCategoryByID :one
SELECT id, key, display_name_hebrew, display_name_english,
       description, icon_name, color, sort_order, is_everyday, created_at
FROM time_categories
WHERE id = $1
`

// Get a time category by its ID
func (q *Queries) GetTimeCategoryByID(ctx context.Context, id int32) (TimeCategory, error) {
	row := q.db.QueryRow(ctx, getTimeCategoryByID, id)
	var i TimeCategory
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.DisplayNameHebrew,
		&i.DisplayNameEnglish,
		&i.Description,
		&i.IconName,
		&i.Color,
		&i.SortOrder,
		&i.IsEveryday,
		&i.CreatedAt,
	)
	return i, err
}

const getTimeCategoryByKey = `-- name: GetTimeCategoryByKey :one
SELECT id, key, display_name_hebrew, display_name_english,
       description, icon_name, color, sort_order, is_everyday, created_at
FROM time_categories
WHERE key = $1
`

// Get a time category by its key
func (q *Queries) GetTimeCategoryByKey(ctx context.Context, key string) (TimeCategory, error) {
	row := q.db.QueryRow(ctx, getTimeCategoryByKey, key)
	var i TimeCategory
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.DisplayNameHebrew,
		&i.DisplayNameEnglish,
		&i.Description,
		&i.IconName,
		&i.Color,
		&i.SortOrder,
		&i.IsEveryday,
		&i.CreatedAt,
	)
	return i, err
}
