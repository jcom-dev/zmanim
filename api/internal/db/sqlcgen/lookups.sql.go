// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: lookups.sql

package sqlcgen

import (
	"context"
)

const getAlgorithmStatusByID = `-- name: GetAlgorithmStatusByID :one
SELECT id, key, display_name_hebrew, display_name_english, description, color
FROM algorithm_statuses
WHERE id = $1
`

type GetAlgorithmStatusByIDRow struct {
	ID                 int16   `json:"id"`
	Key                string  `json:"key"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	Description        *string `json:"description"`
	Color              *string `json:"color"`
}

func (q *Queries) GetAlgorithmStatusByID(ctx context.Context, id int16) (GetAlgorithmStatusByIDRow, error) {
	row := q.db.QueryRow(ctx, getAlgorithmStatusByID, id)
	var i GetAlgorithmStatusByIDRow
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.DisplayNameHebrew,
		&i.DisplayNameEnglish,
		&i.Description,
		&i.Color,
	)
	return i, err
}

const getAlgorithmStatusByKey = `-- name: GetAlgorithmStatusByKey :one
SELECT id, key, display_name_hebrew, display_name_english, description, color
FROM algorithm_statuses
WHERE key = $1
`

type GetAlgorithmStatusByKeyRow struct {
	ID                 int16   `json:"id"`
	Key                string  `json:"key"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	Description        *string `json:"description"`
	Color              *string `json:"color"`
}

func (q *Queries) GetAlgorithmStatusByKey(ctx context.Context, key string) (GetAlgorithmStatusByKeyRow, error) {
	row := q.db.QueryRow(ctx, getAlgorithmStatusByKey, key)
	var i GetAlgorithmStatusByKeyRow
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.DisplayNameHebrew,
		&i.DisplayNameEnglish,
		&i.Description,
		&i.Color,
	)
	return i, err
}

const getAlgorithmStatuses = `-- name: GetAlgorithmStatuses :many

SELECT id, key, display_name_hebrew, display_name_english, description, color, sort_order
FROM algorithm_statuses
ORDER BY sort_order
`

type GetAlgorithmStatusesRow struct {
	ID                 int16   `json:"id"`
	Key                string  `json:"key"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	Description        *string `json:"description"`
	Color              *string `json:"color"`
	SortOrder          int16   `json:"sort_order"`
}

// Algorithm Statuses --
func (q *Queries) GetAlgorithmStatuses(ctx context.Context) ([]GetAlgorithmStatusesRow, error) {
	rows, err := q.db.Query(ctx, getAlgorithmStatuses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAlgorithmStatusesRow{}
	for rows.Next() {
		var i GetAlgorithmStatusesRow
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglish,
			&i.Description,
			&i.Color,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContinentByCode = `-- name: GetContinentByCode :one

SELECT id, code, name
FROM geo_continents
WHERE code = $1
`

type GetContinentByCodeRow struct {
	ID   int16  `json:"id"`
	Code string `json:"code"`
	Name string `json:"name"`
}

// Geo Lookups --
func (q *Queries) GetContinentByCode(ctx context.Context, code string) (GetContinentByCodeRow, error) {
	row := q.db.QueryRow(ctx, getContinentByCode, code)
	var i GetContinentByCodeRow
	err := row.Scan(&i.ID, &i.Code, &i.Name)
	return i, err
}

const getCountryByCodeOrID = `-- name: GetCountryByCodeOrID :one
SELECT id, code, name
FROM geo_countries
WHERE code = $1 OR id::text = $1
`

type GetCountryByCodeOrIDRow struct {
	ID   int16  `json:"id"`
	Code string `json:"code"`
	Name string `json:"name"`
}

func (q *Queries) GetCountryByCodeOrID(ctx context.Context, code string) (GetCountryByCodeOrIDRow, error) {
	row := q.db.QueryRow(ctx, getCountryByCodeOrID, code)
	var i GetCountryByCodeOrIDRow
	err := row.Scan(&i.ID, &i.Code, &i.Name)
	return i, err
}

const getCoverageLevelByID = `-- name: GetCoverageLevelByID :one
SELECT id, key, display_name_hebrew, display_name_english, description
FROM coverage_levels
WHERE id = $1
`

type GetCoverageLevelByIDRow struct {
	ID                 int16   `json:"id"`
	Key                string  `json:"key"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	Description        *string `json:"description"`
}

func (q *Queries) GetCoverageLevelByID(ctx context.Context, id int16) (GetCoverageLevelByIDRow, error) {
	row := q.db.QueryRow(ctx, getCoverageLevelByID, id)
	var i GetCoverageLevelByIDRow
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.DisplayNameHebrew,
		&i.DisplayNameEnglish,
		&i.Description,
	)
	return i, err
}

const getCoverageLevelByKey = `-- name: GetCoverageLevelByKey :one
SELECT id, key, display_name_hebrew, display_name_english, description
FROM coverage_levels
WHERE key = $1
`

type GetCoverageLevelByKeyRow struct {
	ID                 int16   `json:"id"`
	Key                string  `json:"key"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	Description        *string `json:"description"`
}

func (q *Queries) GetCoverageLevelByKey(ctx context.Context, key string) (GetCoverageLevelByKeyRow, error) {
	row := q.db.QueryRow(ctx, getCoverageLevelByKey, key)
	var i GetCoverageLevelByKeyRow
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.DisplayNameHebrew,
		&i.DisplayNameEnglish,
		&i.Description,
	)
	return i, err
}

const getCoverageLevels = `-- name: GetCoverageLevels :many

SELECT id, key, display_name_hebrew, display_name_english, description, sort_order
FROM coverage_levels
ORDER BY sort_order
`

type GetCoverageLevelsRow struct {
	ID                 int16   `json:"id"`
	Key                string  `json:"key"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	Description        *string `json:"description"`
	SortOrder          int16   `json:"sort_order"`
}

// Coverage Levels --
func (q *Queries) GetCoverageLevels(ctx context.Context) ([]GetCoverageLevelsRow, error) {
	rows, err := q.db.Query(ctx, getCoverageLevels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCoverageLevelsRow{}
	for rows.Next() {
		var i GetCoverageLevelsRow
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglish,
			&i.Description,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherRoleByID = `-- name: GetPublisherRoleByID :one
SELECT id, key, display_name_hebrew, display_name_english, description, permissions
FROM publisher_roles
WHERE id = $1
`

type GetPublisherRoleByIDRow struct {
	ID                 int16   `json:"id"`
	Key                string  `json:"key"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	Description        *string `json:"description"`
	Permissions        []byte  `json:"permissions"`
}

func (q *Queries) GetPublisherRoleByID(ctx context.Context, id int16) (GetPublisherRoleByIDRow, error) {
	row := q.db.QueryRow(ctx, getPublisherRoleByID, id)
	var i GetPublisherRoleByIDRow
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.DisplayNameHebrew,
		&i.DisplayNameEnglish,
		&i.Description,
		&i.Permissions,
	)
	return i, err
}

const getPublisherRoleByKey = `-- name: GetPublisherRoleByKey :one
SELECT id, key, display_name_hebrew, display_name_english, description, permissions
FROM publisher_roles
WHERE key = $1
`

type GetPublisherRoleByKeyRow struct {
	ID                 int16   `json:"id"`
	Key                string  `json:"key"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	Description        *string `json:"description"`
	Permissions        []byte  `json:"permissions"`
}

func (q *Queries) GetPublisherRoleByKey(ctx context.Context, key string) (GetPublisherRoleByKeyRow, error) {
	row := q.db.QueryRow(ctx, getPublisherRoleByKey, key)
	var i GetPublisherRoleByKeyRow
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.DisplayNameHebrew,
		&i.DisplayNameEnglish,
		&i.Description,
		&i.Permissions,
	)
	return i, err
}

const getPublisherRoles = `-- name: GetPublisherRoles :many

SELECT id, key, display_name_hebrew, display_name_english, description, sort_order
FROM publisher_roles
ORDER BY sort_order
`

type GetPublisherRolesRow struct {
	ID                 int16   `json:"id"`
	Key                string  `json:"key"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	Description        *string `json:"description"`
	SortOrder          int16   `json:"sort_order"`
}

// Publisher Roles --
func (q *Queries) GetPublisherRoles(ctx context.Context) ([]GetPublisherRolesRow, error) {
	rows, err := q.db.Query(ctx, getPublisherRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherRolesRow{}
	for rows.Next() {
		var i GetPublisherRolesRow
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglish,
			&i.Description,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherStatusByID = `-- name: GetPublisherStatusByID :one
SELECT id, key, display_name_hebrew, display_name_english, description, color
FROM publisher_statuses
WHERE id = $1
`

type GetPublisherStatusByIDRow struct {
	ID                 int16   `json:"id"`
	Key                string  `json:"key"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	Description        *string `json:"description"`
	Color              *string `json:"color"`
}

func (q *Queries) GetPublisherStatusByID(ctx context.Context, id int16) (GetPublisherStatusByIDRow, error) {
	row := q.db.QueryRow(ctx, getPublisherStatusByID, id)
	var i GetPublisherStatusByIDRow
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.DisplayNameHebrew,
		&i.DisplayNameEnglish,
		&i.Description,
		&i.Color,
	)
	return i, err
}

const getPublisherStatusByKey = `-- name: GetPublisherStatusByKey :one
SELECT id, key, display_name_hebrew, display_name_english, description, color
FROM publisher_statuses
WHERE key = $1
`

type GetPublisherStatusByKeyRow struct {
	ID                 int16   `json:"id"`
	Key                string  `json:"key"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	Description        *string `json:"description"`
	Color              *string `json:"color"`
}

func (q *Queries) GetPublisherStatusByKey(ctx context.Context, key string) (GetPublisherStatusByKeyRow, error) {
	row := q.db.QueryRow(ctx, getPublisherStatusByKey, key)
	var i GetPublisherStatusByKeyRow
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.DisplayNameHebrew,
		&i.DisplayNameEnglish,
		&i.Description,
		&i.Color,
	)
	return i, err
}

const getPublisherStatuses = `-- name: GetPublisherStatuses :many


SELECT id, key, display_name_hebrew, display_name_english, description, color, sort_order
FROM publisher_statuses
WHERE is_active = true
ORDER BY sort_order
`

type GetPublisherStatusesRow struct {
	ID                 int16   `json:"id"`
	Key                string  `json:"key"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	Description        *string `json:"description"`
	Color              *string `json:"color"`
	SortOrder          int16   `json:"sort_order"`
}

// Lookup Tables SQL Queries
// Provides access to all lookup/reference tables for frontend dropdowns and validation
// Publisher Statuses --
func (q *Queries) GetPublisherStatuses(ctx context.Context) ([]GetPublisherStatusesRow, error) {
	rows, err := q.db.Query(ctx, getPublisherStatuses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherStatusesRow{}
	for rows.Next() {
		var i GetPublisherStatusesRow
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglish,
			&i.Description,
			&i.Color,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestStatusByKey = `-- name: GetRequestStatusByKey :one
SELECT id, key, display_name_hebrew, display_name_english, description, color
FROM request_statuses
WHERE key = $1
`

type GetRequestStatusByKeyRow struct {
	ID                 int16   `json:"id"`
	Key                string  `json:"key"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	Description        *string `json:"description"`
	Color              *string `json:"color"`
}

func (q *Queries) GetRequestStatusByKey(ctx context.Context, key string) (GetRequestStatusByKeyRow, error) {
	row := q.db.QueryRow(ctx, getRequestStatusByKey, key)
	var i GetRequestStatusByKeyRow
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.DisplayNameHebrew,
		&i.DisplayNameEnglish,
		&i.Description,
		&i.Color,
	)
	return i, err
}

const getRequestStatuses = `-- name: GetRequestStatuses :many

SELECT id, key, display_name_hebrew, display_name_english, description, color, sort_order
FROM request_statuses
ORDER BY sort_order
`

type GetRequestStatusesRow struct {
	ID                 int16   `json:"id"`
	Key                string  `json:"key"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	Description        *string `json:"description"`
	Color              *string `json:"color"`
	SortOrder          int16   `json:"sort_order"`
}

// Request Statuses --
func (q *Queries) GetRequestStatuses(ctx context.Context) ([]GetRequestStatusesRow, error) {
	rows, err := q.db.Query(ctx, getRequestStatuses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRequestStatusesRow{}
	for rows.Next() {
		var i GetRequestStatusesRow
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglish,
			&i.Description,
			&i.Color,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagTypeByKey = `-- name: GetTagTypeByKey :one
SELECT id, key, display_name_hebrew, display_name_english, description, color
FROM tag_types
WHERE key = $1
`

type GetTagTypeByKeyRow struct {
	ID                 int32   `json:"id"`
	Key                string  `json:"key"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	Description        *string `json:"description"`
	Color              *string `json:"color"`
}

func (q *Queries) GetTagTypeByKey(ctx context.Context, key string) (GetTagTypeByKeyRow, error) {
	row := q.db.QueryRow(ctx, getTagTypeByKey, key)
	var i GetTagTypeByKeyRow
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.DisplayNameHebrew,
		&i.DisplayNameEnglish,
		&i.Description,
		&i.Color,
	)
	return i, err
}

const getTagTypes = `-- name: GetTagTypes :many

SELECT id, key, display_name_hebrew, display_name_english, description, color, sort_order
FROM tag_types
ORDER BY sort_order
`

type GetTagTypesRow struct {
	ID                 int32   `json:"id"`
	Key                string  `json:"key"`
	DisplayNameHebrew  string  `json:"display_name_hebrew"`
	DisplayNameEnglish string  `json:"display_name_english"`
	Description        *string `json:"description"`
	Color              *string `json:"color"`
	SortOrder          int32   `json:"sort_order"`
}

// Tag Types --
func (q *Queries) GetTagTypes(ctx context.Context) ([]GetTagTypesRow, error) {
	rows, err := q.db.Query(ctx, getTagTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTagTypesRow{}
	for rows.Next() {
		var i GetTagTypesRow
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglish,
			&i.Description,
			&i.Color,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
