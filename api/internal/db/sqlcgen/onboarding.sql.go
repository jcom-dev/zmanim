// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: onboarding.sql

package sqlcgen

import (
	"context"
)

const deleteAllPublisherCoverage = `-- name: DeleteAllPublisherCoverage :exec
DELETE FROM publisher_coverage WHERE publisher_id = $1
`

func (q *Queries) DeleteAllPublisherCoverage(ctx context.Context, publisherID int32) error {
	_, err := q.db.Exec(ctx, deleteAllPublisherCoverage, publisherID)
	return err
}

const deleteAllPublisherZmanim = `-- name: DeleteAllPublisherZmanim :exec

DELETE FROM publisher_zmanim WHERE publisher_id = $1
`

// Cleanup Operations --
func (q *Queries) DeleteAllPublisherZmanim(ctx context.Context, publisherID int32) error {
	_, err := q.db.Exec(ctx, deleteAllPublisherZmanim, publisherID)
	return err
}

const upsertPublisherZmanLegacy = `-- name: UpsertPublisherZmanLegacy :exec
INSERT INTO publisher_zmanim (
    publisher_id, zman_key, hebrew_name, english_name, formula_dsl,
    is_enabled, is_visible, is_published, is_custom, time_category_id
) VALUES ($1, $2, $3, $4, $5, true, true, false, false, $6)
ON CONFLICT (publisher_id, zman_key) DO UPDATE SET
    hebrew_name = EXCLUDED.hebrew_name,
    english_name = EXCLUDED.english_name,
    formula_dsl = EXCLUDED.formula_dsl,
    is_enabled = EXCLUDED.is_enabled,
    time_category_id = EXCLUDED.time_category_id,
    updated_at = NOW()
`

type UpsertPublisherZmanLegacyParams struct {
	PublisherID    int32  `json:"publisher_id"`
	ZmanKey        string `json:"zman_key"`
	HebrewName     string `json:"hebrew_name"`
	EnglishName    string `json:"english_name"`
	FormulaDsl     string `json:"formula_dsl"`
	TimeCategoryID *int32 `json:"time_category_id"`
}

func (q *Queries) UpsertPublisherZmanLegacy(ctx context.Context, arg UpsertPublisherZmanLegacyParams) error {
	_, err := q.db.Exec(ctx, upsertPublisherZmanLegacy,
		arg.PublisherID,
		arg.ZmanKey,
		arg.HebrewName,
		arg.EnglishName,
		arg.FormulaDsl,
		arg.TimeCategoryID,
	)
	return err
}

const upsertPublisherZmanWithMaster = `-- name: UpsertPublisherZmanWithMaster :exec


INSERT INTO publisher_zmanim (
    publisher_id, zman_key, hebrew_name, english_name, formula_dsl,
    is_enabled, is_visible, is_published, is_custom, time_category_id,
    master_zman_id
) VALUES ($1, $2, $3, $4, $5, true, true, false, false, $6, $7)
ON CONFLICT (publisher_id, zman_key) DO UPDATE SET
    hebrew_name = EXCLUDED.hebrew_name,
    english_name = EXCLUDED.english_name,
    formula_dsl = EXCLUDED.formula_dsl,
    is_enabled = EXCLUDED.is_enabled,
    time_category_id = EXCLUDED.time_category_id,
    master_zman_id = EXCLUDED.master_zman_id,
    updated_at = NOW()
`

type UpsertPublisherZmanWithMasterParams struct {
	PublisherID    int32  `json:"publisher_id"`
	ZmanKey        string `json:"zman_key"`
	HebrewName     string `json:"hebrew_name"`
	EnglishName    string `json:"english_name"`
	FormulaDsl     string `json:"formula_dsl"`
	TimeCategoryID *int32 `json:"time_category_id"`
	MasterZmanID   *int32 `json:"master_zman_id"`
}

// Onboarding SQL Queries
// Wizard trigger simplified: shows when zmanim count = 0
// Publisher Zmanim Upserts for Wizard --
func (q *Queries) UpsertPublisherZmanWithMaster(ctx context.Context, arg UpsertPublisherZmanWithMasterParams) error {
	_, err := q.db.Exec(ctx, upsertPublisherZmanWithMaster,
		arg.PublisherID,
		arg.ZmanKey,
		arg.HebrewName,
		arg.EnglishName,
		arg.FormulaDsl,
		arg.TimeCategoryID,
		arg.MasterZmanID,
	)
	return err
}
