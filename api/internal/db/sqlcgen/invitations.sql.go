// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: invitations.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cancelInvitation = `-- name: CancelInvitation :exec
UPDATE publisher_invitations
SET status = 'cancelled',
    updated_at = NOW()
WHERE id = $1
  AND publisher_id = $2
  AND status = 'pending'
`

type CancelInvitationParams struct {
	ID          int32 `json:"id"`
	PublisherID int32 `json:"publisher_id"`
}

func (q *Queries) CancelInvitation(ctx context.Context, arg CancelInvitationParams) error {
	_, err := q.db.Exec(ctx, cancelInvitation, arg.ID, arg.PublisherID)
	return err
}

const countRecentInvitationsByPublisher = `-- name: CountRecentInvitationsByPublisher :one
SELECT COUNT(*) FROM publisher_invitations
WHERE publisher_id = $1
  AND created_at > $2
`

type CountRecentInvitationsByPublisherParams struct {
	PublisherID int32              `json:"publisher_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CountRecentInvitationsByPublisher(ctx context.Context, arg CountRecentInvitationsByPublisherParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRecentInvitationsByPublisher, arg.PublisherID, arg.CreatedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInvitationWithStatus = `-- name: CreateInvitationWithStatus :one

INSERT INTO publisher_invitations (
    publisher_id,
    email,
    token,
    role_id,
    invited_by,
    expires_at,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, 'pending'
)
RETURNING id, publisher_id, email, role_id, token, expires_at, created_at, invited_by, status, accepted_at, updated_at
`

type CreateInvitationWithStatusParams struct {
	PublisherID int32              `json:"publisher_id"`
	Email       string             `json:"email"`
	Token       string             `json:"token"`
	RoleID      int16              `json:"role_id"`
	InvitedBy   string             `json:"invited_by"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
}

// Additional invitation queries for secure user invitation flow
// Story: 8.31 - Secure User Invitation Flow with Email Verification
// Note: Core queries exist in admin.sql and publishers.sql
func (q *Queries) CreateInvitationWithStatus(ctx context.Context, arg CreateInvitationWithStatusParams) (PublisherInvitation, error) {
	row := q.db.QueryRow(ctx, createInvitationWithStatus,
		arg.PublisherID,
		arg.Email,
		arg.Token,
		arg.RoleID,
		arg.InvitedBy,
		arg.ExpiresAt,
	)
	var i PublisherInvitation
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.Email,
		&i.RoleID,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.InvitedBy,
		&i.Status,
		&i.AcceptedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const expireOldInvitations = `-- name: ExpireOldInvitations :exec
UPDATE publisher_invitations
SET status = 'expired',
    updated_at = NOW()
WHERE status = 'pending'
  AND expires_at < NOW()
`

func (q *Queries) ExpireOldInvitations(ctx context.Context) error {
	_, err := q.db.Exec(ctx, expireOldInvitations)
	return err
}

const getInvitationByIDWithStatus = `-- name: GetInvitationByIDWithStatus :one
SELECT pi.id, pi.publisher_id, pi.email, pi.role_id, pi.token, pi.expires_at, pi.created_at, pi.invited_by, pi.status, pi.accepted_at, pi.updated_at, pr.key as role_key
FROM publisher_invitations pi
JOIN publisher_roles pr ON pr.id = pi.role_id
WHERE pi.id = $1
`

type GetInvitationByIDWithStatusRow struct {
	ID          int32              `json:"id"`
	PublisherID int32              `json:"publisher_id"`
	Email       string             `json:"email"`
	RoleID      int16              `json:"role_id"`
	Token       string             `json:"token"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	InvitedBy   string             `json:"invited_by"`
	Status      *string            `json:"status"`
	AcceptedAt  pgtype.Timestamptz `json:"accepted_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	RoleKey     string             `json:"role_key"`
}

func (q *Queries) GetInvitationByIDWithStatus(ctx context.Context, id int32) (GetInvitationByIDWithStatusRow, error) {
	row := q.db.QueryRow(ctx, getInvitationByIDWithStatus, id)
	var i GetInvitationByIDWithStatusRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.Email,
		&i.RoleID,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.InvitedBy,
		&i.Status,
		&i.AcceptedAt,
		&i.UpdatedAt,
		&i.RoleKey,
	)
	return i, err
}

const getInvitationByPublisherAndEmail = `-- name: GetInvitationByPublisherAndEmail :one
SELECT pi.id, pi.publisher_id, pi.email, pi.role_id, pi.token, pi.expires_at, pi.created_at, pi.invited_by, pi.status, pi.accepted_at, pi.updated_at, pr.key as role_key
FROM publisher_invitations pi
JOIN publisher_roles pr ON pr.id = pi.role_id
WHERE pi.publisher_id = $1
  AND pi.email = $2
ORDER BY pi.created_at DESC
LIMIT 1
`

type GetInvitationByPublisherAndEmailParams struct {
	PublisherID int32  `json:"publisher_id"`
	Email       string `json:"email"`
}

type GetInvitationByPublisherAndEmailRow struct {
	ID          int32              `json:"id"`
	PublisherID int32              `json:"publisher_id"`
	Email       string             `json:"email"`
	RoleID      int16              `json:"role_id"`
	Token       string             `json:"token"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	InvitedBy   string             `json:"invited_by"`
	Status      *string            `json:"status"`
	AcceptedAt  pgtype.Timestamptz `json:"accepted_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	RoleKey     string             `json:"role_key"`
}

func (q *Queries) GetInvitationByPublisherAndEmail(ctx context.Context, arg GetInvitationByPublisherAndEmailParams) (GetInvitationByPublisherAndEmailRow, error) {
	row := q.db.QueryRow(ctx, getInvitationByPublisherAndEmail, arg.PublisherID, arg.Email)
	var i GetInvitationByPublisherAndEmailRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.Email,
		&i.RoleID,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.InvitedBy,
		&i.Status,
		&i.AcceptedAt,
		&i.UpdatedAt,
		&i.RoleKey,
	)
	return i, err
}

const listAllInvitationsByPublisher = `-- name: ListAllInvitationsByPublisher :many
SELECT pi.id, pi.publisher_id, pi.email, pi.role_id, pi.token, pi.expires_at, pi.created_at, pi.invited_by, pi.status, pi.accepted_at, pi.updated_at, pr.key as role_key,
       pr.display_name_english as role_display_english
FROM publisher_invitations pi
JOIN publisher_roles pr ON pr.id = pi.role_id
WHERE pi.publisher_id = $1
ORDER BY pi.created_at DESC
`

type ListAllInvitationsByPublisherRow struct {
	ID                 int32              `json:"id"`
	PublisherID        int32              `json:"publisher_id"`
	Email              string             `json:"email"`
	RoleID             int16              `json:"role_id"`
	Token              string             `json:"token"`
	ExpiresAt          pgtype.Timestamptz `json:"expires_at"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	InvitedBy          string             `json:"invited_by"`
	Status             *string            `json:"status"`
	AcceptedAt         pgtype.Timestamptz `json:"accepted_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	RoleKey            string             `json:"role_key"`
	RoleDisplayEnglish string             `json:"role_display_english"`
}

func (q *Queries) ListAllInvitationsByPublisher(ctx context.Context, publisherID int32) ([]ListAllInvitationsByPublisherRow, error) {
	rows, err := q.db.Query(ctx, listAllInvitationsByPublisher, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllInvitationsByPublisherRow{}
	for rows.Next() {
		var i ListAllInvitationsByPublisherRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.Email,
			&i.RoleID,
			&i.Token,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.InvitedBy,
			&i.Status,
			&i.AcceptedAt,
			&i.UpdatedAt,
			&i.RoleKey,
			&i.RoleDisplayEnglish,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resendInvitationUpdateToken = `-- name: ResendInvitationUpdateToken :one
UPDATE publisher_invitations
SET token = $2,
    expires_at = $3,
    status = 'pending',
    updated_at = NOW()
WHERE id = $1
  AND publisher_id = $4
RETURNING id, publisher_id, email, role_id, token, expires_at, created_at, invited_by, status, accepted_at, updated_at
`

type ResendInvitationUpdateTokenParams struct {
	ID          int32              `json:"id"`
	Token       string             `json:"token"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	PublisherID int32              `json:"publisher_id"`
}

func (q *Queries) ResendInvitationUpdateToken(ctx context.Context, arg ResendInvitationUpdateTokenParams) (PublisherInvitation, error) {
	row := q.db.QueryRow(ctx, resendInvitationUpdateToken,
		arg.ID,
		arg.Token,
		arg.ExpiresAt,
		arg.PublisherID,
	)
	var i PublisherInvitation
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.Email,
		&i.RoleID,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.InvitedBy,
		&i.Status,
		&i.AcceptedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateInvitationStatus = `-- name: UpdateInvitationStatus :one
UPDATE publisher_invitations
SET status = $2,
    updated_at = NOW(),
    accepted_at = CASE
        WHEN $2 = 'accepted' THEN NOW()
        ELSE accepted_at
    END
WHERE id = $1
RETURNING id, publisher_id, email, role_id, token, expires_at, created_at, invited_by, status, accepted_at, updated_at
`

type UpdateInvitationStatusParams struct {
	ID     int32   `json:"id"`
	Status *string `json:"status"`
}

func (q *Queries) UpdateInvitationStatus(ctx context.Context, arg UpdateInvitationStatusParams) (PublisherInvitation, error) {
	row := q.db.QueryRow(ctx, updateInvitationStatus, arg.ID, arg.Status)
	var i PublisherInvitation
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.Email,
		&i.RoleID,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.InvitedBy,
		&i.Status,
		&i.AcceptedAt,
		&i.UpdatedAt,
	)
	return i, err
}
