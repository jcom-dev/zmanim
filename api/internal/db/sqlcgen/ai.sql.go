// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: ai.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAIAuditLogs = `-- name: GetAIAuditLogs :many
SELECT id, publisher_id, user_id, request_type, input_text, output_text,
       tokens_used, model, confidence, success, error_message,
       duration_ms, rag_context_used, created_at
FROM ai_audit_logs
WHERE ($1 = '' OR request_type = $1)
ORDER BY created_at DESC
LIMIT $2
`

type GetAIAuditLogsParams struct {
	Column1 interface{} `json:"column_1"`
	Limit   int32       `json:"limit"`
}

func (q *Queries) GetAIAuditLogs(ctx context.Context, arg GetAIAuditLogsParams) ([]AiAuditLog, error) {
	rows, err := q.db.Query(ctx, getAIAuditLogs, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AiAuditLog{}
	for rows.Next() {
		var i AiAuditLog
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.UserID,
			&i.RequestType,
			&i.InputText,
			&i.OutputText,
			&i.TokensUsed,
			&i.Model,
			&i.Confidence,
			&i.Success,
			&i.ErrorMessage,
			&i.DurationMs,
			&i.RagContextUsed,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCachedExplanation = `-- name: GetCachedExplanation :one
SELECT explanation
FROM explanation_cache
WHERE formula_hash = $1 AND language = $2 AND expires_at > NOW()
`

type GetCachedExplanationParams struct {
	FormulaHash string `json:"formula_hash"`
	Language    string `json:"language"`
}

func (q *Queries) GetCachedExplanation(ctx context.Context, arg GetCachedExplanationParams) (string, error) {
	row := q.db.QueryRow(ctx, getCachedExplanation, arg.FormulaHash, arg.Language)
	var explanation string
	err := row.Scan(&explanation)
	return explanation, err
}

const insertAIAuditLog = `-- name: InsertAIAuditLog :exec
INSERT INTO ai_audit_logs (
    publisher_id, user_id, request_type, input_text, output_text,
    tokens_used, model, confidence, success, error_message,
    duration_ms, rag_context_used
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7, $8, $9, $10, $11, $12
)
`

type InsertAIAuditLogParams struct {
	PublisherID    *int32         `json:"publisher_id"`
	UserID         *string        `json:"user_id"`
	RequestType    string         `json:"request_type"`
	InputText      *string        `json:"input_text"`
	OutputText     *string        `json:"output_text"`
	TokensUsed     *int32         `json:"tokens_used"`
	Model          *string        `json:"model"`
	Confidence     pgtype.Numeric `json:"confidence"`
	Success        *bool          `json:"success"`
	ErrorMessage   *string        `json:"error_message"`
	DurationMs     *int32         `json:"duration_ms"`
	RagContextUsed *bool          `json:"rag_context_used"`
}

func (q *Queries) InsertAIAuditLog(ctx context.Context, arg InsertAIAuditLogParams) error {
	_, err := q.db.Exec(ctx, insertAIAuditLog,
		arg.PublisherID,
		arg.UserID,
		arg.RequestType,
		arg.InputText,
		arg.OutputText,
		arg.TokensUsed,
		arg.Model,
		arg.Confidence,
		arg.Success,
		arg.ErrorMessage,
		arg.DurationMs,
		arg.RagContextUsed,
	)
	return err
}

const upsertExplanationCache = `-- name: UpsertExplanationCache :exec
INSERT INTO explanation_cache (formula_hash, language, explanation, expires_at, source_id)
VALUES ($1, $2, $3, NOW() + INTERVAL '7 days', 1)
ON CONFLICT (formula_hash, language)
DO UPDATE SET
    explanation = EXCLUDED.explanation,
    expires_at = NOW() + INTERVAL '7 days',
    source_id = EXCLUDED.source_id
`

type UpsertExplanationCacheParams struct {
	FormulaHash string `json:"formula_hash"`
	Language    string `json:"language"`
	Explanation string `json:"explanation"`
}

func (q *Queries) UpsertExplanationCache(ctx context.Context, arg UpsertExplanationCacheParams) error {
	_, err := q.db.Exec(ctx, upsertExplanationCache, arg.FormulaHash, arg.Language, arg.Explanation)
	return err
}
