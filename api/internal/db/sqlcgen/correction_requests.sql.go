// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: correction_requests.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkDuplicateCorrectionRequests = `-- name: CheckDuplicateCorrectionRequests :many
SELECT
  ccr.id,
  ccr.locality_id,
  ccr.publisher_id,
  ccr.status,
  ccr.proposed_latitude,
  ccr.proposed_longitude,
  ccr.proposed_elevation,
  ccr.created_at,
  ccr.approved_at,
  p.name as publisher_name
FROM location_correction_requests ccr
LEFT JOIN publishers p ON ccr.publisher_id = p.id
WHERE ccr.locality_id = $1
  AND ccr.status IN ('pending', 'approved')
  AND (ccr.status = 'pending' OR ccr.approved_at > NOW() - INTERVAL '30 days')
ORDER BY
  CASE ccr.status WHEN 'pending' THEN 1 ELSE 2 END,
  ccr.created_at DESC
`

type CheckDuplicateCorrectionRequestsRow struct {
	ID                int32              `json:"id"`
	LocalityID        *int32             `json:"locality_id"`
	PublisherID       *int32             `json:"publisher_id"`
	Status            string             `json:"status"`
	ProposedLatitude  *float64           `json:"proposed_latitude"`
	ProposedLongitude *float64           `json:"proposed_longitude"`
	ProposedElevation *int32             `json:"proposed_elevation"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	ApprovedAt        pgtype.Timestamptz `json:"approved_at"`
	PublisherName     *string            `json:"publisher_name"`
}

func (q *Queries) CheckDuplicateCorrectionRequests(ctx context.Context, localityID *int32) ([]CheckDuplicateCorrectionRequestsRow, error) {
	rows, err := q.db.Query(ctx, checkDuplicateCorrectionRequests, localityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CheckDuplicateCorrectionRequestsRow{}
	for rows.Next() {
		var i CheckDuplicateCorrectionRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.LocalityID,
			&i.PublisherID,
			&i.Status,
			&i.ProposedLatitude,
			&i.ProposedLongitude,
			&i.ProposedElevation,
			&i.CreatedAt,
			&i.ApprovedAt,
			&i.PublisherName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createAdminElevationOverride = `-- name: CreateAdminElevationOverride :one
INSERT INTO geo_locality_elevations (
  locality_id,
  publisher_id,
  source_id,
  elevation_m,
  accuracy_m,
  reason,
  created_by
)
SELECT
  $1::integer,
  NULL,  -- System-wide (not publisher-specific)
  ds.id,
  $2::integer,
  $3::integer,
  $4::text,
  $5::text
FROM geo_data_sources ds
WHERE ds.key = 'admin'
ON CONFLICT ON CONSTRAINT geo_locality_elevations_unique
DO UPDATE SET
  elevation_m = EXCLUDED.elevation_m,
  accuracy_m = COALESCE(EXCLUDED.accuracy_m, geo_locality_elevations.accuracy_m),
  reason = COALESCE(EXCLUDED.reason, geo_locality_elevations.reason),
  updated_at = now()
RETURNING id, locality_id, publisher_id, source_id, elevation_m, accuracy_m, reason, created_at, updated_at, created_by
`

type CreateAdminElevationOverrideParams struct {
	LocalityID int32   `json:"locality_id"`
	ElevationM int32   `json:"elevation_m"`
	AccuracyM  *int32  `json:"accuracy_m"`
	Reason     *string `json:"reason"`
	CreatedBy  *string `json:"created_by"`
}

// Creates an admin override for locality elevation (source='admin', publisher_id=NULL)
// This is the highest priority system-wide elevation source
func (q *Queries) CreateAdminElevationOverride(ctx context.Context, arg CreateAdminElevationOverrideParams) (GeoLocalityElevation, error) {
	row := q.db.QueryRow(ctx, createAdminElevationOverride,
		arg.LocalityID,
		arg.ElevationM,
		arg.AccuracyM,
		arg.Reason,
		arg.CreatedBy,
	)
	var i GeoLocalityElevation
	err := row.Scan(
		&i.ID,
		&i.LocalityID,
		&i.PublisherID,
		&i.SourceID,
		&i.ElevationM,
		&i.AccuracyM,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const createAdminLocationOverride = `-- name: CreateAdminLocationOverride :one
INSERT INTO geo_locality_locations (
  locality_id,
  publisher_id,
  source_id,
  latitude,
  longitude,
  accuracy_m,
  reason,
  created_by
)
SELECT
  $1::integer,
  NULL,  -- System-wide (not publisher-specific)
  ds.id,
  $2::double precision,
  $3::double precision,
  $4::integer,
  $5::text,
  $6::text
FROM geo_data_sources ds
WHERE ds.key = 'admin'
ON CONFLICT ON CONSTRAINT geo_locality_locations_unique
DO UPDATE SET
  latitude = EXCLUDED.latitude,
  longitude = EXCLUDED.longitude,
  accuracy_m = COALESCE(EXCLUDED.accuracy_m, geo_locality_locations.accuracy_m),
  reason = COALESCE(EXCLUDED.reason, geo_locality_locations.reason),
  updated_at = now()
RETURNING id, locality_id, publisher_id, source_id, latitude, longitude, accuracy_m, reason, created_at, updated_at, created_by
`

type CreateAdminLocationOverrideParams struct {
	LocalityID int32   `json:"locality_id"`
	Latitude   float64 `json:"latitude"`
	Longitude  float64 `json:"longitude"`
	AccuracyM  *int32  `json:"accuracy_m"`
	Reason     *string `json:"reason"`
	CreatedBy  *string `json:"created_by"`
}

type CreateAdminLocationOverrideRow struct {
	ID          int32              `json:"id"`
	LocalityID  int32              `json:"locality_id"`
	PublisherID *int32             `json:"publisher_id"`
	SourceID    int32              `json:"source_id"`
	Latitude    float64            `json:"latitude"`
	Longitude   float64            `json:"longitude"`
	AccuracyM   *int32             `json:"accuracy_m"`
	Reason      *string            `json:"reason"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	CreatedBy   *string            `json:"created_by"`
}

// Creates an admin override for locality coordinates (source='admin', publisher_id=NULL)
// This is the highest priority system-wide coordinate source
func (q *Queries) CreateAdminLocationOverride(ctx context.Context, arg CreateAdminLocationOverrideParams) (CreateAdminLocationOverrideRow, error) {
	row := q.db.QueryRow(ctx, createAdminLocationOverride,
		arg.LocalityID,
		arg.Latitude,
		arg.Longitude,
		arg.AccuracyM,
		arg.Reason,
		arg.CreatedBy,
	)
	var i CreateAdminLocationOverrideRow
	err := row.Scan(
		&i.ID,
		&i.LocalityID,
		&i.PublisherID,
		&i.SourceID,
		&i.Latitude,
		&i.Longitude,
		&i.AccuracyM,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const createCorrectionRequest = `-- name: CreateCorrectionRequest :one

INSERT INTO location_correction_requests (
  locality_id,
  publisher_id,
  requester_email,
  requester_name,
  proposed_latitude,
  proposed_longitude,
  proposed_elevation,
  correction_reason,
  evidence_urls
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, publisher_id, requester_email, requester_name, proposed_latitude, proposed_longitude, proposed_elevation, correction_reason, evidence_urls, status, reviewed_by, reviewed_at, review_notes, created_at, updated_at, locality_id, approved_at, reverted_at, reverted_by, revert_reason
`

type CreateCorrectionRequestParams struct {
	LocalityID        *int32   `json:"locality_id"`
	PublisherID       *int32   `json:"publisher_id"`
	RequesterEmail    string   `json:"requester_email"`
	RequesterName     *string  `json:"requester_name"`
	ProposedLatitude  *float64 `json:"proposed_latitude"`
	ProposedLongitude *float64 `json:"proposed_longitude"`
	ProposedElevation *int32   `json:"proposed_elevation"`
	CorrectionReason  string   `json:"correction_reason"`
	EvidenceUrls      []string `json:"evidence_urls"`
}

// File: correction_requests.sql
// Purpose: SQLc queries for locality correction requests
// Story: 6.5 - Public Correction Requests
func (q *Queries) CreateCorrectionRequest(ctx context.Context, arg CreateCorrectionRequestParams) (LocationCorrectionRequest, error) {
	row := q.db.QueryRow(ctx, createCorrectionRequest,
		arg.LocalityID,
		arg.PublisherID,
		arg.RequesterEmail,
		arg.RequesterName,
		arg.ProposedLatitude,
		arg.ProposedLongitude,
		arg.ProposedElevation,
		arg.CorrectionReason,
		arg.EvidenceUrls,
	)
	var i LocationCorrectionRequest
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.RequesterEmail,
		&i.RequesterName,
		&i.ProposedLatitude,
		&i.ProposedLongitude,
		&i.ProposedElevation,
		&i.CorrectionReason,
		&i.EvidenceUrls,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LocalityID,
		&i.ApprovedAt,
		&i.RevertedAt,
		&i.RevertedBy,
		&i.RevertReason,
	)
	return i, err
}

const createPublisherElevationOverride = `-- name: CreatePublisherElevationOverride :one
INSERT INTO geo_locality_elevations (
  locality_id,
  publisher_id,
  source_id,
  elevation_m,
  accuracy_m,
  reason,
  created_by
)
SELECT
  $1::integer,
  $2::integer,
  ds.id,
  $3::integer,
  $4::integer,
  $5::text,
  $6::text
FROM geo_data_sources ds
WHERE ds.key = 'publisher'
ON CONFLICT ON CONSTRAINT geo_locality_elevations_unique
DO UPDATE SET
  elevation_m = EXCLUDED.elevation_m,
  accuracy_m = COALESCE(EXCLUDED.accuracy_m, geo_locality_elevations.accuracy_m),
  reason = COALESCE(EXCLUDED.reason, geo_locality_elevations.reason),
  updated_at = now()
RETURNING id, locality_id, publisher_id, source_id, elevation_m, accuracy_m, reason, created_at, updated_at, created_by
`

type CreatePublisherElevationOverrideParams struct {
	LocalityID  int32   `json:"locality_id"`
	PublisherID int32   `json:"publisher_id"`
	ElevationM  int32   `json:"elevation_m"`
	AccuracyM   *int32  `json:"accuracy_m"`
	Reason      *string `json:"reason"`
	CreatedBy   *string `json:"created_by"`
}

// Creates a publisher-specific override for locality elevation
// This is the highest priority for this publisher's zmanim calculations
func (q *Queries) CreatePublisherElevationOverride(ctx context.Context, arg CreatePublisherElevationOverrideParams) (GeoLocalityElevation, error) {
	row := q.db.QueryRow(ctx, createPublisherElevationOverride,
		arg.LocalityID,
		arg.PublisherID,
		arg.ElevationM,
		arg.AccuracyM,
		arg.Reason,
		arg.CreatedBy,
	)
	var i GeoLocalityElevation
	err := row.Scan(
		&i.ID,
		&i.LocalityID,
		&i.PublisherID,
		&i.SourceID,
		&i.ElevationM,
		&i.AccuracyM,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const createPublisherLocationOverride = `-- name: CreatePublisherLocationOverride :one
INSERT INTO geo_locality_locations (
  locality_id,
  publisher_id,
  source_id,
  latitude,
  longitude,
  accuracy_m,
  reason,
  created_by
)
SELECT
  $1::integer,
  $2::integer,
  ds.id,
  $3::double precision,
  $4::double precision,
  $5::integer,
  $6::text,
  $7::text
FROM geo_data_sources ds
WHERE ds.key = 'publisher'
ON CONFLICT ON CONSTRAINT geo_locality_locations_unique
DO UPDATE SET
  latitude = EXCLUDED.latitude,
  longitude = EXCLUDED.longitude,
  accuracy_m = COALESCE(EXCLUDED.accuracy_m, geo_locality_locations.accuracy_m),
  reason = COALESCE(EXCLUDED.reason, geo_locality_locations.reason),
  updated_at = now()
RETURNING id, locality_id, publisher_id, source_id, latitude, longitude, accuracy_m, reason, created_at, updated_at, created_by
`

type CreatePublisherLocationOverrideParams struct {
	LocalityID  int32   `json:"locality_id"`
	PublisherID int32   `json:"publisher_id"`
	Latitude    float64 `json:"latitude"`
	Longitude   float64 `json:"longitude"`
	AccuracyM   *int32  `json:"accuracy_m"`
	Reason      *string `json:"reason"`
	CreatedBy   *string `json:"created_by"`
}

type CreatePublisherLocationOverrideRow struct {
	ID          int32              `json:"id"`
	LocalityID  int32              `json:"locality_id"`
	PublisherID *int32             `json:"publisher_id"`
	SourceID    int32              `json:"source_id"`
	Latitude    float64            `json:"latitude"`
	Longitude   float64            `json:"longitude"`
	AccuracyM   *int32             `json:"accuracy_m"`
	Reason      *string            `json:"reason"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	CreatedBy   *string            `json:"created_by"`
}

// Creates a publisher-specific override for locality coordinates
// This is the highest priority for this publisher's zmanim calculations
func (q *Queries) CreatePublisherLocationOverride(ctx context.Context, arg CreatePublisherLocationOverrideParams) (CreatePublisherLocationOverrideRow, error) {
	row := q.db.QueryRow(ctx, createPublisherLocationOverride,
		arg.LocalityID,
		arg.PublisherID,
		arg.Latitude,
		arg.Longitude,
		arg.AccuracyM,
		arg.Reason,
		arg.CreatedBy,
	)
	var i CreatePublisherLocationOverrideRow
	err := row.Scan(
		&i.ID,
		&i.LocalityID,
		&i.PublisherID,
		&i.SourceID,
		&i.Latitude,
		&i.Longitude,
		&i.AccuracyM,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const deleteCorrectionRequest = `-- name: DeleteCorrectionRequest :exec
DELETE FROM location_correction_requests
WHERE id = $1
`

// Deletes a correction request by ID
func (q *Queries) DeleteCorrectionRequest(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteCorrectionRequest, id)
	return err
}

const deleteLocalityElevationOverrideByLocality = `-- name: DeleteLocalityElevationOverrideByLocality :exec
DELETE FROM geo_locality_elevations
WHERE locality_id = $1::integer
  AND source_id IN (
    SELECT id FROM geo_data_sources
    WHERE key IN ('admin', 'publisher')
  )
  AND (
    ($2::integer IS NULL AND publisher_id IS NULL)
    OR publisher_id = $2::integer
  )
`

type DeleteLocalityElevationOverrideByLocalityParams struct {
	LocalityID  int32  `json:"locality_id"`
	PublisherID *int32 `json:"publisher_id"`
}

// Removes an elevation override (admin or publisher) by locality_id and optional publisher_id
// ONLY deletes admin or publisher overrides, never base data sources
func (q *Queries) DeleteLocalityElevationOverrideByLocality(ctx context.Context, arg DeleteLocalityElevationOverrideByLocalityParams) error {
	_, err := q.db.Exec(ctx, deleteLocalityElevationOverrideByLocality, arg.LocalityID, arg.PublisherID)
	return err
}

const deleteLocalityLocationOverrideByLocality = `-- name: DeleteLocalityLocationOverrideByLocality :exec
DELETE FROM geo_locality_locations
WHERE locality_id = $1::integer
  AND source_id IN (
    SELECT id FROM geo_data_sources
    WHERE key IN ('admin', 'publisher')
  )
  AND (
    ($2::integer IS NULL AND publisher_id IS NULL)
    OR publisher_id = $2::integer
  )
`

type DeleteLocalityLocationOverrideByLocalityParams struct {
	LocalityID  int32  `json:"locality_id"`
	PublisherID *int32 `json:"publisher_id"`
}

// Removes a location override (admin or publisher) by locality_id and optional publisher_id
// ONLY deletes admin or publisher overrides, never base data sources
func (q *Queries) DeleteLocalityLocationOverrideByLocality(ctx context.Context, arg DeleteLocalityLocationOverrideByLocalityParams) error {
	_, err := q.db.Exec(ctx, deleteLocalityLocationOverrideByLocality, arg.LocalityID, arg.PublisherID)
	return err
}

const getAllCorrectionRequests = `-- name: GetAllCorrectionRequests :many
SELECT
  ccr.id, ccr.publisher_id, ccr.requester_email, ccr.requester_name, ccr.proposed_latitude, ccr.proposed_longitude, ccr.proposed_elevation, ccr.correction_reason, ccr.evidence_urls, ccr.status, ccr.reviewed_by, ccr.reviewed_at, ccr.review_notes, ccr.created_at, ccr.updated_at, ccr.locality_id, ccr.approved_at, ccr.reverted_at, ccr.reverted_by, ccr.revert_reason,
  l.name as locality_name,
  COALESCE(bc.latitude, 0.0) as current_latitude,
  COALESCE(bc.longitude, 0.0) as current_longitude,
  COALESCE(be.elevation_m, 0) as current_elevation,
  p.name as publisher_name
FROM location_correction_requests ccr
JOIN geo_localities l ON ccr.locality_id = l.id
LEFT JOIN LATERAL (
  SELECT ll.latitude, ll.longitude
  FROM geo_locality_locations ll
  JOIN geo_data_sources ds ON ds.id = ll.source_id AND ds.is_active = true
  WHERE ll.locality_id = l.id AND ll.publisher_id IS NULL
  ORDER BY CASE ds.key WHEN 'admin' THEN 1 ELSE 2 END, ds.priority
  LIMIT 1
) bc ON true
LEFT JOIN LATERAL (
  SELECT le.elevation_m
  FROM geo_locality_elevations le
  JOIN geo_data_sources ds ON ds.id = le.source_id AND ds.is_active = true
  WHERE le.locality_id = l.id AND le.publisher_id IS NULL
  ORDER BY CASE ds.key WHEN 'admin' THEN 1 ELSE 2 END, ds.priority
  LIMIT 1
) be ON true
LEFT JOIN publishers p ON ccr.publisher_id = p.id
WHERE ($1::text IS NULL OR ccr.status = $1)
ORDER BY ccr.created_at DESC
`

type GetAllCorrectionRequestsRow struct {
	ID                int32              `json:"id"`
	PublisherID       *int32             `json:"publisher_id"`
	RequesterEmail    string             `json:"requester_email"`
	RequesterName     *string            `json:"requester_name"`
	ProposedLatitude  *float64           `json:"proposed_latitude"`
	ProposedLongitude *float64           `json:"proposed_longitude"`
	ProposedElevation *int32             `json:"proposed_elevation"`
	CorrectionReason  string             `json:"correction_reason"`
	EvidenceUrls      []string           `json:"evidence_urls"`
	Status            string             `json:"status"`
	ReviewedBy        *string            `json:"reviewed_by"`
	ReviewedAt        pgtype.Timestamptz `json:"reviewed_at"`
	ReviewNotes       *string            `json:"review_notes"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	LocalityID        *int32             `json:"locality_id"`
	ApprovedAt        pgtype.Timestamptz `json:"approved_at"`
	RevertedAt        pgtype.Timestamptz `json:"reverted_at"`
	RevertedBy        *string            `json:"reverted_by"`
	RevertReason      *string            `json:"revert_reason"`
	LocalityName      string             `json:"locality_name"`
	CurrentLatitude   float64            `json:"current_latitude"`
	CurrentLongitude  float64            `json:"current_longitude"`
	CurrentElevation  int32              `json:"current_elevation"`
	PublisherName     *string            `json:"publisher_name"`
}

// Current coordinates/elevation resolved with priority: admin > default (for display)
// Uses LATERAL joins to avoid materializing the full resolved_coords view for 4M+ localities
func (q *Queries) GetAllCorrectionRequests(ctx context.Context, status *string) ([]GetAllCorrectionRequestsRow, error) {
	rows, err := q.db.Query(ctx, getAllCorrectionRequests, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllCorrectionRequestsRow{}
	for rows.Next() {
		var i GetAllCorrectionRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.RequesterEmail,
			&i.RequesterName,
			&i.ProposedLatitude,
			&i.ProposedLongitude,
			&i.ProposedElevation,
			&i.CorrectionReason,
			&i.EvidenceUrls,
			&i.Status,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.ReviewNotes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LocalityID,
			&i.ApprovedAt,
			&i.RevertedAt,
			&i.RevertedBy,
			&i.RevertReason,
			&i.LocalityName,
			&i.CurrentLatitude,
			&i.CurrentLongitude,
			&i.CurrentElevation,
			&i.PublisherName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCorrectionRequestByID = `-- name: GetCorrectionRequestByID :one
SELECT
  ccr.id, ccr.publisher_id, ccr.requester_email, ccr.requester_name, ccr.proposed_latitude, ccr.proposed_longitude, ccr.proposed_elevation, ccr.correction_reason, ccr.evidence_urls, ccr.status, ccr.reviewed_by, ccr.reviewed_at, ccr.review_notes, ccr.created_at, ccr.updated_at, ccr.locality_id, ccr.approved_at, ccr.reverted_at, ccr.reverted_by, ccr.revert_reason,
  l.name as locality_name,
  COALESCE(bc.latitude, 0.0) as current_latitude,
  COALESCE(bc.longitude, 0.0) as current_longitude,
  COALESCE(be.elevation_m, 0) as current_elevation,
  oc.latitude as original_latitude,
  oc.longitude as original_longitude,
  oe.elevation_m as original_elevation,
  p.name as publisher_name
FROM location_correction_requests ccr
JOIN geo_localities l ON ccr.locality_id = l.id
LEFT JOIN LATERAL (
  SELECT ll.latitude, ll.longitude
  FROM geo_locality_locations ll
  JOIN geo_data_sources ds ON ds.id = ll.source_id AND ds.is_active = true
  WHERE ll.locality_id = l.id AND ll.publisher_id IS NULL
  ORDER BY CASE ds.key WHEN 'admin' THEN 1 ELSE 2 END, ds.priority
  LIMIT 1
) bc ON true
LEFT JOIN LATERAL (
  SELECT le.elevation_m
  FROM geo_locality_elevations le
  JOIN geo_data_sources ds ON ds.id = le.source_id AND ds.is_active = true
  WHERE le.locality_id = l.id AND le.publisher_id IS NULL
  ORDER BY CASE ds.key WHEN 'admin' THEN 1 ELSE 2 END, ds.priority
  LIMIT 1
) be ON true
LEFT JOIN LATERAL (
  SELECT ll.latitude, ll.longitude
  FROM geo_locality_locations ll
  JOIN geo_data_sources ds ON ds.id = ll.source_id AND ds.is_active = true
  WHERE ll.locality_id = l.id AND ll.publisher_id IS NULL AND ds.key != 'admin'
  ORDER BY ds.priority
  LIMIT 1
) oc ON true
LEFT JOIN LATERAL (
  SELECT le.elevation_m
  FROM geo_locality_elevations le
  JOIN geo_data_sources ds ON ds.id = le.source_id AND ds.is_active = true
  WHERE le.locality_id = l.id AND le.publisher_id IS NULL AND ds.key != 'admin'
  ORDER BY ds.priority
  LIMIT 1
) oe ON true
LEFT JOIN publishers p ON ccr.publisher_id = p.id
WHERE ccr.id = $1
`

type GetCorrectionRequestByIDRow struct {
	ID                int32              `json:"id"`
	PublisherID       *int32             `json:"publisher_id"`
	RequesterEmail    string             `json:"requester_email"`
	RequesterName     *string            `json:"requester_name"`
	ProposedLatitude  *float64           `json:"proposed_latitude"`
	ProposedLongitude *float64           `json:"proposed_longitude"`
	ProposedElevation *int32             `json:"proposed_elevation"`
	CorrectionReason  string             `json:"correction_reason"`
	EvidenceUrls      []string           `json:"evidence_urls"`
	Status            string             `json:"status"`
	ReviewedBy        *string            `json:"reviewed_by"`
	ReviewedAt        pgtype.Timestamptz `json:"reviewed_at"`
	ReviewNotes       *string            `json:"review_notes"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	LocalityID        *int32             `json:"locality_id"`
	ApprovedAt        pgtype.Timestamptz `json:"approved_at"`
	RevertedAt        pgtype.Timestamptz `json:"reverted_at"`
	RevertedBy        *string            `json:"reverted_by"`
	RevertReason      *string            `json:"revert_reason"`
	LocalityName      string             `json:"locality_name"`
	CurrentLatitude   float64            `json:"current_latitude"`
	CurrentLongitude  float64            `json:"current_longitude"`
	CurrentElevation  int32              `json:"current_elevation"`
	OriginalLatitude  float64            `json:"original_latitude"`
	OriginalLongitude float64            `json:"original_longitude"`
	OriginalElevation int32              `json:"original_elevation"`
	PublisherName     *string            `json:"publisher_name"`
}

// Current coordinates/elevation resolved with priority: admin > default (for display)
// Original coordinates/elevation from default source (excluding admin overrides, for revert)
// Uses LATERAL joins to avoid materializing the full resolved_coords view for 4M+ localities
func (q *Queries) GetCorrectionRequestByID(ctx context.Context, id int32) (GetCorrectionRequestByIDRow, error) {
	row := q.db.QueryRow(ctx, getCorrectionRequestByID, id)
	var i GetCorrectionRequestByIDRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.RequesterEmail,
		&i.RequesterName,
		&i.ProposedLatitude,
		&i.ProposedLongitude,
		&i.ProposedElevation,
		&i.CorrectionReason,
		&i.EvidenceUrls,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LocalityID,
		&i.ApprovedAt,
		&i.RevertedAt,
		&i.RevertedBy,
		&i.RevertReason,
		&i.LocalityName,
		&i.CurrentLatitude,
		&i.CurrentLongitude,
		&i.CurrentElevation,
		&i.OriginalLatitude,
		&i.OriginalLongitude,
		&i.OriginalElevation,
		&i.PublisherName,
	)
	return i, err
}

const getCorrectionRequestHistory = `-- name: GetCorrectionRequestHistory :many
SELECT
  ccr.id,
  ccr.locality_id,
  l.name as locality_name,
  c.name as country_name,
  ccr.publisher_id,
  p.name as publisher_name,
  ccr.requester_email,
  ccr.requester_name,
  COALESCE(bc.latitude, 0.0) as previous_latitude,
  COALESCE(bc.longitude, 0.0) as previous_longitude,
  COALESCE(be.elevation_m, 0) as previous_elevation,
  ccr.proposed_latitude,
  ccr.proposed_longitude,
  ccr.proposed_elevation,
  ccr.status,
  ccr.reviewed_at as approved_at,
  ccr.reverted_at,
  ccr.reverted_by,
  ccr.revert_reason,
  ccr.created_at
FROM location_correction_requests ccr
JOIN geo_localities l ON ccr.locality_id = l.id
JOIN geo_countries c ON l.country_id = c.id
LEFT JOIN publishers p ON ccr.publisher_id = p.id
LEFT JOIN LATERAL (
  SELECT ll.latitude, ll.longitude
  FROM geo_locality_locations ll
  JOIN geo_data_sources ds ON ds.id = ll.source_id AND ds.is_active = true
  WHERE ll.locality_id = l.id AND ll.publisher_id IS NULL
  ORDER BY CASE ds.key WHEN 'admin' THEN 1 ELSE 2 END, ds.priority
  LIMIT 1
) bc ON true
LEFT JOIN LATERAL (
  SELECT le.elevation_m
  FROM geo_locality_elevations le
  JOIN geo_data_sources ds ON ds.id = le.source_id AND ds.is_active = true
  WHERE le.locality_id = l.id AND le.publisher_id IS NULL
  ORDER BY CASE ds.key WHEN 'admin' THEN 1 ELSE 2 END, ds.priority
  LIMIT 1
) be ON true
WHERE ccr.locality_id = $1
  AND ccr.status IN ('approved', 'reverted')
ORDER BY
  CASE ccr.status
    WHEN 'approved' THEN 1
    WHEN 'reverted' THEN 2
  END,
  ccr.reviewed_at DESC NULLS LAST,
  ccr.created_at DESC
`

type GetCorrectionRequestHistoryRow struct {
	ID                int32              `json:"id"`
	LocalityID        *int32             `json:"locality_id"`
	LocalityName      string             `json:"locality_name"`
	CountryName       string             `json:"country_name"`
	PublisherID       *int32             `json:"publisher_id"`
	PublisherName     *string            `json:"publisher_name"`
	RequesterEmail    string             `json:"requester_email"`
	RequesterName     *string            `json:"requester_name"`
	PreviousLatitude  float64            `json:"previous_latitude"`
	PreviousLongitude float64            `json:"previous_longitude"`
	PreviousElevation int32              `json:"previous_elevation"`
	ProposedLatitude  *float64           `json:"proposed_latitude"`
	ProposedLongitude *float64           `json:"proposed_longitude"`
	ProposedElevation *int32             `json:"proposed_elevation"`
	Status            string             `json:"status"`
	ApprovedAt        pgtype.Timestamptz `json:"approved_at"`
	RevertedAt        pgtype.Timestamptz `json:"reverted_at"`
	RevertedBy        *string            `json:"reverted_by"`
	RevertReason      *string            `json:"revert_reason"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
}

// Get all approved/reverted correction requests for a locality (for History & Revert tab)
// Uses LATERAL joins to get current coordinates (before the correction was applied)
func (q *Queries) GetCorrectionRequestHistory(ctx context.Context, localityID *int32) ([]GetCorrectionRequestHistoryRow, error) {
	rows, err := q.db.Query(ctx, getCorrectionRequestHistory, localityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCorrectionRequestHistoryRow{}
	for rows.Next() {
		var i GetCorrectionRequestHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.LocalityID,
			&i.LocalityName,
			&i.CountryName,
			&i.PublisherID,
			&i.PublisherName,
			&i.RequesterEmail,
			&i.RequesterName,
			&i.PreviousLatitude,
			&i.PreviousLongitude,
			&i.PreviousElevation,
			&i.ProposedLatitude,
			&i.ProposedLongitude,
			&i.ProposedElevation,
			&i.Status,
			&i.ApprovedAt,
			&i.RevertedAt,
			&i.RevertedBy,
			&i.RevertReason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherCorrectionRequests = `-- name: GetPublisherCorrectionRequests :many
SELECT
  ccr.id, ccr.publisher_id, ccr.requester_email, ccr.requester_name, ccr.proposed_latitude, ccr.proposed_longitude, ccr.proposed_elevation, ccr.correction_reason, ccr.evidence_urls, ccr.status, ccr.reviewed_by, ccr.reviewed_at, ccr.review_notes, ccr.created_at, ccr.updated_at, ccr.locality_id, ccr.approved_at, ccr.reverted_at, ccr.reverted_by, ccr.revert_reason,
  l.name as locality_name,
  COALESCE(bc.latitude, 0.0) as current_latitude,
  COALESCE(bc.longitude, 0.0) as current_longitude,
  COALESCE(be.elevation_m, 0) as current_elevation
FROM location_correction_requests ccr
JOIN geo_localities l ON ccr.locality_id = l.id
LEFT JOIN LATERAL (
  SELECT ll.latitude, ll.longitude
  FROM geo_locality_locations ll
  JOIN geo_data_sources ds ON ds.id = ll.source_id AND ds.is_active = true
  WHERE ll.locality_id = l.id AND ll.publisher_id IS NULL
  ORDER BY CASE ds.key WHEN 'admin' THEN 1 ELSE 2 END, ds.priority
  LIMIT 1
) bc ON true
LEFT JOIN LATERAL (
  SELECT le.elevation_m
  FROM geo_locality_elevations le
  JOIN geo_data_sources ds ON ds.id = le.source_id AND ds.is_active = true
  WHERE le.locality_id = l.id AND le.publisher_id IS NULL
  ORDER BY CASE ds.key WHEN 'admin' THEN 1 ELSE 2 END, ds.priority
  LIMIT 1
) be ON true
WHERE ccr.publisher_id = $1
ORDER BY ccr.created_at DESC
`

type GetPublisherCorrectionRequestsRow struct {
	ID                int32              `json:"id"`
	PublisherID       *int32             `json:"publisher_id"`
	RequesterEmail    string             `json:"requester_email"`
	RequesterName     *string            `json:"requester_name"`
	ProposedLatitude  *float64           `json:"proposed_latitude"`
	ProposedLongitude *float64           `json:"proposed_longitude"`
	ProposedElevation *int32             `json:"proposed_elevation"`
	CorrectionReason  string             `json:"correction_reason"`
	EvidenceUrls      []string           `json:"evidence_urls"`
	Status            string             `json:"status"`
	ReviewedBy        *string            `json:"reviewed_by"`
	ReviewedAt        pgtype.Timestamptz `json:"reviewed_at"`
	ReviewNotes       *string            `json:"review_notes"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	LocalityID        *int32             `json:"locality_id"`
	ApprovedAt        pgtype.Timestamptz `json:"approved_at"`
	RevertedAt        pgtype.Timestamptz `json:"reverted_at"`
	RevertedBy        *string            `json:"reverted_by"`
	RevertReason      *string            `json:"revert_reason"`
	LocalityName      string             `json:"locality_name"`
	CurrentLatitude   float64            `json:"current_latitude"`
	CurrentLongitude  float64            `json:"current_longitude"`
	CurrentElevation  int32              `json:"current_elevation"`
}

// Current coordinates/elevation resolved with priority: admin > default (for display)
// Uses LATERAL joins to avoid materializing the full resolved_coords view for 4M+ localities
func (q *Queries) GetPublisherCorrectionRequests(ctx context.Context, publisherID *int32) ([]GetPublisherCorrectionRequestsRow, error) {
	rows, err := q.db.Query(ctx, getPublisherCorrectionRequests, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherCorrectionRequestsRow{}
	for rows.Next() {
		var i GetPublisherCorrectionRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.RequesterEmail,
			&i.RequesterName,
			&i.ProposedLatitude,
			&i.ProposedLongitude,
			&i.ProposedElevation,
			&i.CorrectionReason,
			&i.EvidenceUrls,
			&i.Status,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.ReviewNotes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LocalityID,
			&i.ApprovedAt,
			&i.RevertedAt,
			&i.RevertedBy,
			&i.RevertReason,
			&i.LocalityName,
			&i.CurrentLatitude,
			&i.CurrentLongitude,
			&i.CurrentElevation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestHistory = `-- name: GetRequestHistory :many
SELECT id, correction_request_id, locality_id, action, performed_by, performed_at, previous_latitude, previous_longitude, previous_elevation, new_latitude, new_longitude, new_elevation, notes, created_at FROM correction_request_history
WHERE correction_request_id = $1
ORDER BY performed_at DESC
`

func (q *Queries) GetRequestHistory(ctx context.Context, correctionRequestID int32) ([]CorrectionRequestHistory, error) {
	rows, err := q.db.Query(ctx, getRequestHistory, correctionRequestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CorrectionRequestHistory{}
	for rows.Next() {
		var i CorrectionRequestHistory
		if err := rows.Scan(
			&i.ID,
			&i.CorrectionRequestID,
			&i.LocalityID,
			&i.Action,
			&i.PerformedBy,
			&i.PerformedAt,
			&i.PreviousLatitude,
			&i.PreviousLongitude,
			&i.PreviousElevation,
			&i.NewLatitude,
			&i.NewLongitude,
			&i.NewElevation,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertCorrectionHistory = `-- name: InsertCorrectionHistory :one
INSERT INTO correction_request_history (
  correction_request_id, locality_id, action, performed_by,
  previous_latitude, previous_longitude, previous_elevation,
  new_latitude, new_longitude, new_elevation, notes
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, correction_request_id, locality_id, action, performed_by, performed_at, previous_latitude, previous_longitude, previous_elevation, new_latitude, new_longitude, new_elevation, notes, created_at
`

type InsertCorrectionHistoryParams struct {
	CorrectionRequestID int32    `json:"correction_request_id"`
	LocalityID          int32    `json:"locality_id"`
	Action              string   `json:"action"`
	PerformedBy         string   `json:"performed_by"`
	PreviousLatitude    *float64 `json:"previous_latitude"`
	PreviousLongitude   *float64 `json:"previous_longitude"`
	PreviousElevation   *int32   `json:"previous_elevation"`
	NewLatitude         *float64 `json:"new_latitude"`
	NewLongitude        *float64 `json:"new_longitude"`
	NewElevation        *int32   `json:"new_elevation"`
	Notes               *string  `json:"notes"`
}

func (q *Queries) InsertCorrectionHistory(ctx context.Context, arg InsertCorrectionHistoryParams) (CorrectionRequestHistory, error) {
	row := q.db.QueryRow(ctx, insertCorrectionHistory,
		arg.CorrectionRequestID,
		arg.LocalityID,
		arg.Action,
		arg.PerformedBy,
		arg.PreviousLatitude,
		arg.PreviousLongitude,
		arg.PreviousElevation,
		arg.NewLatitude,
		arg.NewLongitude,
		arg.NewElevation,
		arg.Notes,
	)
	var i CorrectionRequestHistory
	err := row.Scan(
		&i.ID,
		&i.CorrectionRequestID,
		&i.LocalityID,
		&i.Action,
		&i.PerformedBy,
		&i.PerformedAt,
		&i.PreviousLatitude,
		&i.PreviousLongitude,
		&i.PreviousElevation,
		&i.NewLatitude,
		&i.NewLongitude,
		&i.NewElevation,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const revertCorrectionRequest = `-- name: RevertCorrectionRequest :exec
UPDATE location_correction_requests
SET status = 'reverted',
    reverted_at = NOW(),
    reverted_by = $1,
    revert_reason = $2,
    updated_at = NOW()
WHERE id = $3 AND status = 'approved'
`

type RevertCorrectionRequestParams struct {
	RevertedBy   *string `json:"reverted_by"`
	RevertReason *string `json:"revert_reason"`
	ID           int32   `json:"id"`
}

func (q *Queries) RevertCorrectionRequest(ctx context.Context, arg RevertCorrectionRequestParams) error {
	_, err := q.db.Exec(ctx, revertCorrectionRequest, arg.RevertedBy, arg.RevertReason, arg.ID)
	return err
}

const updateCorrectionRequest = `-- name: UpdateCorrectionRequest :one
UPDATE location_correction_requests
SET
  locality_id = $2,
  proposed_latitude = $3,
  proposed_longitude = $4,
  proposed_elevation = $5,
  correction_reason = $6,
  evidence_urls = $7,
  updated_at = now()
WHERE id = $1
RETURNING id, publisher_id, requester_email, requester_name, proposed_latitude, proposed_longitude, proposed_elevation, correction_reason, evidence_urls, status, reviewed_by, reviewed_at, review_notes, created_at, updated_at, locality_id, approved_at, reverted_at, reverted_by, revert_reason
`

type UpdateCorrectionRequestParams struct {
	ID                int32    `json:"id"`
	LocalityID        *int32   `json:"locality_id"`
	ProposedLatitude  *float64 `json:"proposed_latitude"`
	ProposedLongitude *float64 `json:"proposed_longitude"`
	ProposedElevation *int32   `json:"proposed_elevation"`
	CorrectionReason  string   `json:"correction_reason"`
	EvidenceUrls      []string `json:"evidence_urls"`
}

// Updates a pending correction request (publisher can only update their own pending requests)
func (q *Queries) UpdateCorrectionRequest(ctx context.Context, arg UpdateCorrectionRequestParams) (LocationCorrectionRequest, error) {
	row := q.db.QueryRow(ctx, updateCorrectionRequest,
		arg.ID,
		arg.LocalityID,
		arg.ProposedLatitude,
		arg.ProposedLongitude,
		arg.ProposedElevation,
		arg.CorrectionReason,
		arg.EvidenceUrls,
	)
	var i LocationCorrectionRequest
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.RequesterEmail,
		&i.RequesterName,
		&i.ProposedLatitude,
		&i.ProposedLongitude,
		&i.ProposedElevation,
		&i.CorrectionReason,
		&i.EvidenceUrls,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LocalityID,
		&i.ApprovedAt,
		&i.RevertedAt,
		&i.RevertedBy,
		&i.RevertReason,
	)
	return i, err
}

const updateCorrectionRequestStatus = `-- name: UpdateCorrectionRequestStatus :exec
UPDATE location_correction_requests
SET
  status = $2,
  reviewed_by = $3,
  reviewed_at = now(),
  review_notes = $4,
  approved_at = CASE WHEN $2 = 'approved' THEN NOW() ELSE NULL END,
  updated_at = now()
WHERE id = $1
`

type UpdateCorrectionRequestStatusParams struct {
	ID          int32   `json:"id"`
	Status      string  `json:"status"`
	ReviewedBy  *string `json:"reviewed_by"`
	ReviewNotes *string `json:"review_notes"`
}

func (q *Queries) UpdateCorrectionRequestStatus(ctx context.Context, arg UpdateCorrectionRequestStatusParams) error {
	_, err := q.db.Exec(ctx, updateCorrectionRequestStatus,
		arg.ID,
		arg.Status,
		arg.ReviewedBy,
		arg.ReviewNotes,
	)
	return err
}
