// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: publisher_reports.sql

package sqlcgen

import (
	"context"
)

const getLocalityForReport = `-- name: GetLocalityForReport :one
SELECT
    l.id,
    l.name,
    l.timezone,
    l.population,
    r.name as region_name,
    c.name as country_name,
    c.code as country_code,
    s.display_hierarchy
FROM geo_localities l
JOIN geo_countries c ON l.country_id = c.id
LEFT JOIN geo_search_index s ON s.entity_type = 'locality' AND s.entity_id = l.id
LEFT JOIN geo_regions r ON s.inherited_region_id = r.id
WHERE l.id = $1
`

type GetLocalityForReportRow struct {
	ID               int32   `json:"id"`
	Name             string  `json:"name"`
	Timezone         string  `json:"timezone"`
	Population       *int32  `json:"population"`
	RegionName       *string `json:"region_name"`
	CountryName      string  `json:"country_name"`
	CountryCode      string  `json:"country_code"`
	DisplayHierarchy *string `json:"display_hierarchy"`
}

// Fetches locality details with timezone for report location section
// NOTE: Coordinates/elevation are resolved separately via GetEffectiveLocalityLocation for publisher-aware overrides
func (q *Queries) GetLocalityForReport(ctx context.Context, id int32) (GetLocalityForReportRow, error) {
	row := q.db.QueryRow(ctx, getLocalityForReport, id)
	var i GetLocalityForReportRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Timezone,
		&i.Population,
		&i.RegionName,
		&i.CountryName,
		&i.CountryCode,
		&i.DisplayHierarchy,
	)
	return i, err
}

const getPublisherForReport = `-- name: GetPublisherForReport :one

SELECT
    p.id,
    p.name,
    p.logo_url,
    p.logo_data,
    p.description,
    ps.key as status_key,
    p.is_verified,
    p.is_certified,
    p.is_global
FROM publishers p
JOIN publisher_statuses ps ON ps.id = p.status_id
WHERE p.id = $1
`

type GetPublisherForReportRow struct {
	ID          int32   `json:"id"`
	Name        string  `json:"name"`
	LogoUrl     *string `json:"logo_url"`
	LogoData    *string `json:"logo_data"`
	Description *string `json:"description"`
	StatusKey   string  `json:"status_key"`
	IsVerified  bool    `json:"is_verified"`
	IsCertified bool    `json:"is_certified"`
	IsGlobal    bool    `json:"is_global"`
}

// Publisher Reports Queries
// Used for generating PDF reports of zmanim calculations
// Fetches publisher details needed for PDF report header
func (q *Queries) GetPublisherForReport(ctx context.Context, id int32) (GetPublisherForReportRow, error) {
	row := q.db.QueryRow(ctx, getPublisherForReport, id)
	var i GetPublisherForReportRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.LogoUrl,
		&i.LogoData,
		&i.Description,
		&i.StatusKey,
		&i.IsVerified,
		&i.IsCertified,
		&i.IsGlobal,
	)
	return i, err
}

const listPublisherZmanimForReport = `-- name: ListPublisherZmanimForReport :many
SELECT
    pz.id,
    pz.zman_key,
    pz.hebrew_name,
    pz.english_name,
    pz.description,
    COALESCE(linked_pz.formula_dsl, pz.formula_dsl) AS formula_dsl,
    pz.is_enabled,
    pz.rounding_mode,
    mzr.id as master_zman_id,
    mzr.formula_explanation,
    mzr.category,
    mzr.shita,
    mzr.canonical_hebrew_name as master_hebrew_name,
    mzr.canonical_english_name as master_english_name,
    COALESCE(mr_tc.key, tc.key, 'uncategorized') AS time_category,
    COALESCE(mr_tc.sort_order, tc.sort_order, 99) AS sort_order,
    -- Is this an event zman (has any tag with tag_type = 'event')?
    EXISTS (
        SELECT 1
        FROM (
            -- Publisher tags
            SELECT tt.key
            FROM publisher_zman_tags pzt
            JOIN zman_tags zt ON pzt.tag_id = zt.id
            JOIN tag_types tt ON zt.tag_type_id = tt.id
            WHERE pzt.publisher_zman_id = pz.id
            UNION ALL
            -- Master tags (fallback)
            SELECT tt.key
            FROM master_zman_tags mzt
            JOIN zman_tags zt ON mzt.tag_id = zt.id
            JOIN tag_types tt ON zt.tag_type_id = tt.id
            WHERE mzt.master_zman_id = pz.master_zman_id
        ) all_tags
        WHERE all_tags.key = 'event'
    ) AS is_event_zman,
    -- Tags: Publisher tags take precedence over master tags
    -- Display name respects publisher's transliteration_style preference (ashkenazi/sephardi)
    COALESCE(
        (SELECT json_agg(json_build_object(
            'id', sub.id,
            'tag_key', sub.tag_key,
            'display_name_hebrew', sub.display_name_hebrew,
            'display_name_english', CASE
                WHEN $2::text = 'sephardi' AND sub.display_name_english_sephardi IS NOT NULL AND sub.display_name_english_sephardi != ''
                THEN sub.display_name_english_sephardi
                ELSE sub.display_name_english_ashkenazi
            END,
            'tag_type', sub.tag_type,
            'description', sub.description,
            'color', sub.color,
            'sort_order', sub.sort_order,
            'is_negated', sub.is_negated,
            'is_modified', sub.is_modified,
            'source_is_negated', sub.source_is_negated
        ) ORDER BY sub.sort_order)
        FROM (
            -- Publisher-specific tags (if any exist, these take full precedence)
            SELECT t.id, t.tag_key, t.display_name_hebrew,
                   t.display_name_english_ashkenazi, t.display_name_english_sephardi,
                   tt.key AS tag_type, t.description, t.color, tt.sort_order, pzt.is_negated,
                   CASE
                       WHEN mzt.tag_id IS NULL THEN true
                       WHEN pzt.is_negated != mzt.is_negated THEN true
                       ELSE false
                   END AS is_modified,
                   mzt.is_negated AS source_is_negated
            FROM publisher_zman_tags pzt
            JOIN zman_tags t ON pzt.tag_id = t.id
            JOIN tag_types tt ON t.tag_type_id = tt.id
            LEFT JOIN master_zman_tags mzt ON mzt.master_zman_id = pz.master_zman_id
                                            AND mzt.tag_id = pzt.tag_id
            WHERE pzt.publisher_zman_id = pz.id
            UNION ALL
            -- Master tags (only if NO publisher tags exist for this zman)
            SELECT t.id, t.tag_key, t.display_name_hebrew,
                   t.display_name_english_ashkenazi, t.display_name_english_sephardi,
                   tt.key AS tag_type, t.description, t.color, tt.sort_order, mzt.is_negated,
                   false AS is_modified,
                   mzt.is_negated AS source_is_negated
            FROM master_zman_tags mzt
            JOIN zman_tags t ON mzt.tag_id = t.id
            JOIN tag_types tt ON t.tag_type_id = tt.id
            WHERE mzt.master_zman_id = pz.master_zman_id
              AND NOT EXISTS (SELECT 1 FROM publisher_zman_tags WHERE publisher_zman_id = pz.id)
        ) sub),
        '[]'::json
    ) AS tags
FROM publisher_zmanim pz
LEFT JOIN time_categories tc ON pz.time_category_id = tc.id
LEFT JOIN publisher_zmanim linked_pz ON pz.linked_publisher_zman_id = linked_pz.id
LEFT JOIN master_zmanim_registry mzr ON pz.master_zman_id = mzr.id
LEFT JOIN time_categories mr_tc ON mzr.time_category_id = mr_tc.id
WHERE pz.publisher_id = $1
  AND pz.deleted_at IS NULL
  AND pz.is_enabled = true
ORDER BY COALESCE(mr_tc.sort_order, tc.sort_order, 99), pz.hebrew_name
`

type ListPublisherZmanimForReportParams struct {
	PublisherID int32  `json:"publisher_id"`
	Column2     string `json:"column_2"`
}

type ListPublisherZmanimForReportRow struct {
	ID                 int32       `json:"id"`
	ZmanKey            string      `json:"zman_key"`
	HebrewName         string      `json:"hebrew_name"`
	EnglishName        string      `json:"english_name"`
	Description        *string     `json:"description"`
	FormulaDsl         string      `json:"formula_dsl"`
	IsEnabled          bool        `json:"is_enabled"`
	RoundingMode       string      `json:"rounding_mode"`
	MasterZmanID       *int32      `json:"master_zman_id"`
	FormulaExplanation *string     `json:"formula_explanation"`
	Category           *string     `json:"category"`
	Shita              *string     `json:"shita"`
	MasterHebrewName   *string     `json:"master_hebrew_name"`
	MasterEnglishName  *string     `json:"master_english_name"`
	TimeCategory       string      `json:"time_category"`
	SortOrder          int32       `json:"sort_order"`
	IsEventZman        bool        `json:"is_event_zman"`
	Tags               interface{} `json:"tags"`
}

// Fetches all published zmanim with master registry metadata and tags for report
// @param publisher_id: The publisher ID
// @param transliteration_style: 'ashkenazi' (default) or 'sephardi' - controls tag display names
func (q *Queries) ListPublisherZmanimForReport(ctx context.Context, arg ListPublisherZmanimForReportParams) ([]ListPublisherZmanimForReportRow, error) {
	rows, err := q.db.Query(ctx, listPublisherZmanimForReport, arg.PublisherID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPublisherZmanimForReportRow{}
	for rows.Next() {
		var i ListPublisherZmanimForReportRow
		if err := rows.Scan(
			&i.ID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.Description,
			&i.FormulaDsl,
			&i.IsEnabled,
			&i.RoundingMode,
			&i.MasterZmanID,
			&i.FormulaExplanation,
			&i.Category,
			&i.Shita,
			&i.MasterHebrewName,
			&i.MasterEnglishName,
			&i.TimeCategory,
			&i.SortOrder,
			&i.IsEventZman,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publisherHasCoverageForLocality = `-- name: PublisherHasCoverageForLocality :one
SELECT EXISTS(
    SELECT 1
    FROM publisher_coverage pc
    WHERE pc.publisher_id = $1
      AND pc.locality_id = $2
      AND pc.deleted_at IS NULL
) AS has_coverage
`

type PublisherHasCoverageForLocalityParams struct {
	PublisherID int32  `json:"publisher_id"`
	LocalityID  *int32 `json:"locality_id"`
}

// Checks if publisher has coverage for a specific locality
func (q *Queries) PublisherHasCoverageForLocality(ctx context.Context, arg PublisherHasCoverageForLocalityParams) (bool, error) {
	row := q.db.QueryRow(ctx, publisherHasCoverageForLocality, arg.PublisherID, arg.LocalityID)
	var has_coverage bool
	err := row.Scan(&has_coverage)
	return has_coverage, err
}
