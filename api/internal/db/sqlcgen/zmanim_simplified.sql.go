// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: zmanim_simplified.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getPublisherZmanByKeySimplified = `-- name: GetPublisherZmanByKeySimplified :one
SELECT
    pz.id, pz.publisher_id, pz.zman_key, pz.hebrew_name, pz.english_name,
    pz.transliteration, pz.description,
    COALESCE(linked_pz.formula_dsl, pz.formula_dsl) AS formula_dsl,
    pz.ai_explanation, pz.publisher_comment,
    pz.is_enabled, pz.is_visible, pz.is_published, pz.is_beta, pz.is_custom,
    pz.display_status,
    pz.dependencies, pz.created_at, pz.updated_at,
    pz.master_zman_id, pz.linked_publisher_zman_id,
    -- Time category ID and display values
    pz.time_category_id,
    tc.key AS category,
    tc.display_name_hebrew AS category_display_hebrew,
    tc.display_name_english AS category_display_english,
    -- Source/original values from registry or linked publisher (for diff/revert UI)
    COALESCE(mr.canonical_hebrew_name, linked_pz.hebrew_name, '') AS source_hebrew_name,
    COALESCE(mr.canonical_english_name, linked_pz.english_name, '') AS source_english_name,
    COALESCE(mr.transliteration, linked_pz.transliteration) AS source_transliteration,
    COALESCE(mr.description, linked_pz.description) AS source_description,
    COALESCE(mr.default_formula_dsl, linked_pz.formula_dsl, '') AS source_formula_dsl,
    -- Linked source info
    CASE WHEN pz.linked_publisher_zman_id IS NOT NULL THEN true ELSE false END AS is_linked,
    linked_pub.name AS linked_source_publisher_name,
    -- Time category key for consistency
    COALESCE(mr_tc.key, tc.key, 'uncategorized') AS time_category
FROM publisher_zmanim pz
LEFT JOIN time_categories tc ON pz.time_category_id = tc.id
LEFT JOIN publisher_zmanim linked_pz ON pz.linked_publisher_zman_id = linked_pz.id
LEFT JOIN publishers linked_pub ON linked_pz.publisher_id = linked_pub.id
LEFT JOIN master_zmanim_registry mr ON pz.master_zman_id = mr.id
LEFT JOIN time_categories mr_tc ON mr.time_category_id = mr_tc.id
WHERE pz.publisher_id = $1 AND pz.zman_key = $2 AND pz.deleted_at IS NULL
`

type GetPublisherZmanByKeySimplifiedParams struct {
	PublisherID int32  `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

type GetPublisherZmanByKeySimplifiedRow struct {
	ID                        int32              `json:"id"`
	PublisherID               int32              `json:"publisher_id"`
	ZmanKey                   string             `json:"zman_key"`
	HebrewName                string             `json:"hebrew_name"`
	EnglishName               string             `json:"english_name"`
	Transliteration           *string            `json:"transliteration"`
	Description               *string            `json:"description"`
	FormulaDsl                string             `json:"formula_dsl"`
	AiExplanation             *string            `json:"ai_explanation"`
	PublisherComment          *string            `json:"publisher_comment"`
	IsEnabled                 bool               `json:"is_enabled"`
	IsVisible                 bool               `json:"is_visible"`
	IsPublished               bool               `json:"is_published"`
	IsBeta                    bool               `json:"is_beta"`
	IsCustom                  bool               `json:"is_custom"`
	DisplayStatus             DisplayStatus      `json:"display_status"`
	Dependencies              []string           `json:"dependencies"`
	CreatedAt                 pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                 pgtype.Timestamptz `json:"updated_at"`
	MasterZmanID              *int32             `json:"master_zman_id"`
	LinkedPublisherZmanID     *int32             `json:"linked_publisher_zman_id"`
	TimeCategoryID            *int32             `json:"time_category_id"`
	Category                  *string            `json:"category"`
	CategoryDisplayHebrew     *string            `json:"category_display_hebrew"`
	CategoryDisplayEnglish    *string            `json:"category_display_english"`
	SourceHebrewName          string             `json:"source_hebrew_name"`
	SourceEnglishName         string             `json:"source_english_name"`
	SourceTransliteration     *string            `json:"source_transliteration"`
	SourceDescription         *string            `json:"source_description"`
	SourceFormulaDsl          string             `json:"source_formula_dsl"`
	IsLinked                  bool               `json:"is_linked"`
	LinkedSourcePublisherName *string            `json:"linked_source_publisher_name"`
	TimeCategory              string             `json:"time_category"`
}

// Simplified version of GetPublisherZmanByKey without tag aggregation
func (q *Queries) GetPublisherZmanByKeySimplified(ctx context.Context, arg GetPublisherZmanByKeySimplifiedParams) (GetPublisherZmanByKeySimplifiedRow, error) {
	row := q.db.QueryRow(ctx, getPublisherZmanByKeySimplified, arg.PublisherID, arg.ZmanKey)
	var i GetPublisherZmanByKeySimplifiedRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.Transliteration,
		&i.Description,
		&i.FormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsBeta,
		&i.IsCustom,
		&i.DisplayStatus,
		&i.Dependencies,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MasterZmanID,
		&i.LinkedPublisherZmanID,
		&i.TimeCategoryID,
		&i.Category,
		&i.CategoryDisplayHebrew,
		&i.CategoryDisplayEnglish,
		&i.SourceHebrewName,
		&i.SourceEnglishName,
		&i.SourceTransliteration,
		&i.SourceDescription,
		&i.SourceFormulaDsl,
		&i.IsLinked,
		&i.LinkedSourcePublisherName,
		&i.TimeCategory,
	)
	return i, err
}

const getPublisherZmanimSimplified = `-- name: GetPublisherZmanimSimplified :many

SELECT
    pz.id, pz.publisher_id, pz.zman_key, pz.hebrew_name, pz.english_name,
    pz.transliteration, pz.description,
    -- Resolve formula from linked source if applicable
    COALESCE(linked_pz.formula_dsl, pz.formula_dsl) AS formula_dsl,
    pz.ai_explanation, pz.publisher_comment,
    pz.is_enabled, pz.is_visible, pz.is_published, pz.is_beta, pz.is_custom,
    pz.display_status,
    pz.dependencies, pz.created_at, pz.updated_at, pz.deleted_at,
    pz.master_zman_id, pz.linked_publisher_zman_id,
    -- Time category ID and display values
    pz.time_category_id,
    tc.key AS category,
    tc.display_name_hebrew AS category_display_hebrew,
    tc.display_name_english AS category_display_english,
    -- Source/original values from registry or linked publisher (for diff/revert UI)
    COALESCE(mr.canonical_hebrew_name, linked_pz.hebrew_name, '') AS source_hebrew_name,
    COALESCE(mr.canonical_english_name, linked_pz.english_name, '') AS source_english_name,
    COALESCE(mr.transliteration, linked_pz.transliteration) AS source_transliteration,
    COALESCE(mr.description, linked_pz.description) AS source_description,
    COALESCE(mr.default_formula_dsl, linked_pz.formula_dsl, '') AS source_formula_dsl,
    -- Linked source info
    CASE WHEN pz.linked_publisher_zman_id IS NOT NULL THEN true ELSE false END AS is_linked,
    linked_pub.name AS linked_source_publisher_name,
    CASE WHEN pz.linked_publisher_zman_id IS NOT NULL AND linked_pz.deleted_at IS NOT NULL
         THEN true ELSE false END AS linked_source_is_deleted,
    -- Time category key for ordering (from registry or current)
    COALESCE(mr_tc.key, tc.key, 'uncategorized') AS time_category
FROM publisher_zmanim pz
LEFT JOIN time_categories tc ON pz.time_category_id = tc.id
LEFT JOIN publisher_zmanim linked_pz ON pz.linked_publisher_zman_id = linked_pz.id
LEFT JOIN publishers linked_pub ON linked_pz.publisher_id = linked_pub.id
LEFT JOIN master_zmanim_registry mr ON pz.master_zman_id = mr.id
LEFT JOIN time_categories mr_tc ON mr.time_category_id = mr_tc.id
WHERE pz.publisher_id = $1
  AND ($2::boolean = true OR pz.deleted_at IS NULL)
ORDER BY
    COALESCE(mr_tc.sort_order, tc.sort_order, 99),
    pz.hebrew_name
`

type GetPublisherZmanimSimplifiedParams struct {
	PublisherID    int32 `json:"publisher_id"`
	IncludeDeleted *bool `json:"include_deleted"`
}

type GetPublisherZmanimSimplifiedRow struct {
	ID                        int32              `json:"id"`
	PublisherID               int32              `json:"publisher_id"`
	ZmanKey                   string             `json:"zman_key"`
	HebrewName                string             `json:"hebrew_name"`
	EnglishName               string             `json:"english_name"`
	Transliteration           *string            `json:"transliteration"`
	Description               *string            `json:"description"`
	FormulaDsl                string             `json:"formula_dsl"`
	AiExplanation             *string            `json:"ai_explanation"`
	PublisherComment          *string            `json:"publisher_comment"`
	IsEnabled                 bool               `json:"is_enabled"`
	IsVisible                 bool               `json:"is_visible"`
	IsPublished               bool               `json:"is_published"`
	IsBeta                    bool               `json:"is_beta"`
	IsCustom                  bool               `json:"is_custom"`
	DisplayStatus             DisplayStatus      `json:"display_status"`
	Dependencies              []string           `json:"dependencies"`
	CreatedAt                 pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                 pgtype.Timestamptz `json:"updated_at"`
	DeletedAt                 pgtype.Timestamptz `json:"deleted_at"`
	MasterZmanID              *int32             `json:"master_zman_id"`
	LinkedPublisherZmanID     *int32             `json:"linked_publisher_zman_id"`
	TimeCategoryID            *int32             `json:"time_category_id"`
	Category                  *string            `json:"category"`
	CategoryDisplayHebrew     *string            `json:"category_display_hebrew"`
	CategoryDisplayEnglish    *string            `json:"category_display_english"`
	SourceHebrewName          string             `json:"source_hebrew_name"`
	SourceEnglishName         string             `json:"source_english_name"`
	SourceTransliteration     *string            `json:"source_transliteration"`
	SourceDescription         *string            `json:"source_description"`
	SourceFormulaDsl          string             `json:"source_formula_dsl"`
	IsLinked                  bool               `json:"is_linked"`
	LinkedSourcePublisherName *string            `json:"linked_source_publisher_name"`
	LinkedSourceIsDeleted     bool               `json:"linked_source_is_deleted"`
	TimeCategory              string             `json:"time_category"`
}

// File: zmanim_simplified.sql
// Purpose: Simplified publisher zmanim queries (tags fetched separately)
// Pattern: query-decomposition
// Complexity: medium (5 concepts: publisher_zmanim, publishers, master_registry, lookup tables)
// Used by: publisher_zmanim.go handlers
// Note: This is a cleaner alternative to the complex GetPublisherZmanim query
// Simplified version without tag aggregation (tags fetched separately via GetZmanTags)
// Still includes linked source resolution and master registry fallbacks
func (q *Queries) GetPublisherZmanimSimplified(ctx context.Context, arg GetPublisherZmanimSimplifiedParams) ([]GetPublisherZmanimSimplifiedRow, error) {
	rows, err := q.db.Query(ctx, getPublisherZmanimSimplified, arg.PublisherID, arg.IncludeDeleted)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherZmanimSimplifiedRow{}
	for rows.Next() {
		var i GetPublisherZmanimSimplifiedRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.Transliteration,
			&i.Description,
			&i.FormulaDsl,
			&i.AiExplanation,
			&i.PublisherComment,
			&i.IsEnabled,
			&i.IsVisible,
			&i.IsPublished,
			&i.IsBeta,
			&i.IsCustom,
			&i.DisplayStatus,
			&i.Dependencies,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.MasterZmanID,
			&i.LinkedPublisherZmanID,
			&i.TimeCategoryID,
			&i.Category,
			&i.CategoryDisplayHebrew,
			&i.CategoryDisplayEnglish,
			&i.SourceHebrewName,
			&i.SourceEnglishName,
			&i.SourceTransliteration,
			&i.SourceDescription,
			&i.SourceFormulaDsl,
			&i.IsLinked,
			&i.LinkedSourcePublisherName,
			&i.LinkedSourceIsDeleted,
			&i.TimeCategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
