// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tag_events.sql

package sqlcgen

import (
	"context"
)

const countTagsByType = `-- name: CountTagsByType :many
SELECT
    t.tag_type_id,
    tt.key AS tag_type,
    tt.display_name_hebrew AS tag_type_display_hebrew,
    tt.display_name_english AS tag_type_display_english,
    COUNT(*) AS count
FROM zman_tags t
JOIN tag_types tt ON tt.id = t.tag_type_id
GROUP BY t.tag_type_id, tt.key, tt.display_name_hebrew, tt.display_name_english
ORDER BY tt.sort_order
`

type CountTagsByTypeRow struct {
	TagTypeID             int32  `json:"tag_type_id"`
	TagType               string `json:"tag_type"`
	TagTypeDisplayHebrew  string `json:"tag_type_display_hebrew"`
	TagTypeDisplayEnglish string `json:"tag_type_display_english"`
	Count                 int64  `json:"count"`
}

// Get count of tags per type (for UI display)
func (q *Queries) CountTagsByType(ctx context.Context) ([]CountTagsByTypeRow, error) {
	rows, err := q.db.Query(ctx, countTagsByType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountTagsByTypeRow{}
	for rows.Next() {
		var i CountTagsByTypeRow
		if err := rows.Scan(
			&i.TagTypeID,
			&i.TagType,
			&i.TagTypeDisplayHebrew,
			&i.TagTypeDisplayEnglish,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTagsWithKey = `-- name: GetAllTagsWithKey :many




SELECT
    t.id,
    t.tag_key,
    t.display_name_hebrew,
    t.display_name_english_ashkenazi,
    t.display_name_english_sephardi,
    t.tag_type_id,
    tt.key AS tag_type,
    tt.display_name_hebrew AS tag_type_display_hebrew,
    tt.display_name_english AS tag_type_display_english,
    t.description,
    t.color
FROM zman_tags t
JOIN tag_types tt ON tt.id = t.tag_type_id
WHERE t.is_hidden = false
ORDER BY tt.sort_order, t.tag_key, t.display_name_english_ashkenazi
`

type GetAllTagsWithKeyRow struct {
	ID                          int32   `json:"id"`
	TagKey                      string  `json:"tag_key"`
	DisplayNameHebrew           string  `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string  `json:"display_name_english_ashkenazi"`
	DisplayNameEnglishSephardi  *string `json:"display_name_english_sephardi"`
	TagTypeID                   int32   `json:"tag_type_id"`
	TagType                     string  `json:"tag_type"`
	TagTypeDisplayHebrew        string  `json:"tag_type_display_hebrew"`
	TagTypeDisplayEnglish       string  `json:"tag_type_display_english"`
	Description                 *string `json:"description"`
	Color                       *string `json:"color"`
}

// REMOVED: GetTagByHebcalBasename
// The hebcal_basename column has been removed in the new schema
// Use match_hebcal_event() function instead for HebCal event matching
// REMOVED: GetTagsForHebCalEvent
// This query used the old tag_event_mappings table
// Use the match_hebcal_event() PostgreSQL function instead
// REMOVED: GetTagsForHebrewDate
// This query used the old tag_event_mappings table with Hebrew date matching
// Hebrew date matching is now handled via HebCal API integration and match_hebcal_event()
// ============================================================================
// All Tags Queries (with tag_key - extends master_registry.sql queries)
// ============================================================================
// Get all tags ordered by type and sort order (includes tag_key and multilingual names)
// User-facing query - excludes hidden tags
func (q *Queries) GetAllTagsWithKey(ctx context.Context) ([]GetAllTagsWithKeyRow, error) {
	rows, err := q.db.Query(ctx, getAllTagsWithKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllTagsWithKeyRow{}
	for rows.Next() {
		var i GetAllTagsWithKeyRow
		if err := rows.Scan(
			&i.ID,
			&i.TagKey,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglishAshkenazi,
			&i.DisplayNameEnglishSephardi,
			&i.TagTypeID,
			&i.TagType,
			&i.TagTypeDisplayHebrew,
			&i.TagTypeDisplayEnglish,
			&i.Description,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJewishDayTags = `-- name: GetJewishDayTags :many
SELECT
    t.id,
    t.tag_key,
    t.display_name_hebrew,
    t.display_name_english_ashkenazi,
    t.display_name_english_sephardi,
    t.tag_type_id,
    tt.key AS tag_type,
    tt.display_name_hebrew AS tag_type_display_hebrew,
    tt.display_name_english AS tag_type_display_english,
    t.description,
    t.color
FROM zman_tags t
JOIN tag_types tt ON tt.id = t.tag_type_id
WHERE tt.key = 'event' AND t.is_hidden = false
ORDER BY t.tag_key, t.display_name_english_ashkenazi
`

type GetJewishDayTagsRow struct {
	ID                          int32   `json:"id"`
	TagKey                      string  `json:"tag_key"`
	DisplayNameHebrew           string  `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string  `json:"display_name_english_ashkenazi"`
	DisplayNameEnglishSephardi  *string `json:"display_name_english_sephardi"`
	TagTypeID                   int32   `json:"tag_type_id"`
	TagType                     string  `json:"tag_type"`
	TagTypeDisplayHebrew        string  `json:"tag_type_display_hebrew"`
	TagTypeDisplayEnglish       string  `json:"tag_type_display_english"`
	Description                 *string `json:"description"`
	Color                       *string `json:"color"`
}

// Get all event tags that represent Jewish days/holidays (for calendar filtering)
// Note: Jewish day tags are now part of 'event' type after tag consolidation
// User-facing query - excludes hidden tags
func (q *Queries) GetJewishDayTags(ctx context.Context) ([]GetJewishDayTagsRow, error) {
	rows, err := q.db.Query(ctx, getJewishDayTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetJewishDayTagsRow{}
	for rows.Next() {
		var i GetJewishDayTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.TagKey,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglishAshkenazi,
			&i.DisplayNameEnglishSephardi,
			&i.TagTypeID,
			&i.TagType,
			&i.TagTypeDisplayHebrew,
			&i.TagTypeDisplayEnglish,
			&i.Description,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMasterZmanimByTags = `-- name: GetMasterZmanimByTags :many
SELECT DISTINCT
    mr.id,
    mr.zman_key,
    mr.canonical_hebrew_name,
    mr.canonical_english_name,
    mr.default_formula_dsl,
    mr.time_category_id,
    tc.key AS time_category,
    tc.display_name_hebrew AS time_category_display_hebrew,
    tc.display_name_english AS time_category_display_english,
    mr.is_core
FROM master_zmanim_registry mr
LEFT JOIN time_categories tc ON tc.id = mr.time_category_id
JOIN master_zman_tags mzt ON mzt.master_zman_id = mr.id
JOIN zman_tags t ON t.id = mzt.tag_id
WHERE t.tag_key = ANY($1::text[])
  AND mr.is_hidden = false
ORDER BY mr.canonical_hebrew_name
`

type GetMasterZmanimByTagsRow struct {
	ID                         int32   `json:"id"`
	ZmanKey                    string  `json:"zman_key"`
	CanonicalHebrewName        string  `json:"canonical_hebrew_name"`
	CanonicalEnglishName       string  `json:"canonical_english_name"`
	DefaultFormulaDsl          *string `json:"default_formula_dsl"`
	TimeCategoryID             *int32  `json:"time_category_id"`
	TimeCategory               *string `json:"time_category"`
	TimeCategoryDisplayHebrew  *string `json:"time_category_display_hebrew"`
	TimeCategoryDisplayEnglish *string `json:"time_category_display_english"`
	IsCore                     *bool   `json:"is_core"`
}

// Get master registry zmanim that have any of the specified tags
func (q *Queries) GetMasterZmanimByTags(ctx context.Context, dollar_1 []string) ([]GetMasterZmanimByTagsRow, error) {
	rows, err := q.db.Query(ctx, getMasterZmanimByTags, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMasterZmanimByTagsRow{}
	for rows.Next() {
		var i GetMasterZmanimByTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.ZmanKey,
			&i.CanonicalHebrewName,
			&i.CanonicalEnglishName,
			&i.DefaultFormulaDsl,
			&i.TimeCategoryID,
			&i.TimeCategory,
			&i.TimeCategoryDisplayHebrew,
			&i.TimeCategoryDisplayEnglish,
			&i.IsCore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagByKey = `-- name: GetTagByKey :one
SELECT
    t.id,
    t.tag_key,
    t.display_name_hebrew,
    t.display_name_english_ashkenazi,
    t.display_name_english_sephardi,
    t.tag_type_id,
    tt.key AS tag_type,
    tt.display_name_hebrew AS tag_type_display_hebrew,
    tt.display_name_english AS tag_type_display_english,
    t.description,
    t.color
FROM zman_tags t
JOIN tag_types tt ON tt.id = t.tag_type_id
WHERE t.tag_key = $1
`

type GetTagByKeyRow struct {
	ID                          int32   `json:"id"`
	TagKey                      string  `json:"tag_key"`
	DisplayNameHebrew           string  `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string  `json:"display_name_english_ashkenazi"`
	DisplayNameEnglishSephardi  *string `json:"display_name_english_sephardi"`
	TagTypeID                   int32   `json:"tag_type_id"`
	TagType                     string  `json:"tag_type"`
	TagTypeDisplayHebrew        string  `json:"tag_type_display_hebrew"`
	TagTypeDisplayEnglish       string  `json:"tag_type_display_english"`
	Description                 *string `json:"description"`
	Color                       *string `json:"color"`
}

// Get a single tag by its key
func (q *Queries) GetTagByKey(ctx context.Context, tagKey string) (GetTagByKeyRow, error) {
	row := q.db.QueryRow(ctx, getTagByKey, tagKey)
	var i GetTagByKeyRow
	err := row.Scan(
		&i.ID,
		&i.TagKey,
		&i.DisplayNameHebrew,
		&i.DisplayNameEnglishAshkenazi,
		&i.DisplayNameEnglishSephardi,
		&i.TagTypeID,
		&i.TagType,
		&i.TagTypeDisplayHebrew,
		&i.TagTypeDisplayEnglish,
		&i.Description,
		&i.Color,
	)
	return i, err
}

const getTagEventMappings = `-- name: GetTagEventMappings :many


SELECT
    tag_key,
    hebcal_match_type,
    COALESCE(hebcal_match_string, hebcal_match_pattern, hebcal_match_category) AS match_value
FROM zman_tags
WHERE hebcal_match_type IS NOT NULL
ORDER BY
    CASE hebcal_match_type
        WHEN 'category' THEN 1
        WHEN 'exact' THEN 2
        WHEN 'group' THEN 3
    END,
    tag_key
`

type GetTagEventMappingsRow struct {
	TagKey          string              `json:"tag_key"`
	HebcalMatchType NullHebcalMatchType `json:"hebcal_match_type"`
	MatchValue      *string             `json:"match_value"`
}

// Tag Events SQL Queries
// SQLc will generate type-safe Go code from these queries
// ============================================================================
// Tag Event Mappings
// ============================================================================
// Get all HebCal event mappings for tag matching
// Uses new schema where match data is stored directly in zman_tags
func (q *Queries) GetTagEventMappings(ctx context.Context) ([]GetTagEventMappingsRow, error) {
	rows, err := q.db.Query(ctx, getTagEventMappings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTagEventMappingsRow{}
	for rows.Next() {
		var i GetTagEventMappingsRow
		if err := rows.Scan(&i.TagKey, &i.HebcalMatchType, &i.MatchValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsByKeys = `-- name: GetTagsByKeys :many
SELECT
    t.id,
    t.tag_key,
    t.display_name_hebrew,
    t.display_name_english_ashkenazi,
    t.display_name_english_sephardi,
    t.tag_type_id,
    tt.key AS tag_type,
    tt.display_name_hebrew AS tag_type_display_hebrew,
    tt.display_name_english AS tag_type_display_english,
    t.description,
    t.color
FROM zman_tags t
JOIN tag_types tt ON tt.id = t.tag_type_id
WHERE t.tag_key = ANY($1::text[])
ORDER BY t.tag_key, t.display_name_english_ashkenazi
`

type GetTagsByKeysRow struct {
	ID                          int32   `json:"id"`
	TagKey                      string  `json:"tag_key"`
	DisplayNameHebrew           string  `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string  `json:"display_name_english_ashkenazi"`
	DisplayNameEnglishSephardi  *string `json:"display_name_english_sephardi"`
	TagTypeID                   int32   `json:"tag_type_id"`
	TagType                     string  `json:"tag_type"`
	TagTypeDisplayHebrew        string  `json:"tag_type_display_hebrew"`
	TagTypeDisplayEnglish       string  `json:"tag_type_display_english"`
	Description                 *string `json:"description"`
	Color                       *string `json:"color"`
}

// Get multiple tags by their keys
func (q *Queries) GetTagsByKeys(ctx context.Context, dollar_1 []string) ([]GetTagsByKeysRow, error) {
	rows, err := q.db.Query(ctx, getTagsByKeys, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTagsByKeysRow{}
	for rows.Next() {
		var i GetTagsByKeysRow
		if err := rows.Scan(
			&i.ID,
			&i.TagKey,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglishAshkenazi,
			&i.DisplayNameEnglishSephardi,
			&i.TagTypeID,
			&i.TagType,
			&i.TagTypeDisplayHebrew,
			&i.TagTypeDisplayEnglish,
			&i.Description,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getZmanimByActiveTags = `-- name: GetZmanimByActiveTags :many



SELECT DISTINCT
    pz.id,
    pz.publisher_id,
    pz.zman_key,
    pz.hebrew_name,
    pz.english_name,
    pz.formula_dsl,
    pz.is_enabled,
    pz.is_published,
    pz.time_category_id,
    tc.key AS category,
    tc.display_name_hebrew AS category_display_hebrew,
    tc.display_name_english AS category_display_english
FROM publisher_zmanim pz
JOIN time_categories tc ON tc.id = pz.time_category_id
JOIN publisher_zman_tags pzt ON pzt.publisher_zman_id = pz.id
JOIN zman_tags t ON t.id = pzt.tag_id
WHERE pz.publisher_id = $1
  AND t.tag_key = ANY($2::text[])
  AND pz.deleted_at IS NULL
  AND pz.is_enabled = true
ORDER BY pz.hebrew_name
`

type GetZmanimByActiveTagsParams struct {
	PublisherID int32    `json:"publisher_id"`
	Column2     []string `json:"column_2"`
}

type GetZmanimByActiveTagsRow struct {
	ID                     int32  `json:"id"`
	PublisherID            int32  `json:"publisher_id"`
	ZmanKey                string `json:"zman_key"`
	HebrewName             string `json:"hebrew_name"`
	EnglishName            string `json:"english_name"`
	FormulaDsl             string `json:"formula_dsl"`
	IsEnabled              bool   `json:"is_enabled"`
	IsPublished            bool   `json:"is_published"`
	TimeCategoryID         *int32 `json:"time_category_id"`
	Category               string `json:"category"`
	CategoryDisplayHebrew  string `json:"category_display_hebrew"`
	CategoryDisplayEnglish string `json:"category_display_english"`
}

// ============================================================================
// Tag Types Metadata
// ============================================================================
// Removed: Duplicate of GetTagTypes in lookups.sql
// ============================================================================
// Publisher Zmanim by Active Tags
// ============================================================================
// Get publisher zmanim that have any of the specified tags (for calendar day filtering)
func (q *Queries) GetZmanimByActiveTags(ctx context.Context, arg GetZmanimByActiveTagsParams) ([]GetZmanimByActiveTagsRow, error) {
	rows, err := q.db.Query(ctx, getZmanimByActiveTags, arg.PublisherID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetZmanimByActiveTagsRow{}
	for rows.Next() {
		var i GetZmanimByActiveTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.FormulaDsl,
			&i.IsEnabled,
			&i.IsPublished,
			&i.TimeCategoryID,
			&i.Category,
			&i.CategoryDisplayHebrew,
			&i.CategoryDisplayEnglish,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const matchHebcalEvent = `-- name: MatchHebcalEvent :many

SELECT
    t.id,
    t.tag_key,
    t.display_name_hebrew,
    t.display_name_english_ashkenazi,
    t.display_name_english_sephardi,
    t.tag_type_id,
    tt.key AS tag_type,
    tt.display_name_hebrew AS tag_type_display_hebrew,
    tt.display_name_english AS tag_type_display_english,
    t.description,
    t.color,
    t.hebcal_match_type AS match_type
FROM match_hebcal_event($1, $2) m
JOIN zman_tags t ON t.id = m.tag_id
JOIN tag_types tt ON tt.id = t.tag_type_id
`

type MatchHebcalEventParams struct {
	HebcalTitle    string `json:"hebcal_title"`
	HebcalCategory string `json:"hebcal_category"`
}

type MatchHebcalEventRow struct {
	ID                          int32               `json:"id"`
	TagKey                      string              `json:"tag_key"`
	DisplayNameHebrew           string              `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string              `json:"display_name_english_ashkenazi"`
	DisplayNameEnglishSephardi  *string             `json:"display_name_english_sephardi"`
	TagTypeID                   int32               `json:"tag_type_id"`
	TagType                     string              `json:"tag_type"`
	TagTypeDisplayHebrew        string              `json:"tag_type_display_hebrew"`
	TagTypeDisplayEnglish       string              `json:"tag_type_display_english"`
	Description                 *string             `json:"description"`
	Color                       *string             `json:"color"`
	MatchType                   NullHebcalMatchType `json:"match_type"`
}

// ============================================================================
// Event Mapping Queries
// ============================================================================
// Get the best matching tag for a HebCal event using the PostgreSQL function
// This wraps the match_hebcal_event() function for use with SQLc
// Returns tag details including display names for matched events
func (q *Queries) MatchHebcalEvent(ctx context.Context, arg MatchHebcalEventParams) ([]MatchHebcalEventRow, error) {
	rows, err := q.db.Query(ctx, matchHebcalEvent, arg.HebcalTitle, arg.HebcalCategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MatchHebcalEventRow{}
	for rows.Next() {
		var i MatchHebcalEventRow
		if err := rows.Scan(
			&i.ID,
			&i.TagKey,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglishAshkenazi,
			&i.DisplayNameEnglishSephardi,
			&i.TagTypeID,
			&i.TagType,
			&i.TagTypeDisplayHebrew,
			&i.TagTypeDisplayEnglish,
			&i.Description,
			&i.Color,
			&i.MatchType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
