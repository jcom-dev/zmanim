// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tag_events.sql

package sqlcgen

import (
	"context"
)

const countTagsByType = `-- name: CountTagsByType :many
SELECT
    t.tag_type_id,
    tt.key AS tag_type,
    tt.display_name_hebrew AS tag_type_display_hebrew,
    tt.display_name_english AS tag_type_display_english,
    COUNT(*) AS count
FROM zman_tags t
JOIN tag_types tt ON tt.id = t.tag_type_id
GROUP BY t.tag_type_id, tt.key, tt.display_name_hebrew, tt.display_name_english
ORDER BY tt.sort_order
`

type CountTagsByTypeRow struct {
	TagTypeID             int32  `json:"tag_type_id"`
	TagType               string `json:"tag_type"`
	TagTypeDisplayHebrew  string `json:"tag_type_display_hebrew"`
	TagTypeDisplayEnglish string `json:"tag_type_display_english"`
	Count                 int64  `json:"count"`
}

// Get count of tags per type (for UI display)
func (q *Queries) CountTagsByType(ctx context.Context) ([]CountTagsByTypeRow, error) {
	rows, err := q.db.Query(ctx, countTagsByType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountTagsByTypeRow{}
	for rows.Next() {
		var i CountTagsByTypeRow
		if err := rows.Scan(
			&i.TagTypeID,
			&i.TagType,
			&i.TagTypeDisplayHebrew,
			&i.TagTypeDisplayEnglish,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTagsWithKey = `-- name: GetAllTagsWithKey :many

SELECT
    t.id,
    t.tag_key,
    t.name,
    t.display_name_hebrew,
    t.display_name_english_ashkenazi,
    t.display_name_english_sephardi,
    t.hebcal_basename,
    t.tag_type_id,
    tt.key AS tag_type,
    tt.display_name_hebrew AS tag_type_display_hebrew,
    tt.display_name_english AS tag_type_display_english,
    t.description,
    t.color,
    t.sort_order
FROM zman_tags t
JOIN tag_types tt ON tt.id = t.tag_type_id
ORDER BY tt.sort_order, t.sort_order, t.display_name_english_ashkenazi
`

type GetAllTagsWithKeyRow struct {
	ID                          int32   `json:"id"`
	TagKey                      string  `json:"tag_key"`
	Name                        string  `json:"name"`
	DisplayNameHebrew           string  `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string  `json:"display_name_english_ashkenazi"`
	DisplayNameEnglishSephardi  *string `json:"display_name_english_sephardi"`
	HebcalBasename              *string `json:"hebcal_basename"`
	TagTypeID                   int32   `json:"tag_type_id"`
	TagType                     string  `json:"tag_type"`
	TagTypeDisplayHebrew        string  `json:"tag_type_display_hebrew"`
	TagTypeDisplayEnglish       string  `json:"tag_type_display_english"`
	Description                 *string `json:"description"`
	Color                       *string `json:"color"`
	SortOrder                   *int32  `json:"sort_order"`
}

// ============================================================================
// All Tags Queries (with tag_key - extends master_registry.sql queries)
// ============================================================================
// Get all tags ordered by type and sort order (includes tag_key and multilingual names)
func (q *Queries) GetAllTagsWithKey(ctx context.Context) ([]GetAllTagsWithKeyRow, error) {
	rows, err := q.db.Query(ctx, getAllTagsWithKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllTagsWithKeyRow{}
	for rows.Next() {
		var i GetAllTagsWithKeyRow
		if err := rows.Scan(
			&i.ID,
			&i.TagKey,
			&i.Name,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglishAshkenazi,
			&i.DisplayNameEnglishSephardi,
			&i.HebcalBasename,
			&i.TagTypeID,
			&i.TagType,
			&i.TagTypeDisplayHebrew,
			&i.TagTypeDisplayEnglish,
			&i.Description,
			&i.Color,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJewishDayTags = `-- name: GetJewishDayTags :many
SELECT
    t.id,
    t.tag_key,
    t.name,
    t.display_name_hebrew,
    t.display_name_english_ashkenazi,
    t.display_name_english_sephardi,
    t.hebcal_basename,
    t.tag_type_id,
    tt.key AS tag_type,
    tt.display_name_hebrew AS tag_type_display_hebrew,
    tt.display_name_english AS tag_type_display_english,
    t.description,
    t.color,
    t.sort_order
FROM zman_tags t
JOIN tag_types tt ON tt.id = t.tag_type_id
WHERE tt.key = 'event'
ORDER BY t.sort_order, t.display_name_english_ashkenazi
`

type GetJewishDayTagsRow struct {
	ID                          int32   `json:"id"`
	TagKey                      string  `json:"tag_key"`
	Name                        string  `json:"name"`
	DisplayNameHebrew           string  `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string  `json:"display_name_english_ashkenazi"`
	DisplayNameEnglishSephardi  *string `json:"display_name_english_sephardi"`
	HebcalBasename              *string `json:"hebcal_basename"`
	TagTypeID                   int32   `json:"tag_type_id"`
	TagType                     string  `json:"tag_type"`
	TagTypeDisplayHebrew        string  `json:"tag_type_display_hebrew"`
	TagTypeDisplayEnglish       string  `json:"tag_type_display_english"`
	Description                 *string `json:"description"`
	Color                       *string `json:"color"`
	SortOrder                   *int32  `json:"sort_order"`
}

// Get all event tags that represent Jewish days/holidays (for calendar filtering)
// Note: Jewish day tags are now part of 'event' type after tag consolidation
func (q *Queries) GetJewishDayTags(ctx context.Context) ([]GetJewishDayTagsRow, error) {
	rows, err := q.db.Query(ctx, getJewishDayTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetJewishDayTagsRow{}
	for rows.Next() {
		var i GetJewishDayTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.TagKey,
			&i.Name,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglishAshkenazi,
			&i.DisplayNameEnglishSephardi,
			&i.HebcalBasename,
			&i.TagTypeID,
			&i.TagType,
			&i.TagTypeDisplayHebrew,
			&i.TagTypeDisplayEnglish,
			&i.Description,
			&i.Color,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMasterZmanimByTags = `-- name: GetMasterZmanimByTags :many
SELECT DISTINCT
    mr.id,
    mr.zman_key,
    mr.canonical_hebrew_name,
    mr.canonical_english_name,
    mr.default_formula_dsl,
    mr.time_category_id,
    tc.key AS time_category,
    tc.display_name_hebrew AS time_category_display_hebrew,
    tc.display_name_english AS time_category_display_english,
    mr.is_core
FROM master_zmanim_registry mr
LEFT JOIN time_categories tc ON tc.id = mr.time_category_id
JOIN master_zman_tags mzt ON mzt.master_zman_id = mr.id
JOIN zman_tags t ON t.id = mzt.tag_id
WHERE t.tag_key = ANY($1::text[])
  AND mr.is_hidden = false
ORDER BY mr.canonical_hebrew_name
`

type GetMasterZmanimByTagsRow struct {
	ID                         int32   `json:"id"`
	ZmanKey                    string  `json:"zman_key"`
	CanonicalHebrewName        string  `json:"canonical_hebrew_name"`
	CanonicalEnglishName       string  `json:"canonical_english_name"`
	DefaultFormulaDsl          *string `json:"default_formula_dsl"`
	TimeCategoryID             *int32  `json:"time_category_id"`
	TimeCategory               *string `json:"time_category"`
	TimeCategoryDisplayHebrew  *string `json:"time_category_display_hebrew"`
	TimeCategoryDisplayEnglish *string `json:"time_category_display_english"`
	IsCore                     *bool   `json:"is_core"`
}

// Get master registry zmanim that have any of the specified tags
func (q *Queries) GetMasterZmanimByTags(ctx context.Context, dollar_1 []string) ([]GetMasterZmanimByTagsRow, error) {
	rows, err := q.db.Query(ctx, getMasterZmanimByTags, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMasterZmanimByTagsRow{}
	for rows.Next() {
		var i GetMasterZmanimByTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.ZmanKey,
			&i.CanonicalHebrewName,
			&i.CanonicalEnglishName,
			&i.DefaultFormulaDsl,
			&i.TimeCategoryID,
			&i.TimeCategory,
			&i.TimeCategoryDisplayHebrew,
			&i.TimeCategoryDisplayEnglish,
			&i.IsCore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagByHebcalBasename = `-- name: GetTagByHebcalBasename :one
SELECT
    t.id,
    t.tag_key,
    t.name,
    t.display_name_hebrew,
    t.display_name_english_ashkenazi,
    t.display_name_english_sephardi,
    t.hebcal_basename,
    t.tag_type_id,
    tt.key AS tag_type,
    t.description,
    t.sort_order
FROM zman_tags t
JOIN tag_types tt ON tt.id = t.tag_type_id
WHERE t.hebcal_basename = $1
`

type GetTagByHebcalBasenameRow struct {
	ID                          int32   `json:"id"`
	TagKey                      string  `json:"tag_key"`
	Name                        string  `json:"name"`
	DisplayNameHebrew           string  `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string  `json:"display_name_english_ashkenazi"`
	DisplayNameEnglishSephardi  *string `json:"display_name_english_sephardi"`
	HebcalBasename              *string `json:"hebcal_basename"`
	TagTypeID                   int32   `json:"tag_type_id"`
	TagType                     string  `json:"tag_type"`
	Description                 *string `json:"description"`
	SortOrder                   *int32  `json:"sort_order"`
}

// Direct lookup by Hebcal basename (e.g., "Shavuot" -> shavuos tag)
func (q *Queries) GetTagByHebcalBasename(ctx context.Context, hebcalBasename *string) (GetTagByHebcalBasenameRow, error) {
	row := q.db.QueryRow(ctx, getTagByHebcalBasename, hebcalBasename)
	var i GetTagByHebcalBasenameRow
	err := row.Scan(
		&i.ID,
		&i.TagKey,
		&i.Name,
		&i.DisplayNameHebrew,
		&i.DisplayNameEnglishAshkenazi,
		&i.DisplayNameEnglishSephardi,
		&i.HebcalBasename,
		&i.TagTypeID,
		&i.TagType,
		&i.Description,
		&i.SortOrder,
	)
	return i, err
}

const getTagByKey = `-- name: GetTagByKey :one
SELECT
    t.id,
    t.tag_key,
    t.name,
    t.display_name_hebrew,
    t.display_name_english_ashkenazi,
    t.display_name_english_sephardi,
    t.hebcal_basename,
    t.tag_type_id,
    tt.key AS tag_type,
    tt.display_name_hebrew AS tag_type_display_hebrew,
    tt.display_name_english AS tag_type_display_english,
    t.description,
    t.color,
    t.sort_order
FROM zman_tags t
JOIN tag_types tt ON tt.id = t.tag_type_id
WHERE t.tag_key = $1
`

type GetTagByKeyRow struct {
	ID                          int32   `json:"id"`
	TagKey                      string  `json:"tag_key"`
	Name                        string  `json:"name"`
	DisplayNameHebrew           string  `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string  `json:"display_name_english_ashkenazi"`
	DisplayNameEnglishSephardi  *string `json:"display_name_english_sephardi"`
	HebcalBasename              *string `json:"hebcal_basename"`
	TagTypeID                   int32   `json:"tag_type_id"`
	TagType                     string  `json:"tag_type"`
	TagTypeDisplayHebrew        string  `json:"tag_type_display_hebrew"`
	TagTypeDisplayEnglish       string  `json:"tag_type_display_english"`
	Description                 *string `json:"description"`
	Color                       *string `json:"color"`
	SortOrder                   *int32  `json:"sort_order"`
}

// Get a single tag by its key
func (q *Queries) GetTagByKey(ctx context.Context, tagKey string) (GetTagByKeyRow, error) {
	row := q.db.QueryRow(ctx, getTagByKey, tagKey)
	var i GetTagByKeyRow
	err := row.Scan(
		&i.ID,
		&i.TagKey,
		&i.Name,
		&i.DisplayNameHebrew,
		&i.DisplayNameEnglishAshkenazi,
		&i.DisplayNameEnglishSephardi,
		&i.HebcalBasename,
		&i.TagTypeID,
		&i.TagType,
		&i.TagTypeDisplayHebrew,
		&i.TagTypeDisplayEnglish,
		&i.Description,
		&i.Color,
		&i.SortOrder,
	)
	return i, err
}

const getTagEventMappings = `-- name: GetTagEventMappings :many


SELECT
    t.tag_key,
    t.hebcal_basename,
    m.hebcal_event_pattern AS pattern,
    m.priority
FROM tag_event_mappings m
JOIN zman_tags t ON t.id = m.tag_id
WHERE m.hebcal_event_pattern IS NOT NULL
ORDER BY m.priority DESC
`

type GetTagEventMappingsRow struct {
	TagKey         string  `json:"tag_key"`
	HebcalBasename *string `json:"hebcal_basename"`
	Pattern        *string `json:"pattern"`
	Priority       *int32  `json:"priority"`
}

// Tag Events SQL Queries
// SQLc will generate type-safe Go code from these queries
// ============================================================================
// Tag Event Mappings
// ============================================================================
// Get all HebCal event mappings for tag matching
func (q *Queries) GetTagEventMappings(ctx context.Context) ([]GetTagEventMappingsRow, error) {
	rows, err := q.db.Query(ctx, getTagEventMappings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTagEventMappingsRow{}
	for rows.Next() {
		var i GetTagEventMappingsRow
		if err := rows.Scan(
			&i.TagKey,
			&i.HebcalBasename,
			&i.Pattern,
			&i.Priority,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsByKeys = `-- name: GetTagsByKeys :many
SELECT
    t.id,
    t.tag_key,
    t.name,
    t.display_name_hebrew,
    t.display_name_english_ashkenazi,
    t.display_name_english_sephardi,
    t.hebcal_basename,
    t.tag_type_id,
    tt.key AS tag_type,
    tt.display_name_hebrew AS tag_type_display_hebrew,
    tt.display_name_english AS tag_type_display_english,
    t.description,
    t.color,
    t.sort_order
FROM zman_tags t
JOIN tag_types tt ON tt.id = t.tag_type_id
WHERE t.tag_key = ANY($1::text[])
ORDER BY t.sort_order, t.display_name_english_ashkenazi
`

type GetTagsByKeysRow struct {
	ID                          int32   `json:"id"`
	TagKey                      string  `json:"tag_key"`
	Name                        string  `json:"name"`
	DisplayNameHebrew           string  `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string  `json:"display_name_english_ashkenazi"`
	DisplayNameEnglishSephardi  *string `json:"display_name_english_sephardi"`
	HebcalBasename              *string `json:"hebcal_basename"`
	TagTypeID                   int32   `json:"tag_type_id"`
	TagType                     string  `json:"tag_type"`
	TagTypeDisplayHebrew        string  `json:"tag_type_display_hebrew"`
	TagTypeDisplayEnglish       string  `json:"tag_type_display_english"`
	Description                 *string `json:"description"`
	Color                       *string `json:"color"`
	SortOrder                   *int32  `json:"sort_order"`
}

// Get multiple tags by their keys
func (q *Queries) GetTagsByKeys(ctx context.Context, dollar_1 []string) ([]GetTagsByKeysRow, error) {
	rows, err := q.db.Query(ctx, getTagsByKeys, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTagsByKeysRow{}
	for rows.Next() {
		var i GetTagsByKeysRow
		if err := rows.Scan(
			&i.ID,
			&i.TagKey,
			&i.Name,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglishAshkenazi,
			&i.DisplayNameEnglishSephardi,
			&i.HebcalBasename,
			&i.TagTypeID,
			&i.TagType,
			&i.TagTypeDisplayHebrew,
			&i.TagTypeDisplayEnglish,
			&i.Description,
			&i.Color,
			&i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsForHebCalEvent = `-- name: GetTagsForHebCalEvent :many
SELECT DISTINCT
    t.id,
    t.tag_key,
    t.name,
    t.display_name_hebrew,
    t.display_name_english_ashkenazi,
    t.display_name_english_sephardi,
    t.hebcal_basename,
    t.tag_type_id,
    tt.key AS tag_type,
    tt.display_name_hebrew AS tag_type_display_hebrew,
    tt.display_name_english AS tag_type_display_english,
    t.description,
    t.sort_order,
    m.priority
FROM zman_tags t
JOIN tag_types tt ON tt.id = t.tag_type_id
JOIN tag_event_mappings m ON m.tag_id = t.id
WHERE m.hebcal_event_pattern IS NOT NULL
  AND (
    $1 LIKE m.hebcal_event_pattern OR
    m.hebcal_event_pattern LIKE $1 OR
    -- Handle wildcards: convert % to pattern matching
    $1 LIKE REPLACE(m.hebcal_event_pattern, '%', '')::text || '%' OR
    $1 LIKE '%' || REPLACE(m.hebcal_event_pattern, '%', '')::text
  )
ORDER BY m.priority DESC, t.sort_order
`

type GetTagsForHebCalEventRow struct {
	ID                          int32   `json:"id"`
	TagKey                      string  `json:"tag_key"`
	Name                        string  `json:"name"`
	DisplayNameHebrew           string  `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string  `json:"display_name_english_ashkenazi"`
	DisplayNameEnglishSephardi  *string `json:"display_name_english_sephardi"`
	HebcalBasename              *string `json:"hebcal_basename"`
	TagTypeID                   int32   `json:"tag_type_id"`
	TagType                     string  `json:"tag_type"`
	TagTypeDisplayHebrew        string  `json:"tag_type_display_hebrew"`
	TagTypeDisplayEnglish       string  `json:"tag_type_display_english"`
	Description                 *string `json:"description"`
	SortOrder                   *int32  `json:"sort_order"`
	Priority                    *int32  `json:"priority"`
}

// Get tags that match a specific HebCal event name using pattern matching
// The pattern supports SQL LIKE wildcards (%)
func (q *Queries) GetTagsForHebCalEvent(ctx context.Context, hebcalEventPattern *string) ([]GetTagsForHebCalEventRow, error) {
	rows, err := q.db.Query(ctx, getTagsForHebCalEvent, hebcalEventPattern)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTagsForHebCalEventRow{}
	for rows.Next() {
		var i GetTagsForHebCalEventRow
		if err := rows.Scan(
			&i.ID,
			&i.TagKey,
			&i.Name,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglishAshkenazi,
			&i.DisplayNameEnglishSephardi,
			&i.HebcalBasename,
			&i.TagTypeID,
			&i.TagType,
			&i.TagTypeDisplayHebrew,
			&i.TagTypeDisplayEnglish,
			&i.Description,
			&i.SortOrder,
			&i.Priority,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsForHebrewDate = `-- name: GetTagsForHebrewDate :many
SELECT DISTINCT
    t.id,
    t.tag_key,
    t.name,
    t.display_name_hebrew,
    t.display_name_english_ashkenazi,
    t.display_name_english_sephardi,
    t.hebcal_basename,
    t.tag_type_id,
    tt.key AS tag_type,
    tt.display_name_hebrew AS tag_type_display_hebrew,
    tt.display_name_english AS tag_type_display_english,
    t.description,
    t.sort_order,
    m.priority
FROM zman_tags t
JOIN tag_types tt ON tt.id = t.tag_type_id
JOIN tag_event_mappings m ON m.tag_id = t.id
WHERE m.hebrew_month = $1
  AND $2 BETWEEN m.hebrew_day_start AND COALESCE(m.hebrew_day_end, m.hebrew_day_start)
ORDER BY m.priority DESC, t.sort_order
`

type GetTagsForHebrewDateParams struct {
	HebrewMonth    *int32 `json:"hebrew_month"`
	HebrewDayStart *int32 `json:"hebrew_day_start"`
}

type GetTagsForHebrewDateRow struct {
	ID                          int32   `json:"id"`
	TagKey                      string  `json:"tag_key"`
	Name                        string  `json:"name"`
	DisplayNameHebrew           string  `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string  `json:"display_name_english_ashkenazi"`
	DisplayNameEnglishSephardi  *string `json:"display_name_english_sephardi"`
	HebcalBasename              *string `json:"hebcal_basename"`
	TagTypeID                   int32   `json:"tag_type_id"`
	TagType                     string  `json:"tag_type"`
	TagTypeDisplayHebrew        string  `json:"tag_type_display_hebrew"`
	TagTypeDisplayEnglish       string  `json:"tag_type_display_english"`
	Description                 *string `json:"description"`
	SortOrder                   *int32  `json:"sort_order"`
	Priority                    *int32  `json:"priority"`
}

// Get tags that match a specific Hebrew date (month and day)
func (q *Queries) GetTagsForHebrewDate(ctx context.Context, arg GetTagsForHebrewDateParams) ([]GetTagsForHebrewDateRow, error) {
	rows, err := q.db.Query(ctx, getTagsForHebrewDate, arg.HebrewMonth, arg.HebrewDayStart)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTagsForHebrewDateRow{}
	for rows.Next() {
		var i GetTagsForHebrewDateRow
		if err := rows.Scan(
			&i.ID,
			&i.TagKey,
			&i.Name,
			&i.DisplayNameHebrew,
			&i.DisplayNameEnglishAshkenazi,
			&i.DisplayNameEnglishSephardi,
			&i.HebcalBasename,
			&i.TagTypeID,
			&i.TagType,
			&i.TagTypeDisplayHebrew,
			&i.TagTypeDisplayEnglish,
			&i.Description,
			&i.SortOrder,
			&i.Priority,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getZmanimByActiveTags = `-- name: GetZmanimByActiveTags :many



SELECT DISTINCT
    pz.id,
    pz.publisher_id,
    pz.zman_key,
    pz.hebrew_name,
    pz.english_name,
    pz.formula_dsl,
    pz.is_enabled,
    pz.is_published,
    pz.time_category_id,
    tc.key AS category,
    tc.display_name_hebrew AS category_display_hebrew,
    tc.display_name_english AS category_display_english
FROM publisher_zmanim pz
JOIN time_categories tc ON tc.id = pz.time_category_id
JOIN publisher_zman_tags pzt ON pzt.publisher_zman_id = pz.id
JOIN zman_tags t ON t.id = pzt.tag_id
WHERE pz.publisher_id = $1
  AND t.tag_key = ANY($2::text[])
  AND pz.deleted_at IS NULL
  AND pz.is_enabled = true
ORDER BY pz.hebrew_name
`

type GetZmanimByActiveTagsParams struct {
	PublisherID int32    `json:"publisher_id"`
	Column2     []string `json:"column_2"`
}

type GetZmanimByActiveTagsRow struct {
	ID                     int32  `json:"id"`
	PublisherID            int32  `json:"publisher_id"`
	ZmanKey                string `json:"zman_key"`
	HebrewName             string `json:"hebrew_name"`
	EnglishName            string `json:"english_name"`
	FormulaDsl             string `json:"formula_dsl"`
	IsEnabled              bool   `json:"is_enabled"`
	IsPublished            bool   `json:"is_published"`
	TimeCategoryID         *int32 `json:"time_category_id"`
	Category               string `json:"category"`
	CategoryDisplayHebrew  string `json:"category_display_hebrew"`
	CategoryDisplayEnglish string `json:"category_display_english"`
}

// ============================================================================
// Tag Types Metadata
// ============================================================================
// Removed: Duplicate of GetTagTypes in lookups.sql
// ============================================================================
// Publisher Zmanim by Active Tags
// ============================================================================
// Get publisher zmanim that have any of the specified tags (for calendar day filtering)
func (q *Queries) GetZmanimByActiveTags(ctx context.Context, arg GetZmanimByActiveTagsParams) ([]GetZmanimByActiveTagsRow, error) {
	rows, err := q.db.Query(ctx, getZmanimByActiveTags, arg.PublisherID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetZmanimByActiveTagsRow{}
	for rows.Next() {
		var i GetZmanimByActiveTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.FormulaDsl,
			&i.IsEnabled,
			&i.IsPublished,
			&i.TimeCategoryID,
			&i.Category,
			&i.CategoryDisplayHebrew,
			&i.CategoryDisplayEnglish,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
