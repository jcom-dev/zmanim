// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: actions.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const completeAction = `-- name: CompleteAction :exec
UPDATE public.actions
SET
    status = $2,           -- 'completed' or 'failed'
    result = $3,           -- result JSON
    error_message = $4,    -- error message if failed
    completed_at = now(),
    duration_ms = EXTRACT(EPOCH FROM (now() - started_at))::integer * 1000
WHERE id = $1
`

type CompleteActionParams struct {
	ID           string  `json:"id"`
	Status       *string `json:"status"`
	Result       []byte  `json:"result"`
	ErrorMessage *string `json:"error_message"`
}

// Marks an action as completed with result data
func (q *Queries) CompleteAction(ctx context.Context, arg CompleteActionParams) error {
	_, err := q.db.Exec(ctx, completeAction,
		arg.ID,
		arg.Status,
		arg.Result,
		arg.ErrorMessage,
	)
	return err
}

const countAdminAuditLog = `-- name: CountAdminAuditLog :one
SELECT COUNT(*)::bigint
FROM public.actions
WHERE
    action_type LIKE 'admin_%'
    AND ($1::text IS NULL OR action_type = $1)
    AND ($2::text IS NULL OR user_id = $2)
    AND ($3::timestamptz IS NULL OR started_at >= $3)
    AND ($4::timestamptz IS NULL OR started_at <= $4)
`

type CountAdminAuditLogParams struct {
	ActionTypeFilter *string            `json:"action_type_filter"`
	UserIDFilter     *string            `json:"user_id_filter"`
	StartDate        pgtype.Timestamptz `json:"start_date"`
	EndDate          pgtype.Timestamptz `json:"end_date"`
}

// Returns count for pagination
func (q *Queries) CountAdminAuditLog(ctx context.Context, arg CountAdminAuditLogParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAdminAuditLog,
		arg.ActionTypeFilter,
		arg.UserIDFilter,
		arg.StartDate,
		arg.EndDate,
	)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const getActionChain = `-- name: GetActionChain :many
WITH RECURSIVE action_chain AS (
    -- Base case: starting action
    SELECT
        a.id,
        a.action_type,
        a.concept,
        a.parent_action_id,
        a.entity_type,
        a.entity_id,
        a.status,
        a.started_at,
        a.completed_at,
        1 AS depth
    FROM public.actions a
    WHERE a.id = $1

    UNION ALL

    -- Recursive case: child actions
    SELECT
        a.id,
        a.action_type,
        a.concept,
        a.parent_action_id,
        a.entity_type,
        a.entity_id,
        a.status,
        a.started_at,
        a.completed_at,
        ac.depth + 1
    FROM public.actions a
    INNER JOIN action_chain ac ON a.parent_action_id = ac.id AND ac.id != a.id
)
SELECT id, action_type, concept, parent_action_id, entity_type, entity_id, status, started_at, completed_at, depth FROM action_chain
ORDER BY depth ASC, started_at ASC
`

type GetActionChainRow struct {
	ID             string             `json:"id"`
	ActionType     string             `json:"action_type"`
	Concept        string             `json:"concept"`
	ParentActionID pgtype.UUID        `json:"parent_action_id"`
	EntityType     *string            `json:"entity_type"`
	EntityID       *string            `json:"entity_id"`
	Status         *string            `json:"status"`
	StartedAt      pgtype.Timestamptz `json:"started_at"`
	CompletedAt    pgtype.Timestamptz `json:"completed_at"`
	Depth          int32              `json:"depth"`
}

// Retrieves causal chain for an action (parent â†’ child actions)
func (q *Queries) GetActionChain(ctx context.Context, id string) ([]GetActionChainRow, error) {
	rows, err := q.db.Query(ctx, getActionChain, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActionChainRow{}
	for rows.Next() {
		var i GetActionChainRow
		if err := rows.Scan(
			&i.ID,
			&i.ActionType,
			&i.Concept,
			&i.ParentActionID,
			&i.EntityType,
			&i.EntityID,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Depth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActionsByRequest = `-- name: GetActionsByRequest :many
SELECT
    id,
    action_type,
    concept,
    user_id,
    publisher_id,
    request_id,
    parent_action_id,
    entity_type,
    entity_id,
    payload,
    result,
    status,
    error_message,
    started_at,
    completed_at,
    duration_ms,
    metadata
FROM public.actions
WHERE request_id = $1
ORDER BY started_at ASC
`

// Retrieves all actions for a given request ID (for debugging/audit)
func (q *Queries) GetActionsByRequest(ctx context.Context, requestID string) ([]Action, error) {
	rows, err := q.db.Query(ctx, getActionsByRequest, requestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Action{}
	for rows.Next() {
		var i Action
		if err := rows.Scan(
			&i.ID,
			&i.ActionType,
			&i.Concept,
			&i.UserID,
			&i.PublisherID,
			&i.RequestID,
			&i.ParentActionID,
			&i.EntityType,
			&i.EntityID,
			&i.Payload,
			&i.Result,
			&i.Status,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DurationMs,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAdminAuditLog = `-- name: GetAdminAuditLog :many
SELECT
    id,
    action_type,
    concept,
    user_id,
    publisher_id,
    request_id,
    entity_type,
    entity_id,
    payload,
    result,
    status,
    error_message,
    started_at,
    completed_at,
    duration_ms,
    metadata
FROM public.actions
WHERE
    action_type LIKE 'admin_%'
    AND ($1::text IS NULL OR action_type = $1)
    AND ($2::text IS NULL OR user_id = $2)
    AND ($3::timestamptz IS NULL OR started_at >= $3)
    AND ($4::timestamptz IS NULL OR started_at <= $4)
ORDER BY started_at DESC
LIMIT $6 OFFSET $5
`

type GetAdminAuditLogParams struct {
	ActionTypeFilter *string            `json:"action_type_filter"`
	UserIDFilter     *string            `json:"user_id_filter"`
	StartDate        pgtype.Timestamptz `json:"start_date"`
	EndDate          pgtype.Timestamptz `json:"end_date"`
	OffsetVal        int32              `json:"offset_val"`
	LimitVal         int32              `json:"limit_val"`
}

type GetAdminAuditLogRow struct {
	ID           string             `json:"id"`
	ActionType   string             `json:"action_type"`
	Concept      string             `json:"concept"`
	UserID       *string            `json:"user_id"`
	PublisherID  *int32             `json:"publisher_id"`
	RequestID    string             `json:"request_id"`
	EntityType   *string            `json:"entity_type"`
	EntityID     *string            `json:"entity_id"`
	Payload      []byte             `json:"payload"`
	Result       []byte             `json:"result"`
	Status       *string            `json:"status"`
	ErrorMessage *string            `json:"error_message"`
	StartedAt    pgtype.Timestamptz `json:"started_at"`
	CompletedAt  pgtype.Timestamptz `json:"completed_at"`
	DurationMs   *int32             `json:"duration_ms"`
	Metadata     []byte             `json:"metadata"`
}

// Returns admin activity log with filtering and pagination
func (q *Queries) GetAdminAuditLog(ctx context.Context, arg GetAdminAuditLogParams) ([]GetAdminAuditLogRow, error) {
	rows, err := q.db.Query(ctx, getAdminAuditLog,
		arg.ActionTypeFilter,
		arg.UserIDFilter,
		arg.StartDate,
		arg.EndDate,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAdminAuditLogRow{}
	for rows.Next() {
		var i GetAdminAuditLogRow
		if err := rows.Scan(
			&i.ID,
			&i.ActionType,
			&i.Concept,
			&i.UserID,
			&i.PublisherID,
			&i.RequestID,
			&i.EntityType,
			&i.EntityID,
			&i.Payload,
			&i.Result,
			&i.Status,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DurationMs,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAuditLog = `-- name: GetAllAuditLog :many
SELECT
    id,
    action_type,
    concept,
    user_id,
    publisher_id,
    entity_type,
    entity_id,
    payload,
    status,
    started_at,
    metadata
FROM public.actions
WHERE
    ($1::text IS NULL OR action_type = $1)
    AND ($2::integer IS NULL OR publisher_id = $2)
    AND ($3::timestamptz IS NULL OR started_at >= $3)
    AND ($4::timestamptz IS NULL OR started_at <= $4)
ORDER BY started_at DESC
LIMIT $6 OFFSET $5
`

type GetAllAuditLogParams struct {
	ActionTypeFilter  *string            `json:"action_type_filter"`
	PublisherIDFilter *int32             `json:"publisher_id_filter"`
	StartDate         pgtype.Timestamptz `json:"start_date"`
	EndDate           pgtype.Timestamptz `json:"end_date"`
	OffsetVal         int32              `json:"offset_val"`
	LimitVal          int32              `json:"limit_val"`
}

type GetAllAuditLogRow struct {
	ID          string             `json:"id"`
	ActionType  string             `json:"action_type"`
	Concept     string             `json:"concept"`
	UserID      *string            `json:"user_id"`
	PublisherID *int32             `json:"publisher_id"`
	EntityType  *string            `json:"entity_type"`
	EntityID    *string            `json:"entity_id"`
	Payload     []byte             `json:"payload"`
	Status      *string            `json:"status"`
	StartedAt   pgtype.Timestamptz `json:"started_at"`
	Metadata    []byte             `json:"metadata"`
}

// Returns all activity log (not just admin) with filtering
func (q *Queries) GetAllAuditLog(ctx context.Context, arg GetAllAuditLogParams) ([]GetAllAuditLogRow, error) {
	rows, err := q.db.Query(ctx, getAllAuditLog,
		arg.ActionTypeFilter,
		arg.PublisherIDFilter,
		arg.StartDate,
		arg.EndDate,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllAuditLogRow{}
	for rows.Next() {
		var i GetAllAuditLogRow
		if err := rows.Scan(
			&i.ID,
			&i.ActionType,
			&i.Concept,
			&i.UserID,
			&i.PublisherID,
			&i.EntityType,
			&i.EntityID,
			&i.Payload,
			&i.Status,
			&i.StartedAt,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntityActionHistory = `-- name: GetEntityActionHistory :many
SELECT
    id,
    action_type,
    concept,
    user_id,
    publisher_id,
    request_id,
    entity_type,
    entity_id,
    payload,
    result,
    status,
    started_at,
    completed_at,
    duration_ms
FROM public.actions
WHERE entity_type = $1 AND entity_id = $2
ORDER BY started_at DESC
`

type GetEntityActionHistoryParams struct {
	EntityType *string `json:"entity_type"`
	EntityID   *string `json:"entity_id"`
}

type GetEntityActionHistoryRow struct {
	ID          string             `json:"id"`
	ActionType  string             `json:"action_type"`
	Concept     string             `json:"concept"`
	UserID      *string            `json:"user_id"`
	PublisherID *int32             `json:"publisher_id"`
	RequestID   string             `json:"request_id"`
	EntityType  *string            `json:"entity_type"`
	EntityID    *string            `json:"entity_id"`
	Payload     []byte             `json:"payload"`
	Result      []byte             `json:"result"`
	Status      *string            `json:"status"`
	StartedAt   pgtype.Timestamptz `json:"started_at"`
	CompletedAt pgtype.Timestamptz `json:"completed_at"`
	DurationMs  *int32             `json:"duration_ms"`
}

// Retrieves all actions for a specific entity (e.g., all actions on publisher_zman #123)
func (q *Queries) GetEntityActionHistory(ctx context.Context, arg GetEntityActionHistoryParams) ([]GetEntityActionHistoryRow, error) {
	rows, err := q.db.Query(ctx, getEntityActionHistory, arg.EntityType, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEntityActionHistoryRow{}
	for rows.Next() {
		var i GetEntityActionHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.ActionType,
			&i.Concept,
			&i.UserID,
			&i.PublisherID,
			&i.RequestID,
			&i.EntityType,
			&i.EntityID,
			&i.Payload,
			&i.Result,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DurationMs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntityAuditTrail = `-- name: GetEntityAuditTrail :many
SELECT
    id,
    action_type,
    concept,
    user_id,
    publisher_id,
    payload,
    result,
    status,
    started_at,
    metadata
FROM public.actions
WHERE entity_type = $1 AND entity_id = $2
ORDER BY started_at DESC
LIMIT $3 OFFSET $4
`

type GetEntityAuditTrailParams struct {
	EntityType *string `json:"entity_type"`
	EntityID   *string `json:"entity_id"`
	Limit      int32   `json:"limit"`
	Offset     int32   `json:"offset"`
}

type GetEntityAuditTrailRow struct {
	ID          string             `json:"id"`
	ActionType  string             `json:"action_type"`
	Concept     string             `json:"concept"`
	UserID      *string            `json:"user_id"`
	PublisherID *int32             `json:"publisher_id"`
	Payload     []byte             `json:"payload"`
	Result      []byte             `json:"result"`
	Status      *string            `json:"status"`
	StartedAt   pgtype.Timestamptz `json:"started_at"`
	Metadata    []byte             `json:"metadata"`
}

// Returns full audit trail for a specific entity
func (q *Queries) GetEntityAuditTrail(ctx context.Context, arg GetEntityAuditTrailParams) ([]GetEntityAuditTrailRow, error) {
	rows, err := q.db.Query(ctx, getEntityAuditTrail,
		arg.EntityType,
		arg.EntityID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEntityAuditTrailRow{}
	for rows.Next() {
		var i GetEntityAuditTrailRow
		if err := rows.Scan(
			&i.ID,
			&i.ActionType,
			&i.Concept,
			&i.UserID,
			&i.PublisherID,
			&i.Payload,
			&i.Result,
			&i.Status,
			&i.StartedAt,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherActivities = `-- name: GetPublisherActivities :many
SELECT
    id,
    action_type,
    concept,
    user_id,
    publisher_id,
    request_id,
    entity_type,
    entity_id,
    payload,
    result,
    status,
    error_message,
    started_at,
    completed_at,
    duration_ms,
    metadata
FROM public.actions
WHERE publisher_id = $1
ORDER BY started_at DESC
LIMIT $2 OFFSET $3
`

type GetPublisherActivitiesParams struct {
	PublisherID *int32 `json:"publisher_id"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

type GetPublisherActivitiesRow struct {
	ID           string             `json:"id"`
	ActionType   string             `json:"action_type"`
	Concept      string             `json:"concept"`
	UserID       *string            `json:"user_id"`
	PublisherID  *int32             `json:"publisher_id"`
	RequestID    string             `json:"request_id"`
	EntityType   *string            `json:"entity_type"`
	EntityID     *string            `json:"entity_id"`
	Payload      []byte             `json:"payload"`
	Result       []byte             `json:"result"`
	Status       *string            `json:"status"`
	ErrorMessage *string            `json:"error_message"`
	StartedAt    pgtype.Timestamptz `json:"started_at"`
	CompletedAt  pgtype.Timestamptz `json:"completed_at"`
	DurationMs   *int32             `json:"duration_ms"`
	Metadata     []byte             `json:"metadata"`
}

// Retrieves all activities for a publisher (for activity log display)
func (q *Queries) GetPublisherActivities(ctx context.Context, arg GetPublisherActivitiesParams) ([]GetPublisherActivitiesRow, error) {
	rows, err := q.db.Query(ctx, getPublisherActivities, arg.PublisherID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherActivitiesRow{}
	for rows.Next() {
		var i GetPublisherActivitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.ActionType,
			&i.Concept,
			&i.UserID,
			&i.PublisherID,
			&i.RequestID,
			&i.EntityType,
			&i.EntityID,
			&i.Payload,
			&i.Result,
			&i.Status,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DurationMs,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordAction = `-- name: RecordAction :one

INSERT INTO public.actions (
    action_type,
    concept,
    user_id,
    publisher_id,
    request_id,
    entity_type,
    entity_id,
    payload,
    parent_action_id,
    metadata
) VALUES (
    $1,  -- action_type
    $2,  -- concept
    $3,  -- user_id
    $4,  -- publisher_id
    $5,  -- request_id
    $6,  -- entity_type
    $7,  -- entity_id
    $8,  -- payload
    $9,  -- parent_action_id
    $10  -- metadata
) RETURNING id
`

type RecordActionParams struct {
	ActionType     string      `json:"action_type"`
	Concept        string      `json:"concept"`
	UserID         *string     `json:"user_id"`
	PublisherID    *int32      `json:"publisher_id"`
	RequestID      string      `json:"request_id"`
	EntityType     *string     `json:"entity_type"`
	EntityID       *string     `json:"entity_id"`
	Payload        []byte      `json:"payload"`
	ParentActionID pgtype.UUID `json:"parent_action_id"`
	Metadata       []byte      `json:"metadata"`
}

// File: actions.sql
// Purpose: Action reification queries for provenance tracking
// Pattern: action-reification
// Complexity: low (single concept - provenance)
// Used by: All services that create/update state
// Records a new action in the actions table (starts with 'pending' status)
// Returns the action_id for tracking
func (q *Queries) RecordAction(ctx context.Context, arg RecordActionParams) (string, error) {
	row := q.db.QueryRow(ctx, recordAction,
		arg.ActionType,
		arg.Concept,
		arg.UserID,
		arg.PublisherID,
		arg.RequestID,
		arg.EntityType,
		arg.EntityID,
		arg.Payload,
		arg.ParentActionID,
		arg.Metadata,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}
