// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: coverage.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkDuplicateCoverageContinent = `-- name: CheckDuplicateCoverageContinent :one

SELECT EXISTS(
    SELECT 1 FROM publisher_coverage pc
    JOIN coverage_levels cl ON cl.id = pc.coverage_level_id
    WHERE pc.publisher_id = $1 AND cl.key = 'continent' AND pc.continent_id = $2
) as exists
`

type CheckDuplicateCoverageContinentParams struct {
	PublisherID int32  `json:"publisher_id"`
	ContinentID *int16 `json:"continent_id"`
}

// ============================================================================
// Coverage Validation
// ============================================================================
func (q *Queries) CheckDuplicateCoverageContinent(ctx context.Context, arg CheckDuplicateCoverageContinentParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkDuplicateCoverageContinent, arg.PublisherID, arg.ContinentID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkDuplicateCoverageCountry = `-- name: CheckDuplicateCoverageCountry :one
SELECT EXISTS(
    SELECT 1 FROM publisher_coverage pc
    JOIN coverage_levels cl ON cl.id = pc.coverage_level_id
    WHERE pc.publisher_id = $1 AND cl.key = 'country' AND pc.country_id = $2
) as exists
`

type CheckDuplicateCoverageCountryParams struct {
	PublisherID int32  `json:"publisher_id"`
	CountryID   *int16 `json:"country_id"`
}

func (q *Queries) CheckDuplicateCoverageCountry(ctx context.Context, arg CheckDuplicateCoverageCountryParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkDuplicateCoverageCountry, arg.PublisherID, arg.CountryID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkDuplicateCoverageLocality = `-- name: CheckDuplicateCoverageLocality :one
SELECT EXISTS(
    SELECT 1 FROM publisher_coverage pc
    JOIN coverage_levels cl ON cl.id = pc.coverage_level_id
    WHERE pc.publisher_id = $1 AND cl.key = 'locality' AND pc.locality_id = $2
) as exists
`

type CheckDuplicateCoverageLocalityParams struct {
	PublisherID int32  `json:"publisher_id"`
	LocalityID  *int32 `json:"locality_id"`
}

func (q *Queries) CheckDuplicateCoverageLocality(ctx context.Context, arg CheckDuplicateCoverageLocalityParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkDuplicateCoverageLocality, arg.PublisherID, arg.LocalityID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkDuplicateCoverageRegion = `-- name: CheckDuplicateCoverageRegion :one
SELECT EXISTS(
    SELECT 1 FROM publisher_coverage pc
    JOIN coverage_levels cl ON cl.id = pc.coverage_level_id
    WHERE pc.publisher_id = $1 AND cl.key = 'region' AND pc.region_id = $2
) as exists
`

type CheckDuplicateCoverageRegionParams struct {
	PublisherID int32  `json:"publisher_id"`
	RegionID    *int32 `json:"region_id"`
}

func (q *Queries) CheckDuplicateCoverageRegion(ctx context.Context, arg CheckDuplicateCoverageRegionParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkDuplicateCoverageRegion, arg.PublisherID, arg.RegionID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createCoverageContinent = `-- name: CreateCoverageContinent :one
INSERT INTO publisher_coverage (
    publisher_id, coverage_level_id, continent_id, priority, is_active
)
VALUES (
    $1,
    (SELECT id FROM coverage_levels WHERE key = 'continent'),
    $2, $3, $4
)
RETURNING id, publisher_id, coverage_level_id, continent_id, country_id, region_id, locality_id, priority, is_active, created_at, updated_at
`

type CreateCoverageContinentParams struct {
	PublisherID int32  `json:"publisher_id"`
	ContinentID *int16 `json:"continent_id"`
	Priority    *int32 `json:"priority"`
	IsActive    bool   `json:"is_active"`
}

type CreateCoverageContinentRow struct {
	ID              int32              `json:"id"`
	PublisherID     int32              `json:"publisher_id"`
	CoverageLevelID int16              `json:"coverage_level_id"`
	ContinentID     *int16             `json:"continent_id"`
	CountryID       *int16             `json:"country_id"`
	RegionID        *int32             `json:"region_id"`
	LocalityID      *int32             `json:"locality_id"`
	Priority        *int32             `json:"priority"`
	IsActive        bool               `json:"is_active"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateCoverageContinent(ctx context.Context, arg CreateCoverageContinentParams) (CreateCoverageContinentRow, error) {
	row := q.db.QueryRow(ctx, createCoverageContinent,
		arg.PublisherID,
		arg.ContinentID,
		arg.Priority,
		arg.IsActive,
	)
	var i CreateCoverageContinentRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.CoverageLevelID,
		&i.ContinentID,
		&i.CountryID,
		&i.RegionID,
		&i.LocalityID,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCoverageCountry = `-- name: CreateCoverageCountry :one
INSERT INTO publisher_coverage (
    publisher_id, coverage_level_id, country_id, priority, is_active
)
VALUES (
    $1,
    (SELECT id FROM coverage_levels WHERE key = 'country'),
    $2, $3, $4
)
RETURNING id, publisher_id, coverage_level_id, continent_id, country_id, region_id, locality_id, priority, is_active, created_at, updated_at
`

type CreateCoverageCountryParams struct {
	PublisherID int32  `json:"publisher_id"`
	CountryID   *int16 `json:"country_id"`
	Priority    *int32 `json:"priority"`
	IsActive    bool   `json:"is_active"`
}

type CreateCoverageCountryRow struct {
	ID              int32              `json:"id"`
	PublisherID     int32              `json:"publisher_id"`
	CoverageLevelID int16              `json:"coverage_level_id"`
	ContinentID     *int16             `json:"continent_id"`
	CountryID       *int16             `json:"country_id"`
	RegionID        *int32             `json:"region_id"`
	LocalityID      *int32             `json:"locality_id"`
	Priority        *int32             `json:"priority"`
	IsActive        bool               `json:"is_active"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateCoverageCountry(ctx context.Context, arg CreateCoverageCountryParams) (CreateCoverageCountryRow, error) {
	row := q.db.QueryRow(ctx, createCoverageCountry,
		arg.PublisherID,
		arg.CountryID,
		arg.Priority,
		arg.IsActive,
	)
	var i CreateCoverageCountryRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.CoverageLevelID,
		&i.ContinentID,
		&i.CountryID,
		&i.RegionID,
		&i.LocalityID,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCoverageLocality = `-- name: CreateCoverageLocality :one
INSERT INTO publisher_coverage (
    publisher_id, coverage_level_id, locality_id, priority, is_active
)
VALUES (
    $1,
    (SELECT id FROM coverage_levels WHERE key = 'locality'),
    $2, $3, $4
)
RETURNING id, publisher_id, coverage_level_id, continent_id, country_id, region_id, locality_id, priority, is_active, created_at, updated_at
`

type CreateCoverageLocalityParams struct {
	PublisherID int32  `json:"publisher_id"`
	LocalityID  *int32 `json:"locality_id"`
	Priority    *int32 `json:"priority"`
	IsActive    bool   `json:"is_active"`
}

type CreateCoverageLocalityRow struct {
	ID              int32              `json:"id"`
	PublisherID     int32              `json:"publisher_id"`
	CoverageLevelID int16              `json:"coverage_level_id"`
	ContinentID     *int16             `json:"continent_id"`
	CountryID       *int16             `json:"country_id"`
	RegionID        *int32             `json:"region_id"`
	LocalityID      *int32             `json:"locality_id"`
	Priority        *int32             `json:"priority"`
	IsActive        bool               `json:"is_active"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateCoverageLocality(ctx context.Context, arg CreateCoverageLocalityParams) (CreateCoverageLocalityRow, error) {
	row := q.db.QueryRow(ctx, createCoverageLocality,
		arg.PublisherID,
		arg.LocalityID,
		arg.Priority,
		arg.IsActive,
	)
	var i CreateCoverageLocalityRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.CoverageLevelID,
		&i.ContinentID,
		&i.CountryID,
		&i.RegionID,
		&i.LocalityID,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCoverageRegion = `-- name: CreateCoverageRegion :one
INSERT INTO publisher_coverage (
    publisher_id, coverage_level_id, region_id, priority, is_active
)
VALUES (
    $1,
    (SELECT id FROM coverage_levels WHERE key = 'region'),
    $2, $3, $4
)
RETURNING id, publisher_id, coverage_level_id, continent_id, country_id, region_id, locality_id, priority, is_active, created_at, updated_at
`

type CreateCoverageRegionParams struct {
	PublisherID int32  `json:"publisher_id"`
	RegionID    *int32 `json:"region_id"`
	Priority    *int32 `json:"priority"`
	IsActive    bool   `json:"is_active"`
}

type CreateCoverageRegionRow struct {
	ID              int32              `json:"id"`
	PublisherID     int32              `json:"publisher_id"`
	CoverageLevelID int16              `json:"coverage_level_id"`
	ContinentID     *int16             `json:"continent_id"`
	CountryID       *int16             `json:"country_id"`
	RegionID        *int32             `json:"region_id"`
	LocalityID      *int32             `json:"locality_id"`
	Priority        *int32             `json:"priority"`
	IsActive        bool               `json:"is_active"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateCoverageRegion(ctx context.Context, arg CreateCoverageRegionParams) (CreateCoverageRegionRow, error) {
	row := q.db.QueryRow(ctx, createCoverageRegion,
		arg.PublisherID,
		arg.RegionID,
		arg.Priority,
		arg.IsActive,
	)
	var i CreateCoverageRegionRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.CoverageLevelID,
		&i.ContinentID,
		&i.CountryID,
		&i.RegionID,
		&i.LocalityID,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCoverage = `-- name: DeleteCoverage :exec
DELETE FROM publisher_coverage
WHERE id = $1
`

func (q *Queries) DeleteCoverage(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteCoverage, id)
	return err
}

const deleteCoverageByPublisher = `-- name: DeleteCoverageByPublisher :exec
DELETE FROM publisher_coverage
WHERE publisher_id = $1
`

func (q *Queries) DeleteCoverageByPublisher(ctx context.Context, publisherID int32) error {
	_, err := q.db.Exec(ctx, deleteCoverageByPublisher, publisherID)
	return err
}

const getCoverageCountByPublisher = `-- name: GetCoverageCountByPublisher :one
SELECT COUNT(*)
FROM publisher_coverage
WHERE publisher_id = $1 AND is_active = true
`

func (q *Queries) GetCoverageCountByPublisher(ctx context.Context, publisherID int32) (int64, error) {
	row := q.db.QueryRow(ctx, getCoverageCountByPublisher, publisherID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLocalitiesCoveredCount = `-- name: GetLocalitiesCoveredCount :one
SELECT COALESCE(SUM(
    CASE cl.key
        WHEN 'locality' THEN 1
        WHEN 'region' THEN COALESCE((
            SELECT s.descendant_count FROM geo_search_index s
            WHERE s.entity_type = 'region' AND s.entity_id = pc.region_id
        ), 0)
        WHEN 'country' THEN COALESCE((
            SELECT s.descendant_count FROM geo_search_index s
            WHERE s.entity_type = 'country' AND s.entity_id = pc.country_id
        ), 0)
        WHEN 'continent' THEN COALESCE((
            SELECT s.descendant_count FROM geo_search_index s
            WHERE s.entity_type = 'continent' AND s.entity_id = pc.continent_id
        ), 0)
        ELSE 0
    END
), 0)::int
FROM publisher_coverage pc
JOIN coverage_levels cl ON cl.id = pc.coverage_level_id
WHERE pc.publisher_id = $1 AND pc.is_active = true
`

// Estimates the number of localities covered by a publisher's coverage areas
// Uses pre-computed descendant_count for accurate totals
func (q *Queries) GetLocalitiesCoveredCount(ctx context.Context, publisherID int32) (int32, error) {
	row := q.db.QueryRow(ctx, getLocalitiesCoveredCount, publisherID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const getPublisherCoverage = `-- name: GetPublisherCoverage :many

WITH best_coords AS (
    SELECT DISTINCT ON (ll.locality_id)
        ll.locality_id,
        ll.latitude,
        ll.longitude
    FROM geo_locality_locations ll
    JOIN geo_data_sources ds ON ds.id = ll.source_id AND ds.is_active = true
    WHERE ll.publisher_id IS NULL  -- System-wide records only
    ORDER BY ll.locality_id,
             CASE ds.key WHEN 'admin' THEN 1 ELSE 2 END,  -- admin > default
             ds.priority
)
SELECT
    pc.id, pc.publisher_id, pc.coverage_level_id,
    cl.key as coverage_level_key,
    cl.display_name_hebrew as coverage_level_display_hebrew,
    cl.display_name_english as coverage_level_display_english,
    pc.continent_id, pc.country_id, pc.region_id, pc.locality_id,
    pc.priority, pc.is_active, pc.created_at, pc.updated_at,
    -- Resolved names
    COALESCE(ct.name, country_continent.name, '') as continent_name,
    COALESCE(co.code, region_country.code, locality_country.code, '') as country_code,
    COALESCE(co.name, region_country.name, locality_country.name, '') as country_name,
    COALESCE(r.code, '') as region_code,
    COALESCE(r.name, '') as region_name,
    COALESCE(l.name, '') as locality_name,
    -- Locality coordinates for preview (from best system-wide data)
    bc.latitude as locality_latitude,
    bc.longitude as locality_longitude,
    l.timezone as locality_timezone,
    -- Locality count for this coverage area (uses pre-computed descendant_count for total descendants)
    CASE cl.key
        WHEN 'locality' THEN 1::bigint
        WHEN 'region' THEN COALESCE((
            SELECT s.descendant_count FROM geo_search_index s
            WHERE s.entity_type = 'region' AND s.entity_id = pc.region_id
        ), 0)::bigint
        WHEN 'country' THEN COALESCE((
            SELECT s.descendant_count FROM geo_search_index s
            WHERE s.entity_type = 'country' AND s.entity_id = pc.country_id
        ), 0)::bigint
        WHEN 'continent' THEN COALESCE((
            SELECT s.descendant_count FROM geo_search_index s
            WHERE s.entity_type = 'continent' AND s.entity_id = pc.continent_id
        ), 0)::bigint
        ELSE 0::bigint
    END as locality_count
FROM publisher_coverage pc
JOIN coverage_levels cl ON cl.id = pc.coverage_level_id
LEFT JOIN geo_continents ct ON pc.continent_id = ct.id
LEFT JOIN geo_countries co ON pc.country_id = co.id
LEFT JOIN geo_regions r ON pc.region_id = r.id
LEFT JOIN geo_localities l ON pc.locality_id = l.id
LEFT JOIN best_coords bc ON bc.locality_id = l.id
LEFT JOIN geo_continents country_continent ON co.continent_id = country_continent.id
LEFT JOIN geo_countries region_country ON r.country_id = region_country.id
LEFT JOIN geo_search_index ls ON ls.entity_type = 'locality' AND ls.entity_id = l.id
LEFT JOIN geo_countries locality_country ON l.country_id = locality_country.id
WHERE pc.publisher_id = $1 AND pc.is_active = true
ORDER BY cl.sort_order, pc.priority DESC, pc.created_at DESC
`

type GetPublisherCoverageRow struct {
	ID                          int32              `json:"id"`
	PublisherID                 int32              `json:"publisher_id"`
	CoverageLevelID             int16              `json:"coverage_level_id"`
	CoverageLevelKey            string             `json:"coverage_level_key"`
	CoverageLevelDisplayHebrew  string             `json:"coverage_level_display_hebrew"`
	CoverageLevelDisplayEnglish string             `json:"coverage_level_display_english"`
	ContinentID                 *int16             `json:"continent_id"`
	CountryID                   *int16             `json:"country_id"`
	RegionID                    *int32             `json:"region_id"`
	LocalityID                  *int32             `json:"locality_id"`
	Priority                    *int32             `json:"priority"`
	IsActive                    bool               `json:"is_active"`
	CreatedAt                   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                   pgtype.Timestamptz `json:"updated_at"`
	ContinentName               string             `json:"continent_name"`
	CountryCode                 string             `json:"country_code"`
	CountryName                 string             `json:"country_name"`
	RegionCode                  string             `json:"region_code"`
	RegionName                  string             `json:"region_name"`
	LocalityName                string             `json:"locality_name"`
	LocalityLatitude            *float64           `json:"locality_latitude"`
	LocalityLongitude           *float64           `json:"locality_longitude"`
	LocalityTimezone            *string            `json:"locality_timezone"`
	LocalityCount               int64              `json:"locality_count"`
}

// Coverage SQL Queries (Geographic Hierarchy)
// Supports: continent, country, region, locality
// Uses geo_search_index for resolved hierarchy lookups
// Returns coverage with full hierarchy resolved
// Locality coordinates resolved with priority: admin > default (for display preview)
// Direct joins for each level
// Hierarchy traversal: country -> continent
// Hierarchy traversal: region -> country
// Hierarchy traversal: locality -> country (via search index)
func (q *Queries) GetPublisherCoverage(ctx context.Context, publisherID int32) ([]GetPublisherCoverageRow, error) {
	rows, err := q.db.Query(ctx, getPublisherCoverage, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherCoverageRow{}
	for rows.Next() {
		var i GetPublisherCoverageRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.CoverageLevelID,
			&i.CoverageLevelKey,
			&i.CoverageLevelDisplayHebrew,
			&i.CoverageLevelDisplayEnglish,
			&i.ContinentID,
			&i.CountryID,
			&i.RegionID,
			&i.LocalityID,
			&i.Priority,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContinentName,
			&i.CountryCode,
			&i.CountryName,
			&i.RegionCode,
			&i.RegionName,
			&i.LocalityName,
			&i.LocalityLatitude,
			&i.LocalityLongitude,
			&i.LocalityTimezone,
			&i.LocalityCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherCoverageByID = `-- name: GetPublisherCoverageByID :one
SELECT
    pc.id, pc.publisher_id, pc.coverage_level_id,
    cl.key as coverage_level_key,
    cl.display_name_hebrew as coverage_level_display_hebrew,
    cl.display_name_english as coverage_level_display_english,
    pc.continent_id, pc.country_id, pc.region_id, pc.locality_id,
    pc.priority, pc.is_active, pc.created_at, pc.updated_at
FROM publisher_coverage pc
JOIN coverage_levels cl ON cl.id = pc.coverage_level_id
WHERE pc.id = $1
`

type GetPublisherCoverageByIDRow struct {
	ID                          int32              `json:"id"`
	PublisherID                 int32              `json:"publisher_id"`
	CoverageLevelID             int16              `json:"coverage_level_id"`
	CoverageLevelKey            string             `json:"coverage_level_key"`
	CoverageLevelDisplayHebrew  string             `json:"coverage_level_display_hebrew"`
	CoverageLevelDisplayEnglish string             `json:"coverage_level_display_english"`
	ContinentID                 *int16             `json:"continent_id"`
	CountryID                   *int16             `json:"country_id"`
	RegionID                    *int32             `json:"region_id"`
	LocalityID                  *int32             `json:"locality_id"`
	Priority                    *int32             `json:"priority"`
	IsActive                    bool               `json:"is_active"`
	CreatedAt                   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetPublisherCoverageByID(ctx context.Context, id int32) (GetPublisherCoverageByIDRow, error) {
	row := q.db.QueryRow(ctx, getPublisherCoverageByID, id)
	var i GetPublisherCoverageByIDRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.CoverageLevelID,
		&i.CoverageLevelKey,
		&i.CoverageLevelDisplayHebrew,
		&i.CoverageLevelDisplayEnglish,
		&i.ContinentID,
		&i.CountryID,
		&i.RegionID,
		&i.LocalityID,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPublishersByCountry = `-- name: GetPublishersByCountry :many
SELECT DISTINCT
    p.id, p.name, p.slug, p.is_verified,
    cl.key as coverage_level_key,
    cl.display_name_hebrew as coverage_level_display_hebrew,
    cl.display_name_english as coverage_level_display_english,
    pc.priority
FROM publishers p
JOIN publisher_statuses ps ON ps.id = p.status_id
JOIN publisher_coverage pc ON p.id = pc.publisher_id
JOIN coverage_levels cl ON cl.id = pc.coverage_level_id
LEFT JOIN geo_countries co ON pc.country_id = co.id
LEFT JOIN geo_regions r ON pc.region_id = r.id
LEFT JOIN geo_localities l ON pc.locality_id = l.id
WHERE ps.key = 'active'
  AND pc.is_active = true
  AND (
    pc.country_id = $1
    OR r.country_id = $1
    OR l.country_id = $1
  )
ORDER BY pc.priority DESC, p.name
`

type GetPublishersByCountryRow struct {
	ID                          int32   `json:"id"`
	Name                        string  `json:"name"`
	Slug                        *string `json:"slug"`
	IsVerified                  bool    `json:"is_verified"`
	CoverageLevelKey            string  `json:"coverage_level_key"`
	CoverageLevelDisplayHebrew  string  `json:"coverage_level_display_hebrew"`
	CoverageLevelDisplayEnglish string  `json:"coverage_level_display_english"`
	Priority                    *int32  `json:"priority"`
}

// Find publishers with coverage in a specific country
func (q *Queries) GetPublishersByCountry(ctx context.Context, countryID *int16) ([]GetPublishersByCountryRow, error) {
	rows, err := q.db.Query(ctx, getPublishersByCountry, countryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublishersByCountryRow{}
	for rows.Next() {
		var i GetPublishersByCountryRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.IsVerified,
			&i.CoverageLevelKey,
			&i.CoverageLevelDisplayHebrew,
			&i.CoverageLevelDisplayEnglish,
			&i.Priority,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublishersByRegion = `-- name: GetPublishersByRegion :many
SELECT DISTINCT
    p.id, p.name, p.slug, p.is_verified,
    cl.key as coverage_level_key,
    cl.display_name_hebrew as coverage_level_display_hebrew,
    cl.display_name_english as coverage_level_display_english,
    pc.priority
FROM publishers p
JOIN publisher_statuses ps ON ps.id = p.status_id
JOIN publisher_coverage pc ON p.id = pc.publisher_id
JOIN coverage_levels cl ON cl.id = pc.coverage_level_id
LEFT JOIN geo_search_index ls ON ls.entity_type = 'locality' AND ls.entity_id = pc.locality_id
WHERE ps.key = 'active'
  AND pc.is_active = true
  AND (
    pc.region_id = $1
    OR ls.inherited_region_id = $1
  )
ORDER BY pc.priority DESC, p.name
`

type GetPublishersByRegionRow struct {
	ID                          int32   `json:"id"`
	Name                        string  `json:"name"`
	Slug                        *string `json:"slug"`
	IsVerified                  bool    `json:"is_verified"`
	CoverageLevelKey            string  `json:"coverage_level_key"`
	CoverageLevelDisplayHebrew  string  `json:"coverage_level_display_hebrew"`
	CoverageLevelDisplayEnglish string  `json:"coverage_level_display_english"`
	Priority                    *int32  `json:"priority"`
}

// Find publishers with coverage in a specific region
// Uses inherited_region_id from search index
func (q *Queries) GetPublishersByRegion(ctx context.Context, regionID *int32) ([]GetPublishersByRegionRow, error) {
	rows, err := q.db.Query(ctx, getPublishersByRegion, regionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublishersByRegionRow{}
	for rows.Next() {
		var i GetPublishersByRegionRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.IsVerified,
			&i.CoverageLevelKey,
			&i.CoverageLevelDisplayHebrew,
			&i.CoverageLevelDisplayEnglish,
			&i.Priority,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublishersForLocality = `-- name: GetPublishersForLocality :many

SELECT DISTINCT ON (p.id)
    p.id::int AS publisher_id,
    p.name::text AS publisher_name,
    cl.key::text AS coverage_level,
    pc.priority::int AS priority,
    CASE
        WHEN pc.locality_id = $1::int THEN 'exact_locality'
        WHEN pc.region_id IS NOT NULL THEN 'region_match'
        WHEN pc.country_id IS NOT NULL THEN 'country_match'
        WHEN pc.continent_id IS NOT NULL THEN 'continent_match'
        ELSE 'unknown'
    END::text AS match_type,
    CASE
        WHEN pc.locality_id = $1::int THEN 1
        WHEN pc.region_id IS NOT NULL THEN 2
        WHEN pc.country_id IS NOT NULL THEN 3
        WHEN pc.continent_id IS NOT NULL THEN 4
        ELSE 5
    END::int AS specificity_rank
FROM publishers p
JOIN publisher_statuses ps ON ps.id = p.status_id
JOIN publisher_coverage pc ON p.id = pc.publisher_id
JOIN coverage_levels cl ON cl.id = pc.coverage_level_id
LEFT JOIN geo_localities l ON l.id = $1::int
LEFT JOIN geo_search_index ls ON ls.entity_type = 'locality' AND ls.entity_id = l.id
WHERE ps.key = 'active'
  AND pc.is_active = true
  AND (
    -- Exact locality match
    pc.locality_id = $1::int
    -- Region match (locality's inherited region)
    OR (pc.region_id IS NOT NULL AND ls.ancestor_region_ids @> ARRAY[pc.region_id])
    -- Country match (locality's country)
    OR (pc.country_id IS NOT NULL AND l.country_id = pc.country_id)
    -- Continent match (locality's country's continent)
    OR (pc.continent_id IS NOT NULL AND EXISTS (
        SELECT 1 FROM geo_countries co
        WHERE co.id = l.country_id AND co.continent_id = pc.continent_id
    ))
  )
ORDER BY p.id, specificity_rank, priority DESC
`

type GetPublishersForLocalityRow struct {
	PublisherID     int32  `json:"publisher_id"`
	PublisherName   string `json:"publisher_name"`
	CoverageLevel   string `json:"coverage_level"`
	Priority        int32  `json:"priority"`
	MatchType       string `json:"match_type"`
	SpecificityRank int32  `json:"specificity_rank"`
}

// ============================================================================
// Publisher Lookup by Location
// ============================================================================
// Find publishers that cover a specific locality through all coverage levels
// Uses search index to resolve inherited_region_id
// DISTINCT ON ensures each publisher appears only once, with most specific coverage
func (q *Queries) GetPublishersForLocality(ctx context.Context, localityID int32) ([]GetPublishersForLocalityRow, error) {
	rows, err := q.db.Query(ctx, getPublishersForLocality, localityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublishersForLocalityRow{}
	for rows.Next() {
		var i GetPublishersForLocalityRow
		if err := rows.Scan(
			&i.PublisherID,
			&i.PublisherName,
			&i.CoverageLevel,
			&i.Priority,
			&i.MatchType,
			&i.SpecificityRank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRepresentativeLocalitiesForCoverage = `-- name: GetRepresentativeLocalitiesForCoverage :many
SELECT
    pc.id as coverage_id,
    cl.key as coverage_level_key,
    COALESCE(loc_locality.locality_id, loc_region.locality_id, loc_country.locality_id, loc_continent.locality_id) as locality_id,
    COALESCE(loc_locality.locality_name, loc_region.locality_name, loc_country.locality_name, loc_continent.locality_name) as locality_name,
    COALESCE(loc_locality.locality_hierarchy, loc_region.locality_hierarchy, loc_country.locality_hierarchy, loc_continent.locality_hierarchy) as locality_hierarchy,
    COALESCE(loc_locality.latitude, loc_region.latitude, loc_country.latitude, loc_continent.latitude) as latitude,
    COALESCE(loc_locality.longitude, loc_region.longitude, loc_country.longitude, loc_continent.longitude) as longitude,
    COALESCE(loc_locality.timezone, loc_region.timezone, loc_country.timezone, loc_continent.timezone) as timezone,
    COALESCE(loc_locality.country_code, loc_region.country_code, loc_country.country_code, loc_continent.country_code) as country_code
FROM publisher_coverage pc
JOIN coverage_levels cl ON cl.id = pc.coverage_level_id
LEFT JOIN LATERAL (
    SELECT s.entity_id as locality_id, s.display_name as locality_name, s.display_hierarchy as locality_hierarchy,
           s.latitude, s.longitude, s.timezone, s.country_code
    FROM geo_search_index s
    WHERE cl.key = 'locality' AND s.entity_type = 'locality' AND s.entity_id = pc.locality_id
    LIMIT 1
) loc_locality ON true
LEFT JOIN LATERAL (
    SELECT s.entity_id as locality_id, s.display_name as locality_name, s.display_hierarchy as locality_hierarchy,
           s.latitude, s.longitude, s.timezone, s.country_code
    FROM geo_search_index s
    WHERE cl.key = 'region' AND s.entity_type = 'locality' AND s.ancestor_region_ids @> ARRAY[pc.region_id]
    ORDER BY s.population DESC NULLS LAST
    LIMIT 1
) loc_region ON true
LEFT JOIN LATERAL (
    SELECT s.entity_id as locality_id, s.display_name as locality_name, s.display_hierarchy as locality_hierarchy,
           s.latitude, s.longitude, s.timezone, s.country_code
    FROM geo_search_index s
    WHERE cl.key = 'country' AND s.entity_type = 'locality' AND s.country_id = pc.country_id
    ORDER BY s.population DESC NULLS LAST
    LIMIT 1
) loc_country ON true
LEFT JOIN LATERAL (
    SELECT s.entity_id as locality_id, s.display_name as locality_name, s.display_hierarchy as locality_hierarchy,
           s.latitude, s.longitude, s.timezone, s.country_code
    FROM geo_search_index s
    WHERE cl.key = 'continent' AND s.entity_type = 'locality' AND s.continent_id = pc.continent_id
    ORDER BY s.population DESC NULLS LAST
    LIMIT 1
) loc_continent ON true
WHERE pc.publisher_id = $1 AND pc.is_active = true
LIMIT 10
`

type GetRepresentativeLocalitiesForCoverageRow struct {
	CoverageID        int32    `json:"coverage_id"`
	CoverageLevelKey  string   `json:"coverage_level_key"`
	LocalityID        int32    `json:"locality_id"`
	LocalityName      string   `json:"locality_name"`
	LocalityHierarchy string   `json:"locality_hierarchy"`
	Latitude          *float64 `json:"latitude"`
	Longitude         *float64 `json:"longitude"`
	Timezone          *string  `json:"timezone"`
	CountryCode       *string  `json:"country_code"`
}

// Returns one representative locality per coverage area using ID-based joins
// Used by Algorithm Editor to get preview locations for zmanim calculation
// Uses separate LATERAL joins per coverage level for optimal index usage (~6ms vs 5s)
// Locality lookup (direct entity match)
// Region lookup (top locality by population in region)
// Country lookup (top locality by population in country)
// Continent lookup (top locality by population in continent)
func (q *Queries) GetRepresentativeLocalitiesForCoverage(ctx context.Context, publisherID int32) ([]GetRepresentativeLocalitiesForCoverageRow, error) {
	rows, err := q.db.Query(ctx, getRepresentativeLocalitiesForCoverage, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRepresentativeLocalitiesForCoverageRow{}
	for rows.Next() {
		var i GetRepresentativeLocalitiesForCoverageRow
		if err := rows.Scan(
			&i.CoverageID,
			&i.CoverageLevelKey,
			&i.LocalityID,
			&i.LocalityName,
			&i.LocalityHierarchy,
			&i.Latitude,
			&i.Longitude,
			&i.Timezone,
			&i.CountryCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCoverageActive = `-- name: UpdateCoverageActive :one
UPDATE publisher_coverage
SET is_active = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, publisher_id, coverage_level_id, continent_id, country_id, region_id, locality_id, priority, is_active, created_at, updated_at
`

type UpdateCoverageActiveParams struct {
	ID       int32 `json:"id"`
	IsActive bool  `json:"is_active"`
}

type UpdateCoverageActiveRow struct {
	ID              int32              `json:"id"`
	PublisherID     int32              `json:"publisher_id"`
	CoverageLevelID int16              `json:"coverage_level_id"`
	ContinentID     *int16             `json:"continent_id"`
	CountryID       *int16             `json:"country_id"`
	RegionID        *int32             `json:"region_id"`
	LocalityID      *int32             `json:"locality_id"`
	Priority        *int32             `json:"priority"`
	IsActive        bool               `json:"is_active"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateCoverageActive(ctx context.Context, arg UpdateCoverageActiveParams) (UpdateCoverageActiveRow, error) {
	row := q.db.QueryRow(ctx, updateCoverageActive, arg.ID, arg.IsActive)
	var i UpdateCoverageActiveRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.CoverageLevelID,
		&i.ContinentID,
		&i.CountryID,
		&i.RegionID,
		&i.LocalityID,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCoveragePriority = `-- name: UpdateCoveragePriority :one
UPDATE publisher_coverage
SET priority = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, publisher_id, coverage_level_id, continent_id, country_id, region_id, locality_id, priority, is_active, created_at, updated_at
`

type UpdateCoveragePriorityParams struct {
	ID       int32  `json:"id"`
	Priority *int32 `json:"priority"`
}

type UpdateCoveragePriorityRow struct {
	ID              int32              `json:"id"`
	PublisherID     int32              `json:"publisher_id"`
	CoverageLevelID int16              `json:"coverage_level_id"`
	ContinentID     *int16             `json:"continent_id"`
	CountryID       *int16             `json:"country_id"`
	RegionID        *int32             `json:"region_id"`
	LocalityID      *int32             `json:"locality_id"`
	Priority        *int32             `json:"priority"`
	IsActive        bool               `json:"is_active"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateCoveragePriority(ctx context.Context, arg UpdateCoveragePriorityParams) (UpdateCoveragePriorityRow, error) {
	row := q.db.QueryRow(ctx, updateCoveragePriority, arg.ID, arg.Priority)
	var i UpdateCoveragePriorityRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.CoverageLevelID,
		&i.ContinentID,
		&i.CountryID,
		&i.RegionID,
		&i.LocalityID,
		&i.Priority,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
