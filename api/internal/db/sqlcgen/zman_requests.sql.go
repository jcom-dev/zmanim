// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: zman_requests.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addZmanRequestNewTag = `-- name: AddZmanRequestNewTag :one
INSERT INTO zman_request_tags (
    request_id,
    requested_tag_name,
    requested_tag_type,
    is_new_tag_request
) VALUES ($1, $2, $3, true)
RETURNING id, request_id, requested_tag_name, requested_tag_type, is_new_tag_request, created_at
`

type AddZmanRequestNewTagParams struct {
	RequestID        int32   `json:"request_id"`
	RequestedTagName *string `json:"requested_tag_name"`
	RequestedTagType *string `json:"requested_tag_type"`
}

type AddZmanRequestNewTagRow struct {
	ID               int32              `json:"id"`
	RequestID        int32              `json:"request_id"`
	RequestedTagName *string            `json:"requested_tag_name"`
	RequestedTagType *string            `json:"requested_tag_type"`
	IsNewTagRequest  bool               `json:"is_new_tag_request"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

// Request a new tag for a zman request
func (q *Queries) AddZmanRequestNewTag(ctx context.Context, arg AddZmanRequestNewTagParams) (AddZmanRequestNewTagRow, error) {
	row := q.db.QueryRow(ctx, addZmanRequestNewTag, arg.RequestID, arg.RequestedTagName, arg.RequestedTagType)
	var i AddZmanRequestNewTagRow
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.RequestedTagName,
		&i.RequestedTagType,
		&i.IsNewTagRequest,
		&i.CreatedAt,
	)
	return i, err
}

const addZmanRequestTag = `-- name: AddZmanRequestTag :one
INSERT INTO zman_request_tags (
    request_id,
    tag_id,
    is_new_tag_request
) VALUES ($1, $2, false)
RETURNING id, request_id, tag_id, is_new_tag_request, created_at
`

type AddZmanRequestTagParams struct {
	RequestID int32  `json:"request_id"`
	TagID     *int32 `json:"tag_id"`
}

type AddZmanRequestTagRow struct {
	ID              int32              `json:"id"`
	RequestID       int32              `json:"request_id"`
	TagID           *int32             `json:"tag_id"`
	IsNewTagRequest bool               `json:"is_new_tag_request"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

// Add an existing tag to a zman request
func (q *Queries) AddZmanRequestTag(ctx context.Context, arg AddZmanRequestTagParams) (AddZmanRequestTagRow, error) {
	row := q.db.QueryRow(ctx, addZmanRequestTag, arg.RequestID, arg.TagID)
	var i AddZmanRequestTagRow
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.TagID,
		&i.IsNewTagRequest,
		&i.CreatedAt,
	)
	return i, err
}

const approveTagRequest = `-- name: ApproveTagRequest :one
INSERT INTO zman_tags (
    tag_key,
    display_name_hebrew,
    display_name_english_ashkenazi,
    display_name_english_sephardi,
    tag_type_id
) VALUES (
    $1, -- tag_key (generated from requested_tag_name)
    $2, -- display_name_hebrew
    $3, -- display_name_english_ashkenazi
    $4, -- display_name_english_sephardi (same as ashkenazi if not specified)
    (SELECT tt.id FROM tag_types tt WHERE tt.key = $5)  -- tag_type_id (from requested_tag_type key)
)
RETURNING id, tag_key, display_name_hebrew, display_name_english_ashkenazi, display_name_english_sephardi, tag_type_id, created_at
`

type ApproveTagRequestParams struct {
	TagKey                      string  `json:"tag_key"`
	DisplayNameHebrew           string  `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string  `json:"display_name_english_ashkenazi"`
	DisplayNameEnglishSephardi  *string `json:"display_name_english_sephardi"`
	Key                         string  `json:"key"`
}

type ApproveTagRequestRow struct {
	ID                          int32              `json:"id"`
	TagKey                      string             `json:"tag_key"`
	DisplayNameHebrew           string             `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string             `json:"display_name_english_ashkenazi"`
	DisplayNameEnglishSephardi  *string            `json:"display_name_english_sephardi"`
	TagTypeID                   int32              `json:"tag_type_id"`
	CreatedAt                   pgtype.Timestamptz `json:"created_at"`
}

// Approve a new tag request - creates the tag and updates the request
// Step 1: Create the new tag in zman_tags table
// This query only creates the tag, the caller must update the request separately
func (q *Queries) ApproveTagRequest(ctx context.Context, arg ApproveTagRequestParams) (ApproveTagRequestRow, error) {
	row := q.db.QueryRow(ctx, approveTagRequest,
		arg.TagKey,
		arg.DisplayNameHebrew,
		arg.DisplayNameEnglishAshkenazi,
		arg.DisplayNameEnglishSephardi,
		arg.Key,
	)
	var i ApproveTagRequestRow
	err := row.Scan(
		&i.ID,
		&i.TagKey,
		&i.DisplayNameHebrew,
		&i.DisplayNameEnglishAshkenazi,
		&i.DisplayNameEnglishSephardi,
		&i.TagTypeID,
		&i.CreatedAt,
	)
	return i, err
}

const approveZmanRequest = `-- name: ApproveZmanRequest :one
UPDATE zman_registry_requests
SET
    status_id = (SELECT rs.id FROM request_statuses rs WHERE rs.key = 'approved'),
    reviewed_by = $2,
    reviewed_at = NOW(),
    reviewer_notes = $3
WHERE zman_registry_requests.id = $1
RETURNING
    id, status_id, reviewed_by, reviewed_at, reviewer_notes,
    auto_add_on_approval, publisher_id
`

type ApproveZmanRequestParams struct {
	ID            int32   `json:"id"`
	ReviewedBy    *string `json:"reviewed_by"`
	ReviewerNotes *string `json:"reviewer_notes"`
}

type ApproveZmanRequestRow struct {
	ID                int32              `json:"id"`
	StatusID          int16              `json:"status_id"`
	ReviewedBy        *string            `json:"reviewed_by"`
	ReviewedAt        pgtype.Timestamptz `json:"reviewed_at"`
	ReviewerNotes     *string            `json:"reviewer_notes"`
	AutoAddOnApproval *bool              `json:"auto_add_on_approval"`
	PublisherID       int32              `json:"publisher_id"`
}

// Approve a zman request
func (q *Queries) ApproveZmanRequest(ctx context.Context, arg ApproveZmanRequestParams) (ApproveZmanRequestRow, error) {
	row := q.db.QueryRow(ctx, approveZmanRequest, arg.ID, arg.ReviewedBy, arg.ReviewerNotes)
	var i ApproveZmanRequestRow
	err := row.Scan(
		&i.ID,
		&i.StatusID,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewerNotes,
		&i.AutoAddOnApproval,
		&i.PublisherID,
	)
	return i, err
}

const createPublisherZmanFromRequest = `-- name: CreatePublisherZmanFromRequest :one
INSERT INTO publisher_zmanim (
    id, publisher_id, zman_key, hebrew_name, english_name,
    transliteration, description,
    formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, time_category_id,
    dependencies, current_version
)
SELECT
    gen_random_uuid() AS id,
    zrr.publisher_id AS publisher_id,
    zrr.requested_key AS zman_key,
    zrr.requested_hebrew_name AS hebrew_name,
    zrr.requested_english_name AS english_name,
    zrr.transliteration AS transliteration,
    zrr.description AS description,
    zrr.requested_formula_dsl AS formula_dsl,
    NULL AS ai_explanation,
    NULL AS publisher_comment,
    true AS is_enabled,
    true AS is_visible,
    false AS is_published,
    true AS is_custom,
    tc.id AS time_category_id,
    '{}'::text[] AS dependencies,
    1 AS current_version
FROM zman_registry_requests zrr
JOIN time_categories tc ON zrr.time_category_id = tc.id
WHERE zrr.id = $1
ON CONFLICT (publisher_id, zman_key) DO NOTHING
RETURNING id, publisher_id, zman_key, hebrew_name, english_name,
    transliteration, description, formula_dsl, ai_explanation, publisher_comment,
    is_enabled, is_visible, is_published, is_custom, time_category_id,
    dependencies, created_at, updated_at, current_version
`

type CreatePublisherZmanFromRequestRow struct {
	ID               int32              `json:"id"`
	PublisherID      int32              `json:"publisher_id"`
	ZmanKey          string             `json:"zman_key"`
	HebrewName       string             `json:"hebrew_name"`
	EnglishName      string             `json:"english_name"`
	Transliteration  *string            `json:"transliteration"`
	Description      *string            `json:"description"`
	FormulaDsl       string             `json:"formula_dsl"`
	AiExplanation    *string            `json:"ai_explanation"`
	PublisherComment *string            `json:"publisher_comment"`
	IsEnabled        bool               `json:"is_enabled"`
	IsVisible        bool               `json:"is_visible"`
	IsPublished      bool               `json:"is_published"`
	IsCustom         bool               `json:"is_custom"`
	TimeCategoryID   *int32             `json:"time_category_id"`
	Dependencies     []string           `json:"dependencies"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	CurrentVersion   *int32             `json:"current_version"`
}

// Create a publisher_zman entry from an approved zman request
// This is used when auto_add_on_approval is true
func (q *Queries) CreatePublisherZmanFromRequest(ctx context.Context, id int32) (CreatePublisherZmanFromRequestRow, error) {
	row := q.db.QueryRow(ctx, createPublisherZmanFromRequest, id)
	var i CreatePublisherZmanFromRequestRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.Transliteration,
		&i.Description,
		&i.FormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsCustom,
		&i.TimeCategoryID,
		&i.Dependencies,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrentVersion,
	)
	return i, err
}

const createZmanRequest = `-- name: CreateZmanRequest :one

INSERT INTO zman_registry_requests (
    publisher_id,
    requested_key,
    requested_hebrew_name,
    requested_english_name,
    transliteration,
    requested_formula_dsl,
    time_category_id,
    description,
    halachic_notes,
    halachic_source,
    publisher_email,
    publisher_name,
    auto_add_on_approval,
    status_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13,
    (SELECT rs.id FROM request_statuses rs WHERE rs.key = 'pending')
)
RETURNING
    id, publisher_id, requested_key, requested_hebrew_name, requested_english_name,
    transliteration, requested_formula_dsl, time_category_id, description,
    halachic_notes, halachic_source, publisher_email, publisher_name, auto_add_on_approval,
    status_id, created_at
`

type CreateZmanRequestParams struct {
	PublisherID          int32   `json:"publisher_id"`
	RequestedKey         string  `json:"requested_key"`
	RequestedHebrewName  string  `json:"requested_hebrew_name"`
	RequestedEnglishName string  `json:"requested_english_name"`
	Transliteration      *string `json:"transliteration"`
	RequestedFormulaDsl  *string `json:"requested_formula_dsl"`
	TimeCategoryID       int32   `json:"time_category_id"`
	Description          *string `json:"description"`
	HalachicNotes        *string `json:"halachic_notes"`
	HalachicSource       *string `json:"halachic_source"`
	PublisherEmail       *string `json:"publisher_email"`
	PublisherName        *string `json:"publisher_name"`
	AutoAddOnApproval    *bool   `json:"auto_add_on_approval"`
}

type CreateZmanRequestRow struct {
	ID                   int32              `json:"id"`
	PublisherID          int32              `json:"publisher_id"`
	RequestedKey         string             `json:"requested_key"`
	RequestedHebrewName  string             `json:"requested_hebrew_name"`
	RequestedEnglishName string             `json:"requested_english_name"`
	Transliteration      *string            `json:"transliteration"`
	RequestedFormulaDsl  *string            `json:"requested_formula_dsl"`
	TimeCategoryID       int32              `json:"time_category_id"`
	Description          *string            `json:"description"`
	HalachicNotes        *string            `json:"halachic_notes"`
	HalachicSource       *string            `json:"halachic_source"`
	PublisherEmail       *string            `json:"publisher_email"`
	PublisherName        *string            `json:"publisher_name"`
	AutoAddOnApproval    *bool              `json:"auto_add_on_approval"`
	StatusID             int16              `json:"status_id"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
}

// Zman Request Queries
// Epic 5, Story 5.0: Enhanced Zman Registry Requests
// Create a new zman request from a publisher
func (q *Queries) CreateZmanRequest(ctx context.Context, arg CreateZmanRequestParams) (CreateZmanRequestRow, error) {
	row := q.db.QueryRow(ctx, createZmanRequest,
		arg.PublisherID,
		arg.RequestedKey,
		arg.RequestedHebrewName,
		arg.RequestedEnglishName,
		arg.Transliteration,
		arg.RequestedFormulaDsl,
		arg.TimeCategoryID,
		arg.Description,
		arg.HalachicNotes,
		arg.HalachicSource,
		arg.PublisherEmail,
		arg.PublisherName,
		arg.AutoAddOnApproval,
	)
	var i CreateZmanRequestRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.RequestedKey,
		&i.RequestedHebrewName,
		&i.RequestedEnglishName,
		&i.Transliteration,
		&i.RequestedFormulaDsl,
		&i.TimeCategoryID,
		&i.Description,
		&i.HalachicNotes,
		&i.HalachicSource,
		&i.PublisherEmail,
		&i.PublisherName,
		&i.AutoAddOnApproval,
		&i.StatusID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteZmanRequestTags = `-- name: DeleteZmanRequestTags :exec
DELETE FROM zman_request_tags WHERE request_id = $1
`

// Delete all tags for a zman request (used when updating request)
func (q *Queries) DeleteZmanRequestTags(ctx context.Context, requestID int32) error {
	_, err := q.db.Exec(ctx, deleteZmanRequestTags, requestID)
	return err
}

const findTagByTagKey = `-- name: FindTagByTagKey :one
SELECT
    zt.id,
    zt.tag_key,
    zt.display_name_hebrew,
    zt.display_name_english_ashkenazi,
    zt.display_name_english_sephardi,
    zt.tag_type_id,
    tt.key as tag_type,
    zt.created_at
FROM zman_tags zt
JOIN tag_types tt ON zt.tag_type_id = tt.id
WHERE LOWER(zt.tag_key) = LOWER($1)
LIMIT 1
`

type FindTagByTagKeyRow struct {
	ID                          int32              `json:"id"`
	TagKey                      string             `json:"tag_key"`
	DisplayNameHebrew           string             `json:"display_name_hebrew"`
	DisplayNameEnglishAshkenazi string             `json:"display_name_english_ashkenazi"`
	DisplayNameEnglishSephardi  *string            `json:"display_name_english_sephardi"`
	TagTypeID                   int32              `json:"tag_type_id"`
	TagType                     string             `json:"tag_type"`
	CreatedAt                   pgtype.Timestamptz `json:"created_at"`
}

// Find an existing tag by tag_key (case-insensitive match)
func (q *Queries) FindTagByTagKey(ctx context.Context, lower string) (FindTagByTagKeyRow, error) {
	row := q.db.QueryRow(ctx, findTagByTagKey, lower)
	var i FindTagByTagKeyRow
	err := row.Scan(
		&i.ID,
		&i.TagKey,
		&i.DisplayNameHebrew,
		&i.DisplayNameEnglishAshkenazi,
		&i.DisplayNameEnglishSephardi,
		&i.TagTypeID,
		&i.TagType,
		&i.CreatedAt,
	)
	return i, err
}

const getAllZmanRequests = `-- name: GetAllZmanRequests :many
SELECT
    zrr.id,
    zrr.publisher_id,
    zrr.requested_key,
    zrr.requested_hebrew_name,
    zrr.requested_english_name,
    zrr.transliteration,
    zrr.time_category_id,
    tc.key as time_category,
    zrr.status_id,
    rs.key as status,
    zrr.reviewed_by,
    zrr.reviewed_at,
    zrr.created_at,
    p.name as publisher_name
FROM zman_registry_requests zrr
JOIN publishers p ON zrr.publisher_id = p.id
JOIN request_statuses rs ON zrr.status_id = rs.id
JOIN time_categories tc ON zrr.time_category_id = tc.id
WHERE ($1::text IS NULL OR rs.key = $1)
ORDER BY
    CASE WHEN rs.key = 'pending' THEN 0 ELSE 1 END,
    zrr.created_at DESC
`

type GetAllZmanRequestsRow struct {
	ID                   int32              `json:"id"`
	PublisherID          int32              `json:"publisher_id"`
	RequestedKey         string             `json:"requested_key"`
	RequestedHebrewName  string             `json:"requested_hebrew_name"`
	RequestedEnglishName string             `json:"requested_english_name"`
	Transliteration      *string            `json:"transliteration"`
	TimeCategoryID       int32              `json:"time_category_id"`
	TimeCategory         string             `json:"time_category"`
	StatusID             int16              `json:"status_id"`
	Status               string             `json:"status"`
	ReviewedBy           *string            `json:"reviewed_by"`
	ReviewedAt           pgtype.Timestamptz `json:"reviewed_at"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	PublisherName        string             `json:"publisher_name"`
}

// Get all zman requests (for admin) with optional status filter
func (q *Queries) GetAllZmanRequests(ctx context.Context, dollar_1 string) ([]GetAllZmanRequestsRow, error) {
	rows, err := q.db.Query(ctx, getAllZmanRequests, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllZmanRequestsRow{}
	for rows.Next() {
		var i GetAllZmanRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.RequestedKey,
			&i.RequestedHebrewName,
			&i.RequestedEnglishName,
			&i.Transliteration,
			&i.TimeCategoryID,
			&i.TimeCategory,
			&i.StatusID,
			&i.Status,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.CreatedAt,
			&i.PublisherName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingZmanRequestCount = `-- name: GetPendingZmanRequestCount :one
SELECT COUNT(*) as count
FROM zman_registry_requests zrr
JOIN request_statuses rs ON zrr.status_id = rs.id
WHERE rs.key = 'pending'
`

// Get count of pending zman requests (for admin dashboard)
func (q *Queries) GetPendingZmanRequestCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getPendingZmanRequestCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPublisherZmanRequests = `-- name: GetPublisherZmanRequests :many
SELECT
    zrr.id,
    zrr.publisher_id,
    zrr.requested_key,
    zrr.requested_hebrew_name,
    zrr.requested_english_name,
    zrr.transliteration,
    zrr.time_category_id,
    tc.key as time_category,
    zrr.status_id,
    rs.key as status,
    zrr.reviewed_at,
    zrr.reviewer_notes,
    zrr.created_at
FROM zman_registry_requests zrr
JOIN request_statuses rs ON zrr.status_id = rs.id
JOIN time_categories tc ON zrr.time_category_id = tc.id
WHERE zrr.publisher_id = $1
ORDER BY zrr.created_at DESC
`

type GetPublisherZmanRequestsRow struct {
	ID                   int32              `json:"id"`
	PublisherID          int32              `json:"publisher_id"`
	RequestedKey         string             `json:"requested_key"`
	RequestedHebrewName  string             `json:"requested_hebrew_name"`
	RequestedEnglishName string             `json:"requested_english_name"`
	Transliteration      *string            `json:"transliteration"`
	TimeCategoryID       int32              `json:"time_category_id"`
	TimeCategory         string             `json:"time_category"`
	StatusID             int16              `json:"status_id"`
	Status               string             `json:"status"`
	ReviewedAt           pgtype.Timestamptz `json:"reviewed_at"`
	ReviewerNotes        *string            `json:"reviewer_notes"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
}

// Get all zman requests for a specific publisher
func (q *Queries) GetPublisherZmanRequests(ctx context.Context, publisherID int32) ([]GetPublisherZmanRequestsRow, error) {
	rows, err := q.db.Query(ctx, getPublisherZmanRequests, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherZmanRequestsRow{}
	for rows.Next() {
		var i GetPublisherZmanRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.RequestedKey,
			&i.RequestedHebrewName,
			&i.RequestedEnglishName,
			&i.Transliteration,
			&i.TimeCategoryID,
			&i.TimeCategory,
			&i.StatusID,
			&i.Status,
			&i.ReviewedAt,
			&i.ReviewerNotes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getZmanRequest = `-- name: GetZmanRequest :one
SELECT
    zrr.id,
    zrr.publisher_id,
    zrr.requested_key,
    zrr.requested_hebrew_name,
    zrr.requested_english_name,
    zrr.transliteration,
    zrr.requested_formula_dsl,
    zrr.time_category_id,
    tc.key as time_category,
    zrr.description,
    zrr.halachic_notes,
    zrr.halachic_source,
    zrr.publisher_email,
    zrr.publisher_name,
    zrr.auto_add_on_approval,
    zrr.status_id,
    rs.key as status,
    zrr.reviewed_by,
    zrr.reviewed_at,
    zrr.reviewer_notes,
    zrr.created_at,
    p.name as submitter_name
FROM zman_registry_requests zrr
JOIN publishers p ON zrr.publisher_id = p.id
JOIN request_statuses rs ON zrr.status_id = rs.id
JOIN time_categories tc ON zrr.time_category_id = tc.id
WHERE zrr.id = $1
`

type GetZmanRequestRow struct {
	ID                   int32              `json:"id"`
	PublisherID          int32              `json:"publisher_id"`
	RequestedKey         string             `json:"requested_key"`
	RequestedHebrewName  string             `json:"requested_hebrew_name"`
	RequestedEnglishName string             `json:"requested_english_name"`
	Transliteration      *string            `json:"transliteration"`
	RequestedFormulaDsl  *string            `json:"requested_formula_dsl"`
	TimeCategoryID       int32              `json:"time_category_id"`
	TimeCategory         string             `json:"time_category"`
	Description          *string            `json:"description"`
	HalachicNotes        *string            `json:"halachic_notes"`
	HalachicSource       *string            `json:"halachic_source"`
	PublisherEmail       *string            `json:"publisher_email"`
	PublisherName        *string            `json:"publisher_name"`
	AutoAddOnApproval    *bool              `json:"auto_add_on_approval"`
	StatusID             int16              `json:"status_id"`
	Status               string             `json:"status"`
	ReviewedBy           *string            `json:"reviewed_by"`
	ReviewedAt           pgtype.Timestamptz `json:"reviewed_at"`
	ReviewerNotes        *string            `json:"reviewer_notes"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	SubmitterName        string             `json:"submitter_name"`
}

// Get a specific zman request by ID
func (q *Queries) GetZmanRequest(ctx context.Context, id int32) (GetZmanRequestRow, error) {
	row := q.db.QueryRow(ctx, getZmanRequest, id)
	var i GetZmanRequestRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.RequestedKey,
		&i.RequestedHebrewName,
		&i.RequestedEnglishName,
		&i.Transliteration,
		&i.RequestedFormulaDsl,
		&i.TimeCategoryID,
		&i.TimeCategory,
		&i.Description,
		&i.HalachicNotes,
		&i.HalachicSource,
		&i.PublisherEmail,
		&i.PublisherName,
		&i.AutoAddOnApproval,
		&i.StatusID,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewerNotes,
		&i.CreatedAt,
		&i.SubmitterName,
	)
	return i, err
}

const getZmanRequestTag = `-- name: GetZmanRequestTag :one
SELECT
    zrt.id,
    zrt.request_id,
    zrt.tag_id,
    zrt.requested_tag_name,
    zrt.requested_tag_type,
    zrt.is_new_tag_request,
    zrt.created_at
FROM zman_request_tags zrt
WHERE zrt.id = $1
`

// Get a specific tag request by ID
func (q *Queries) GetZmanRequestTag(ctx context.Context, id int32) (ZmanRequestTag, error) {
	row := q.db.QueryRow(ctx, getZmanRequestTag, id)
	var i ZmanRequestTag
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.TagID,
		&i.RequestedTagName,
		&i.RequestedTagType,
		&i.IsNewTagRequest,
		&i.CreatedAt,
	)
	return i, err
}

const getZmanRequestTags = `-- name: GetZmanRequestTags :many
SELECT
    zrt.id,
    zrt.request_id,
    zrt.tag_id,
    zrt.requested_tag_name,
    zrt.requested_tag_type,
    zrt.is_new_tag_request,
    zrt.created_at,
    zt.tag_key as existing_tag_key,
    zt.display_name_english_ashkenazi as existing_tag_name_ashkenazi,
    zt.display_name_english_sephardi as existing_tag_name_sephardi,
    zt.tag_type_id as existing_tag_type_id,
    tt.key as existing_tag_type
FROM zman_request_tags zrt
LEFT JOIN zman_tags zt ON zrt.tag_id = zt.id
LEFT JOIN tag_types tt ON zt.tag_type_id = tt.id
WHERE zrt.request_id = $1
`

type GetZmanRequestTagsRow struct {
	ID                       int32              `json:"id"`
	RequestID                int32              `json:"request_id"`
	TagID                    *int32             `json:"tag_id"`
	RequestedTagName         *string            `json:"requested_tag_name"`
	RequestedTagType         *string            `json:"requested_tag_type"`
	IsNewTagRequest          bool               `json:"is_new_tag_request"`
	CreatedAt                pgtype.Timestamptz `json:"created_at"`
	ExistingTagKey           *string            `json:"existing_tag_key"`
	ExistingTagNameAshkenazi *string            `json:"existing_tag_name_ashkenazi"`
	ExistingTagNameSephardi  *string            `json:"existing_tag_name_sephardi"`
	ExistingTagTypeID        *int32             `json:"existing_tag_type_id"`
	ExistingTagType          *string            `json:"existing_tag_type"`
}

// Get all tags (existing and requested) for a zman request
func (q *Queries) GetZmanRequestTags(ctx context.Context, requestID int32) ([]GetZmanRequestTagsRow, error) {
	rows, err := q.db.Query(ctx, getZmanRequestTags, requestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetZmanRequestTagsRow{}
	for rows.Next() {
		var i GetZmanRequestTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.RequestID,
			&i.TagID,
			&i.RequestedTagName,
			&i.RequestedTagType,
			&i.IsNewTagRequest,
			&i.CreatedAt,
			&i.ExistingTagKey,
			&i.ExistingTagNameAshkenazi,
			&i.ExistingTagNameSephardi,
			&i.ExistingTagTypeID,
			&i.ExistingTagType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkTagToRequest = `-- name: LinkTagToRequest :exec
UPDATE zman_request_tags
SET
    tag_id = $2,
    is_new_tag_request = false,
    requested_tag_name = NULL,
    requested_tag_type = NULL
WHERE id = $1
`

type LinkTagToRequestParams struct {
	ID    int32  `json:"id"`
	TagID *int32 `json:"tag_id"`
}

// Update the tag request to link the newly created tag
// Must also clear requested_tag_name to satisfy tag_reference_check constraint
func (q *Queries) LinkTagToRequest(ctx context.Context, arg LinkTagToRequestParams) error {
	_, err := q.db.Exec(ctx, linkTagToRequest, arg.ID, arg.TagID)
	return err
}

const rejectTagRequest = `-- name: RejectTagRequest :exec
DELETE FROM zman_request_tags
WHERE id = $1 AND is_new_tag_request = true
`

// Reject a new tag request by deleting it from zman_request_tags
func (q *Queries) RejectTagRequest(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, rejectTagRequest, id)
	return err
}

const rejectZmanRequest = `-- name: RejectZmanRequest :one
UPDATE zman_registry_requests
SET
    status_id = (SELECT rs.id FROM request_statuses rs WHERE rs.key = 'rejected'),
    reviewed_by = $2,
    reviewed_at = NOW(),
    reviewer_notes = $3
WHERE zman_registry_requests.id = $1
RETURNING id, status_id, reviewed_by, reviewed_at, reviewer_notes
`

type RejectZmanRequestParams struct {
	ID            int32   `json:"id"`
	ReviewedBy    *string `json:"reviewed_by"`
	ReviewerNotes *string `json:"reviewer_notes"`
}

type RejectZmanRequestRow struct {
	ID            int32              `json:"id"`
	StatusID      int16              `json:"status_id"`
	ReviewedBy    *string            `json:"reviewed_by"`
	ReviewedAt    pgtype.Timestamptz `json:"reviewed_at"`
	ReviewerNotes *string            `json:"reviewer_notes"`
}

// Reject a zman request
func (q *Queries) RejectZmanRequest(ctx context.Context, arg RejectZmanRequestParams) (RejectZmanRequestRow, error) {
	row := q.db.QueryRow(ctx, rejectZmanRequest, arg.ID, arg.ReviewedBy, arg.ReviewerNotes)
	var i RejectZmanRequestRow
	err := row.Scan(
		&i.ID,
		&i.StatusID,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewerNotes,
	)
	return i, err
}
