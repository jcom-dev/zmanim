// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: location_overrides.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkLocalityElevationOverrideExists = `-- name: CheckLocalityElevationOverrideExists :one
SELECT EXISTS(
    SELECT 1 FROM geo_locality_elevations
    WHERE locality_id = $1::int
      AND (
        ($2::int IS NULL AND publisher_id IS NULL) OR
        (publisher_id = $2::int)
      )
      AND source_id = $3::int
) AS exists
`

type CheckLocalityElevationOverrideExistsParams struct {
	LocalityID  int32  `json:"locality_id"`
	PublisherID *int32 `json:"publisher_id"`
	SourceID    int32  `json:"source_id"`
}

func (q *Queries) CheckLocalityElevationOverrideExists(ctx context.Context, arg CheckLocalityElevationOverrideExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkLocalityElevationOverrideExists, arg.LocalityID, arg.PublisherID, arg.SourceID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkLocalityLocationOverrideExists = `-- name: CheckLocalityLocationOverrideExists :one

SELECT EXISTS(
    SELECT 1 FROM geo_locality_locations
    WHERE locality_id = $1::int
      AND (
        ($2::int IS NULL AND publisher_id IS NULL) OR
        (publisher_id = $2::int)
      )
      AND source_id = $3::int
) AS exists
`

type CheckLocalityLocationOverrideExistsParams struct {
	LocalityID  int32  `json:"locality_id"`
	PublisherID *int32 `json:"publisher_id"`
	SourceID    int32  `json:"source_id"`
}

// ============================================
// Existence Checks
// ============================================
func (q *Queries) CheckLocalityLocationOverrideExists(ctx context.Context, arg CheckLocalityLocationOverrideExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkLocalityLocationOverrideExists, arg.LocalityID, arg.PublisherID, arg.SourceID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createLocalityElevationOverride = `-- name: CreateLocalityElevationOverride :one

INSERT INTO geo_locality_elevations (
    locality_id, publisher_id, source_id, elevation_m,
    accuracy_m, reason, created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, locality_id, publisher_id, source_id, elevation_m, accuracy_m, reason, created_at, updated_at, created_by
`

type CreateLocalityElevationOverrideParams struct {
	LocalityID  int32   `json:"locality_id"`
	PublisherID *int32  `json:"publisher_id"`
	SourceID    int32   `json:"source_id"`
	ElevationM  int32   `json:"elevation_m"`
	AccuracyM   *int32  `json:"accuracy_m"`
	Reason      *string `json:"reason"`
	CreatedBy   *string `json:"created_by"`
}

// ============================================
// Elevation Override CRUD
// ============================================
func (q *Queries) CreateLocalityElevationOverride(ctx context.Context, arg CreateLocalityElevationOverrideParams) (GeoLocalityElevation, error) {
	row := q.db.QueryRow(ctx, createLocalityElevationOverride,
		arg.LocalityID,
		arg.PublisherID,
		arg.SourceID,
		arg.ElevationM,
		arg.AccuracyM,
		arg.Reason,
		arg.CreatedBy,
	)
	var i GeoLocalityElevation
	err := row.Scan(
		&i.ID,
		&i.LocalityID,
		&i.PublisherID,
		&i.SourceID,
		&i.ElevationM,
		&i.AccuracyM,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const createLocalityLocationOverride = `-- name: CreateLocalityLocationOverride :one



INSERT INTO geo_locality_locations (
    locality_id, publisher_id, source_id, latitude, longitude,
    accuracy_m, reason, created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, locality_id, publisher_id, source_id, latitude, longitude, accuracy_m, reason, created_at, updated_at, created_by
`

type CreateLocalityLocationOverrideParams struct {
	LocalityID  int32   `json:"locality_id"`
	PublisherID *int32  `json:"publisher_id"`
	SourceID    int32   `json:"source_id"`
	Latitude    float64 `json:"latitude"`
	Longitude   float64 `json:"longitude"`
	AccuracyM   *int32  `json:"accuracy_m"`
	Reason      *string `json:"reason"`
	CreatedBy   *string `json:"created_by"`
}

type CreateLocalityLocationOverrideRow struct {
	ID          int32              `json:"id"`
	LocalityID  int32              `json:"locality_id"`
	PublisherID *int32             `json:"publisher_id"`
	SourceID    int32              `json:"source_id"`
	Latitude    float64            `json:"latitude"`
	Longitude   float64            `json:"longitude"`
	AccuracyM   *int32             `json:"accuracy_m"`
	Reason      *string            `json:"reason"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	CreatedBy   *string            `json:"created_by"`
}

// ============================================
// Location Override Queries
// Hierarchical location/elevation management
// ============================================
// ============================================
// Resolution Function Query
// ============================================
// NOTE: get_effective_locality_location() is implemented in locality_locations_manual.go
// SQLc cannot introspect PostgreSQL functions that return TABLE(...)
// ============================================
// Location Override CRUD
// ============================================
func (q *Queries) CreateLocalityLocationOverride(ctx context.Context, arg CreateLocalityLocationOverrideParams) (CreateLocalityLocationOverrideRow, error) {
	row := q.db.QueryRow(ctx, createLocalityLocationOverride,
		arg.LocalityID,
		arg.PublisherID,
		arg.SourceID,
		arg.Latitude,
		arg.Longitude,
		arg.AccuracyM,
		arg.Reason,
		arg.CreatedBy,
	)
	var i CreateLocalityLocationOverrideRow
	err := row.Scan(
		&i.ID,
		&i.LocalityID,
		&i.PublisherID,
		&i.SourceID,
		&i.Latitude,
		&i.Longitude,
		&i.AccuracyM,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const deleteLocalityElevationOverride = `-- name: DeleteLocalityElevationOverride :exec
DELETE FROM geo_locality_elevations WHERE id = $1
`

func (q *Queries) DeleteLocalityElevationOverride(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteLocalityElevationOverride, id)
	return err
}

const deleteLocalityLocationOverride = `-- name: DeleteLocalityLocationOverride :exec
DELETE FROM geo_locality_locations WHERE id = $1
`

func (q *Queries) DeleteLocalityLocationOverride(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteLocalityLocationOverride, id)
	return err
}

const getAdminElevationOverrides = `-- name: GetAdminElevationOverrides :many
SELECT
    le.id,
    le.locality_id,
    l.name as locality_name,
    c.name as country_name,
    le.elevation_m,
    le.reason,
    le.created_by,
    le.created_at,
    le.updated_at
FROM geo_locality_elevations le
JOIN geo_localities l ON l.id = le.locality_id
JOIN geo_countries c ON c.id = l.country_id
JOIN geo_data_sources s ON s.id = le.source_id
WHERE le.publisher_id IS NULL AND s.key = 'admin'
ORDER BY le.updated_at DESC
`

type GetAdminElevationOverridesRow struct {
	ID           int32              `json:"id"`
	LocalityID   int32              `json:"locality_id"`
	LocalityName string             `json:"locality_name"`
	CountryName  string             `json:"country_name"`
	ElevationM   int32              `json:"elevation_m"`
	Reason       *string            `json:"reason"`
	CreatedBy    *string            `json:"created_by"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

// Returns all system-wide admin elevation overrides
func (q *Queries) GetAdminElevationOverrides(ctx context.Context) ([]GetAdminElevationOverridesRow, error) {
	rows, err := q.db.Query(ctx, getAdminElevationOverrides)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAdminElevationOverridesRow{}
	for rows.Next() {
		var i GetAdminElevationOverridesRow
		if err := rows.Scan(
			&i.ID,
			&i.LocalityID,
			&i.LocalityName,
			&i.CountryName,
			&i.ElevationM,
			&i.Reason,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAdminLocationOverrides = `-- name: GetAdminLocationOverrides :many

SELECT
    ll.id,
    ll.locality_id,
    l.name as locality_name,
    c.name as country_name,
    ll.latitude,
    ll.longitude,
    ll.reason,
    ll.created_by,
    ll.created_at,
    ll.updated_at
FROM geo_locality_locations ll
JOIN geo_localities l ON l.id = ll.locality_id
JOIN geo_countries c ON c.id = l.country_id
JOIN geo_data_sources s ON s.id = ll.source_id
WHERE ll.publisher_id IS NULL AND s.key = 'admin'
ORDER BY ll.updated_at DESC
`

type GetAdminLocationOverridesRow struct {
	ID           int32              `json:"id"`
	LocalityID   int32              `json:"locality_id"`
	LocalityName string             `json:"locality_name"`
	CountryName  string             `json:"country_name"`
	Latitude     float64            `json:"latitude"`
	Longitude    float64            `json:"longitude"`
	Reason       *string            `json:"reason"`
	CreatedBy    *string            `json:"created_by"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

// ============================================
// Admin Override Queries
// ============================================
// Returns all system-wide admin location overrides
func (q *Queries) GetAdminLocationOverrides(ctx context.Context) ([]GetAdminLocationOverridesRow, error) {
	rows, err := q.db.Query(ctx, getAdminLocationOverrides)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAdminLocationOverridesRow{}
	for rows.Next() {
		var i GetAdminLocationOverridesRow
		if err := rows.Scan(
			&i.ID,
			&i.LocalityID,
			&i.LocalityName,
			&i.CountryName,
			&i.Latitude,
			&i.Longitude,
			&i.Reason,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocalityElevationOverrideByID = `-- name: GetLocalityElevationOverrideByID :one
SELECT id, locality_id, publisher_id, source_id, elevation_m, accuracy_m, reason, created_at, updated_at, created_by FROM geo_locality_elevations WHERE id = $1
`

func (q *Queries) GetLocalityElevationOverrideByID(ctx context.Context, id int32) (GeoLocalityElevation, error) {
	row := q.db.QueryRow(ctx, getLocalityElevationOverrideByID, id)
	var i GeoLocalityElevation
	err := row.Scan(
		&i.ID,
		&i.LocalityID,
		&i.PublisherID,
		&i.SourceID,
		&i.ElevationM,
		&i.AccuracyM,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getLocalityElevationOverrides = `-- name: GetLocalityElevationOverrides :many
SELECT
    le.id,
    le.locality_id,
    le.publisher_id,
    le.source_id,
    s.key as source_key,
    s.name as source_name,
    le.elevation_m,
    le.accuracy_m,
    le.reason,
    le.created_at,
    le.updated_at,
    le.created_by,
    p.name as publisher_name
FROM geo_locality_elevations le
JOIN geo_data_sources s ON s.id = le.source_id
LEFT JOIN publishers p ON p.id = le.publisher_id
WHERE le.locality_id = $1
ORDER BY
    CASE WHEN le.publisher_id IS NOT NULL THEN 0 ELSE 1 END,
    s.priority
`

type GetLocalityElevationOverridesRow struct {
	ID            int32              `json:"id"`
	LocalityID    int32              `json:"locality_id"`
	PublisherID   *int32             `json:"publisher_id"`
	SourceID      int32              `json:"source_id"`
	SourceKey     string             `json:"source_key"`
	SourceName    string             `json:"source_name"`
	ElevationM    int32              `json:"elevation_m"`
	AccuracyM     *int32             `json:"accuracy_m"`
	Reason        *string            `json:"reason"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	CreatedBy     *string            `json:"created_by"`
	PublisherName *string            `json:"publisher_name"`
}

// Returns all elevation overrides for a locality
func (q *Queries) GetLocalityElevationOverrides(ctx context.Context, localityID int32) ([]GetLocalityElevationOverridesRow, error) {
	rows, err := q.db.Query(ctx, getLocalityElevationOverrides, localityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLocalityElevationOverridesRow{}
	for rows.Next() {
		var i GetLocalityElevationOverridesRow
		if err := rows.Scan(
			&i.ID,
			&i.LocalityID,
			&i.PublisherID,
			&i.SourceID,
			&i.SourceKey,
			&i.SourceName,
			&i.ElevationM,
			&i.AccuracyM,
			&i.Reason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.PublisherName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocalityLocationOverrideByID = `-- name: GetLocalityLocationOverrideByID :one
SELECT id, locality_id, publisher_id, source_id, latitude, longitude, accuracy_m, reason, created_at, updated_at, created_by FROM geo_locality_locations WHERE id = $1
`

type GetLocalityLocationOverrideByIDRow struct {
	ID          int32              `json:"id"`
	LocalityID  int32              `json:"locality_id"`
	PublisherID *int32             `json:"publisher_id"`
	SourceID    int32              `json:"source_id"`
	Latitude    float64            `json:"latitude"`
	Longitude   float64            `json:"longitude"`
	AccuracyM   *int32             `json:"accuracy_m"`
	Reason      *string            `json:"reason"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	CreatedBy   *string            `json:"created_by"`
}

func (q *Queries) GetLocalityLocationOverrideByID(ctx context.Context, id int32) (GetLocalityLocationOverrideByIDRow, error) {
	row := q.db.QueryRow(ctx, getLocalityLocationOverrideByID, id)
	var i GetLocalityLocationOverrideByIDRow
	err := row.Scan(
		&i.ID,
		&i.LocalityID,
		&i.PublisherID,
		&i.SourceID,
		&i.Latitude,
		&i.Longitude,
		&i.AccuracyM,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getLocalityLocationOverrides = `-- name: GetLocalityLocationOverrides :many

SELECT
    ll.id,
    ll.locality_id,
    ll.publisher_id,
    ll.source_id,
    s.key as source_key,
    s.name as source_name,
    ll.latitude,
    ll.longitude,
    ll.accuracy_m,
    ll.reason,
    ll.created_at,
    ll.updated_at,
    ll.created_by,
    p.name as publisher_name
FROM geo_locality_locations ll
JOIN geo_data_sources s ON s.id = ll.source_id
LEFT JOIN publishers p ON p.id = ll.publisher_id
WHERE ll.locality_id = $1
ORDER BY
    CASE WHEN ll.publisher_id IS NOT NULL THEN 0 ELSE 1 END,
    s.priority
`

type GetLocalityLocationOverridesRow struct {
	ID            int32              `json:"id"`
	LocalityID    int32              `json:"locality_id"`
	PublisherID   *int32             `json:"publisher_id"`
	SourceID      int32              `json:"source_id"`
	SourceKey     string             `json:"source_key"`
	SourceName    string             `json:"source_name"`
	Latitude      float64            `json:"latitude"`
	Longitude     float64            `json:"longitude"`
	AccuracyM     *int32             `json:"accuracy_m"`
	Reason        *string            `json:"reason"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	CreatedBy     *string            `json:"created_by"`
	PublisherName *string            `json:"publisher_name"`
}

// ============================================
// List Overrides by Locality (Admin View)
// ============================================
// Returns all location overrides for a locality (shows all sources)
func (q *Queries) GetLocalityLocationOverrides(ctx context.Context, localityID int32) ([]GetLocalityLocationOverridesRow, error) {
	rows, err := q.db.Query(ctx, getLocalityLocationOverrides, localityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLocalityLocationOverridesRow{}
	for rows.Next() {
		var i GetLocalityLocationOverridesRow
		if err := rows.Scan(
			&i.ID,
			&i.LocalityID,
			&i.PublisherID,
			&i.SourceID,
			&i.SourceKey,
			&i.SourceName,
			&i.Latitude,
			&i.Longitude,
			&i.AccuracyM,
			&i.Reason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.PublisherName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherElevationOverrideByLocality = `-- name: GetPublisherElevationOverrideByLocality :one
SELECT
    le.id,
    le.locality_id,
    le.elevation_m,
    le.reason,
    le.created_at,
    le.updated_at
FROM geo_locality_elevations le
WHERE le.publisher_id = $1 AND le.locality_id = $2
LIMIT 1
`

type GetPublisherElevationOverrideByLocalityParams struct {
	PublisherID *int32 `json:"publisher_id"`
	LocalityID  int32  `json:"locality_id"`
}

type GetPublisherElevationOverrideByLocalityRow struct {
	ID         int32              `json:"id"`
	LocalityID int32              `json:"locality_id"`
	ElevationM int32              `json:"elevation_m"`
	Reason     *string            `json:"reason"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
}

// Get a publisher's specific elevation override for a locality
func (q *Queries) GetPublisherElevationOverrideByLocality(ctx context.Context, arg GetPublisherElevationOverrideByLocalityParams) (GetPublisherElevationOverrideByLocalityRow, error) {
	row := q.db.QueryRow(ctx, getPublisherElevationOverrideByLocality, arg.PublisherID, arg.LocalityID)
	var i GetPublisherElevationOverrideByLocalityRow
	err := row.Scan(
		&i.ID,
		&i.LocalityID,
		&i.ElevationM,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPublisherElevationOverrides = `-- name: GetPublisherElevationOverrides :many
SELECT
    le.id,
    le.locality_id,
    l.name as locality_name,
    c.name as country_name,
    le.elevation_m,
    le.reason,
    le.created_at,
    le.updated_at
FROM geo_locality_elevations le
JOIN geo_localities l ON l.id = le.locality_id
JOIN geo_countries c ON c.id = l.country_id
WHERE le.publisher_id = $1
ORDER BY le.updated_at DESC
`

type GetPublisherElevationOverridesRow struct {
	ID           int32              `json:"id"`
	LocalityID   int32              `json:"locality_id"`
	LocalityName string             `json:"locality_name"`
	CountryName  string             `json:"country_name"`
	ElevationM   int32              `json:"elevation_m"`
	Reason       *string            `json:"reason"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

// Returns all elevation overrides for a specific publisher
func (q *Queries) GetPublisherElevationOverrides(ctx context.Context, publisherID *int32) ([]GetPublisherElevationOverridesRow, error) {
	rows, err := q.db.Query(ctx, getPublisherElevationOverrides, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherElevationOverridesRow{}
	for rows.Next() {
		var i GetPublisherElevationOverridesRow
		if err := rows.Scan(
			&i.ID,
			&i.LocalityID,
			&i.LocalityName,
			&i.CountryName,
			&i.ElevationM,
			&i.Reason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherLocationOverrideByLocality = `-- name: GetPublisherLocationOverrideByLocality :one
SELECT
    ll.id,
    ll.locality_id,
    ll.latitude,
    ll.longitude,
    ll.reason,
    ll.created_at,
    ll.updated_at
FROM geo_locality_locations ll
WHERE ll.publisher_id = $1 AND ll.locality_id = $2
LIMIT 1
`

type GetPublisherLocationOverrideByLocalityParams struct {
	PublisherID *int32 `json:"publisher_id"`
	LocalityID  int32  `json:"locality_id"`
}

type GetPublisherLocationOverrideByLocalityRow struct {
	ID         int32              `json:"id"`
	LocalityID int32              `json:"locality_id"`
	Latitude   float64            `json:"latitude"`
	Longitude  float64            `json:"longitude"`
	Reason     *string            `json:"reason"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
}

// Get a publisher's specific override for a locality
func (q *Queries) GetPublisherLocationOverrideByLocality(ctx context.Context, arg GetPublisherLocationOverrideByLocalityParams) (GetPublisherLocationOverrideByLocalityRow, error) {
	row := q.db.QueryRow(ctx, getPublisherLocationOverrideByLocality, arg.PublisherID, arg.LocalityID)
	var i GetPublisherLocationOverrideByLocalityRow
	err := row.Scan(
		&i.ID,
		&i.LocalityID,
		&i.Latitude,
		&i.Longitude,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPublisherLocationOverridesNew = `-- name: GetPublisherLocationOverridesNew :many

SELECT
    ll.id,
    ll.locality_id,
    l.name as locality_name,
    c.name as country_name,
    ll.latitude,
    ll.longitude,
    ll.reason,
    ll.created_at,
    ll.updated_at
FROM geo_locality_locations ll
JOIN geo_localities l ON l.id = ll.locality_id
JOIN geo_countries c ON c.id = l.country_id
WHERE ll.publisher_id = $1
ORDER BY ll.updated_at DESC
`

type GetPublisherLocationOverridesNewRow struct {
	ID           int32              `json:"id"`
	LocalityID   int32              `json:"locality_id"`
	LocalityName string             `json:"locality_name"`
	CountryName  string             `json:"country_name"`
	Latitude     float64            `json:"latitude"`
	Longitude    float64            `json:"longitude"`
	Reason       *string            `json:"reason"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

// ============================================
// Publisher-specific Override Queries
// ============================================
// Returns all location overrides for a specific publisher
func (q *Queries) GetPublisherLocationOverridesNew(ctx context.Context, publisherID *int32) ([]GetPublisherLocationOverridesNewRow, error) {
	rows, err := q.db.Query(ctx, getPublisherLocationOverridesNew, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherLocationOverridesNewRow{}
	for rows.Next() {
		var i GetPublisherLocationOverridesNewRow
		if err := rows.Scan(
			&i.ID,
			&i.LocalityID,
			&i.LocalityName,
			&i.CountryName,
			&i.Latitude,
			&i.Longitude,
			&i.Reason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLocalityElevationOverride = `-- name: UpdateLocalityElevationOverride :one
UPDATE geo_locality_elevations
SET
    elevation_m = $2,
    accuracy_m = $3,
    reason = $4,
    updated_at = now()
WHERE id = $1
RETURNING id, locality_id, publisher_id, source_id, elevation_m, accuracy_m, reason, created_at, updated_at, created_by
`

type UpdateLocalityElevationOverrideParams struct {
	ID         int32   `json:"id"`
	ElevationM int32   `json:"elevation_m"`
	AccuracyM  *int32  `json:"accuracy_m"`
	Reason     *string `json:"reason"`
}

func (q *Queries) UpdateLocalityElevationOverride(ctx context.Context, arg UpdateLocalityElevationOverrideParams) (GeoLocalityElevation, error) {
	row := q.db.QueryRow(ctx, updateLocalityElevationOverride,
		arg.ID,
		arg.ElevationM,
		arg.AccuracyM,
		arg.Reason,
	)
	var i GeoLocalityElevation
	err := row.Scan(
		&i.ID,
		&i.LocalityID,
		&i.PublisherID,
		&i.SourceID,
		&i.ElevationM,
		&i.AccuracyM,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const updateLocalityLocationOverride = `-- name: UpdateLocalityLocationOverride :one
UPDATE geo_locality_locations
SET
    latitude = $2,
    longitude = $3,
    accuracy_m = $4,
    reason = $5,
    updated_at = now()
WHERE id = $1
RETURNING id, locality_id, publisher_id, source_id, latitude, longitude, accuracy_m, reason, created_at, updated_at, created_by
`

type UpdateLocalityLocationOverrideParams struct {
	ID        int32   `json:"id"`
	Latitude  float64 `json:"latitude"`
	Longitude float64 `json:"longitude"`
	AccuracyM *int32  `json:"accuracy_m"`
	Reason    *string `json:"reason"`
}

type UpdateLocalityLocationOverrideRow struct {
	ID          int32              `json:"id"`
	LocalityID  int32              `json:"locality_id"`
	PublisherID *int32             `json:"publisher_id"`
	SourceID    int32              `json:"source_id"`
	Latitude    float64            `json:"latitude"`
	Longitude   float64            `json:"longitude"`
	AccuracyM   *int32             `json:"accuracy_m"`
	Reason      *string            `json:"reason"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	CreatedBy   *string            `json:"created_by"`
}

func (q *Queries) UpdateLocalityLocationOverride(ctx context.Context, arg UpdateLocalityLocationOverrideParams) (UpdateLocalityLocationOverrideRow, error) {
	row := q.db.QueryRow(ctx, updateLocalityLocationOverride,
		arg.ID,
		arg.Latitude,
		arg.Longitude,
		arg.AccuracyM,
		arg.Reason,
	)
	var i UpdateLocalityLocationOverrideRow
	err := row.Scan(
		&i.ID,
		&i.LocalityID,
		&i.PublisherID,
		&i.SourceID,
		&i.Latitude,
		&i.Longitude,
		&i.AccuracyM,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}
