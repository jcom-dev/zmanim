// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: version_history.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createVersionSnapshot = `-- name: CreateVersionSnapshot :one
INSERT INTO algorithm_version_history (
    algorithm_id, version_number, status, config_snapshot, description, created_by
) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, version_number, status
`

type CreateVersionSnapshotParams struct {
	AlgorithmID    int32   `json:"algorithm_id"`
	VersionNumber  int32   `json:"version_number"`
	Status         string  `json:"status"`
	ConfigSnapshot []byte  `json:"config_snapshot"`
	Description    *string `json:"description"`
	CreatedBy      *string `json:"created_by"`
}

type CreateVersionSnapshotRow struct {
	ID            int32  `json:"id"`
	VersionNumber int32  `json:"version_number"`
	Status        string `json:"status"`
}

func (q *Queries) CreateVersionSnapshot(ctx context.Context, arg CreateVersionSnapshotParams) (CreateVersionSnapshotRow, error) {
	row := q.db.QueryRow(ctx, createVersionSnapshot,
		arg.AlgorithmID,
		arg.VersionNumber,
		arg.Status,
		arg.ConfigSnapshot,
		arg.Description,
		arg.CreatedBy,
	)
	var i CreateVersionSnapshotRow
	err := row.Scan(&i.ID, &i.VersionNumber, &i.Status)
	return i, err
}

const getCurrentVersionNumber = `-- name: GetCurrentVersionNumber :one

SELECT COALESCE(MAX(version_number), 0)
FROM algorithm_version_history
WHERE algorithm_id = $1
`

// Version history queries --
func (q *Queries) GetCurrentVersionNumber(ctx context.Context, algorithmID int32) (interface{}, error) {
	row := q.db.QueryRow(ctx, getCurrentVersionNumber, algorithmID)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const getLatestAlgorithmByPublisher = `-- name: GetLatestAlgorithmByPublisher :one

SELECT id FROM algorithms
WHERE publisher_id = $1
ORDER BY updated_at DESC
LIMIT 1
`

// Get algorithm ID for publisher --
func (q *Queries) GetLatestAlgorithmByPublisher(ctx context.Context, publisherID int32) (int32, error) {
	row := q.db.QueryRow(ctx, getLatestAlgorithmByPublisher, publisherID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getNextVersionNumber = `-- name: GetNextVersionNumber :one
SELECT get_next_algorithm_version($1)
`

func (q *Queries) GetNextVersionNumber(ctx context.Context, pAlgorithmID int32) (int32, error) {
	row := q.db.QueryRow(ctx, getNextVersionNumber, pAlgorithmID)
	var get_next_algorithm_version int32
	err := row.Scan(&get_next_algorithm_version)
	return get_next_algorithm_version, err
}

const getPublisherIDByClerkUserID = `-- name: GetPublisherIDByClerkUserID :one


SELECT id FROM publishers WHERE clerk_user_id = $1
`

// Version History SQL Queries
// SQLc will generate type-safe Go code from these queries
// Get publisher ID by clerk user ID --
func (q *Queries) GetPublisherIDByClerkUserID(ctx context.Context, clerkUserID *string) (int32, error) {
	row := q.db.QueryRow(ctx, getPublisherIDByClerkUserID, clerkUserID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getVersionConfig = `-- name: GetVersionConfig :one
SELECT config_snapshot
FROM algorithm_version_history
WHERE algorithm_id = $1 AND version_number = $2
`

type GetVersionConfigParams struct {
	AlgorithmID   int32 `json:"algorithm_id"`
	VersionNumber int32 `json:"version_number"`
}

func (q *Queries) GetVersionConfig(ctx context.Context, arg GetVersionConfigParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, getVersionConfig, arg.AlgorithmID, arg.VersionNumber)
	var config_snapshot []byte
	err := row.Scan(&config_snapshot)
	return config_snapshot, err
}

const getVersionDetail = `-- name: GetVersionDetail :one
SELECT id, version_number, status,
       COALESCE(description, '') as description,
       config_snapshot,
       COALESCE(created_by, '') as created_by,
       created_at
FROM algorithm_version_history
WHERE algorithm_id = $1 AND version_number = $2
`

type GetVersionDetailParams struct {
	AlgorithmID   int32 `json:"algorithm_id"`
	VersionNumber int32 `json:"version_number"`
}

type GetVersionDetailRow struct {
	ID             int32              `json:"id"`
	VersionNumber  int32              `json:"version_number"`
	Status         string             `json:"status"`
	Description    string             `json:"description"`
	ConfigSnapshot []byte             `json:"config_snapshot"`
	CreatedBy      string             `json:"created_by"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetVersionDetail(ctx context.Context, arg GetVersionDetailParams) (GetVersionDetailRow, error) {
	row := q.db.QueryRow(ctx, getVersionDetail, arg.AlgorithmID, arg.VersionNumber)
	var i GetVersionDetailRow
	err := row.Scan(
		&i.ID,
		&i.VersionNumber,
		&i.Status,
		&i.Description,
		&i.ConfigSnapshot,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const listVersionHistory = `-- name: ListVersionHistory :many
SELECT id, version_number, status,
       COALESCE(description, '') as description,
       COALESCE(created_by, '') as created_by,
       created_at,
       published_at
FROM algorithm_version_history
WHERE algorithm_id = $1
ORDER BY version_number DESC
`

type ListVersionHistoryRow struct {
	ID            int32              `json:"id"`
	VersionNumber int32              `json:"version_number"`
	Status        string             `json:"status"`
	Description   string             `json:"description"`
	CreatedBy     string             `json:"created_by"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	PublishedAt   pgtype.Timestamptz `json:"published_at"`
}

func (q *Queries) ListVersionHistory(ctx context.Context, algorithmID int32) ([]ListVersionHistoryRow, error) {
	rows, err := q.db.Query(ctx, listVersionHistory, algorithmID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListVersionHistoryRow{}
	for rows.Next() {
		var i ListVersionHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.VersionNumber,
			&i.Status,
			&i.Description,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.PublishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logRollback = `-- name: LogRollback :exec

INSERT INTO algorithm_rollback_audit (
    algorithm_id, source_version, target_version, new_version, reason, rolled_back_by
) VALUES ($1, $2, $3, $4, $5, $6)
`

type LogRollbackParams struct {
	AlgorithmID   int32   `json:"algorithm_id"`
	SourceVersion int32   `json:"source_version"`
	TargetVersion int32   `json:"target_version"`
	NewVersion    int32   `json:"new_version"`
	Reason        *string `json:"reason"`
	RolledBackBy  *string `json:"rolled_back_by"`
}

// Rollback audit --
func (q *Queries) LogRollback(ctx context.Context, arg LogRollbackParams) error {
	_, err := q.db.Exec(ctx, logRollback,
		arg.AlgorithmID,
		arg.SourceVersion,
		arg.TargetVersion,
		arg.NewVersion,
		arg.Reason,
		arg.RolledBackBy,
	)
	return err
}

const updateAlgorithmConfiguration = `-- name: UpdateAlgorithmConfiguration :exec

UPDATE algorithms
SET configuration = $1, updated_at = NOW()
WHERE id = $2
`

type UpdateAlgorithmConfigurationParams struct {
	Configuration []byte `json:"configuration"`
	ID            int32  `json:"id"`
}

// Update algorithm configuration --
func (q *Queries) UpdateAlgorithmConfiguration(ctx context.Context, arg UpdateAlgorithmConfigurationParams) error {
	_, err := q.db.Exec(ctx, updateAlgorithmConfiguration, arg.Configuration, arg.ID)
	return err
}
