// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: geo_boundaries.sql

package sqlcgen

import (
	"context"
)

const getBoundaryStats = `-- name: GetBoundaryStats :one


SELECT
    0::bigint as country_boundaries,
    0::bigint as region_boundaries,
    0::bigint as district_boundaries,
    0::bigint as city_boundaries
`

type GetBoundaryStatsRow struct {
	CountryBoundaries  int64 `json:"country_boundaries"`
	RegionBoundaries   int64 `json:"region_boundaries"`
	DistrictBoundaries int64 `json:"district_boundaries"`
	CityBoundaries     int64 `json:"city_boundaries"`
}

// Geo Boundaries SQL Queries
// NOTE: Boundary tables (geo_country_boundaries, geo_region_boundaries) were removed
// as part of the Overture migration. Localities are point-only.
// This file contains placeholder queries to maintain handler compatibility.
// ============================================================================
// Boundary Functionality Status: DISABLED
// ============================================================================
// The old WOF boundary tables have been removed. The Overture schema uses
// point-based localities without boundary polygons. If boundary functionality
// is needed in the future, new boundary tables would need to be added.
//
// Removed tables:
// - geo_country_boundaries
// - geo_region_boundaries
// - geo_district_boundaries
// - geo_city_boundaries
// - geo_locality_boundaries
// - geo_boundary_imports
// - geo_name_mappings
// ============================================================================
// Returns placeholder stats since boundaries are disabled
func (q *Queries) GetBoundaryStats(ctx context.Context) (GetBoundaryStatsRow, error) {
	row := q.db.QueryRow(ctx, getBoundaryStats)
	var i GetBoundaryStatsRow
	err := row.Scan(
		&i.CountryBoundaries,
		&i.RegionBoundaries,
		&i.DistrictBoundaries,
		&i.CityBoundaries,
	)
	return i, err
}
