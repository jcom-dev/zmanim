// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: localities.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const browseHierarchy = `-- name: BrowseHierarchy :many
SELECT
    s.entity_type,
    s.entity_id,
    s.entity_subtype,
    s.locality_id,
    s.display_name,
    s.display_hierarchy,
    s.locality_type_id,
    s.population,
    s.latitude,
    s.longitude,
    s.timezone,
    s.direct_child_count,
    s.descendant_count,
    s.has_children
FROM geo_search_index s
WHERE
    ($1::varchar IS NULL AND s.direct_parent_type IS NULL)
    OR (s.direct_parent_type = $1 AND s.direct_parent_id = $2)
ORDER BY
    s.population DESC NULLS LAST,
    s.display_name
LIMIT $3
`

type BrowseHierarchyParams struct {
	ParentType *string `json:"parent_type"`
	ParentID   *int32  `json:"parent_id"`
	LimitVal   int32   `json:"limit_val"`
}

type BrowseHierarchyRow struct {
	EntityType       string   `json:"entity_type"`
	EntityID         int32    `json:"entity_id"`
	EntitySubtype    *string  `json:"entity_subtype"`
	LocalityID       *int32   `json:"locality_id"`
	DisplayName      string   `json:"display_name"`
	DisplayHierarchy string   `json:"display_hierarchy"`
	LocalityTypeID   *int16   `json:"locality_type_id"`
	Population       *int64   `json:"population"`
	Latitude         *float64 `json:"latitude"`
	Longitude        *float64 `json:"longitude"`
	Timezone         *string  `json:"timezone"`
	DirectChildCount *int32   `json:"direct_child_count"`
	DescendantCount  *int32   `json:"descendant_count"`
	HasChildren      *bool    `json:"has_children"`
}

// Returns children of ANY entity (continent, country, region, or locality) for unified hierarchical browsing
// When parent_type is NULL, returns all continents (top-level entities)
// Uses pre-computed descendant_count for recursive totals
func (q *Queries) BrowseHierarchy(ctx context.Context, arg BrowseHierarchyParams) ([]BrowseHierarchyRow, error) {
	rows, err := q.db.Query(ctx, browseHierarchy, arg.ParentType, arg.ParentID, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BrowseHierarchyRow{}
	for rows.Next() {
		var i BrowseHierarchyRow
		if err := rows.Scan(
			&i.EntityType,
			&i.EntityID,
			&i.EntitySubtype,
			&i.LocalityID,
			&i.DisplayName,
			&i.DisplayHierarchy,
			&i.LocalityTypeID,
			&i.Population,
			&i.Latitude,
			&i.Longitude,
			&i.Timezone,
			&i.DirectChildCount,
			&i.DescendantCount,
			&i.HasChildren,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDirectChildrenOfLocality = `-- name: GetDirectChildrenOfLocality :many
SELECT
    s.entity_type,
    s.entity_id,
    s.locality_id,
    s.display_name,
    s.display_hierarchy,
    s.locality_type_id,
    s.country_id,
    s.country_code,
    s.population,
    s.latitude,
    s.longitude
FROM geo_search_index s
WHERE s.direct_parent_type = 'locality'
  AND s.direct_parent_id = $1
ORDER BY s.population DESC NULLS LAST, s.display_name
LIMIT $2
`

type GetDirectChildrenOfLocalityParams struct {
	LocalityID *int32 `json:"locality_id"`
	LimitVal   int32  `json:"limit_val"`
}

type GetDirectChildrenOfLocalityRow struct {
	EntityType       string   `json:"entity_type"`
	EntityID         int32    `json:"entity_id"`
	LocalityID       *int32   `json:"locality_id"`
	DisplayName      string   `json:"display_name"`
	DisplayHierarchy string   `json:"display_hierarchy"`
	LocalityTypeID   *int16   `json:"locality_type_id"`
	CountryID        *int16   `json:"country_id"`
	CountryCode      *string  `json:"country_code"`
	Population       *int64   `json:"population"`
	Latitude         *float64 `json:"latitude"`
	Longitude        *float64 `json:"longitude"`
}

// Get direct children of a locality (sub-localities like neighborhoods)
func (q *Queries) GetDirectChildrenOfLocality(ctx context.Context, arg GetDirectChildrenOfLocalityParams) ([]GetDirectChildrenOfLocalityRow, error) {
	rows, err := q.db.Query(ctx, getDirectChildrenOfLocality, arg.LocalityID, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDirectChildrenOfLocalityRow{}
	for rows.Next() {
		var i GetDirectChildrenOfLocalityRow
		if err := rows.Scan(
			&i.EntityType,
			&i.EntityID,
			&i.LocalityID,
			&i.DisplayName,
			&i.DisplayHierarchy,
			&i.LocalityTypeID,
			&i.CountryID,
			&i.CountryCode,
			&i.Population,
			&i.Latitude,
			&i.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDirectChildrenOfRegion = `-- name: GetDirectChildrenOfRegion :many
SELECT
    s.entity_type,
    s.entity_id,
    s.locality_id,
    s.display_name,
    s.display_hierarchy,
    s.locality_type_id,
    s.country_id,
    s.country_code,
    s.population,
    s.latitude,
    s.longitude
FROM geo_search_index s
WHERE s.direct_parent_type = 'region'
  AND s.direct_parent_id = $1
ORDER BY
    CASE s.entity_type WHEN 'region' THEN 1 WHEN 'locality' THEN 2 ELSE 3 END,
    s.population DESC NULLS LAST,
    s.display_name
LIMIT $2
`

type GetDirectChildrenOfRegionParams struct {
	RegionID *int32 `json:"region_id"`
	LimitVal int32  `json:"limit_val"`
}

type GetDirectChildrenOfRegionRow struct {
	EntityType       string   `json:"entity_type"`
	EntityID         int32    `json:"entity_id"`
	LocalityID       *int32   `json:"locality_id"`
	DisplayName      string   `json:"display_name"`
	DisplayHierarchy string   `json:"display_hierarchy"`
	LocalityTypeID   *int16   `json:"locality_type_id"`
	CountryID        *int16   `json:"country_id"`
	CountryCode      *string  `json:"country_code"`
	Population       *int64   `json:"population"`
	Latitude         *float64 `json:"latitude"`
	Longitude        *float64 `json:"longitude"`
}

// Get direct children of a region (both sub-regions and localities)
func (q *Queries) GetDirectChildrenOfRegion(ctx context.Context, arg GetDirectChildrenOfRegionParams) ([]GetDirectChildrenOfRegionRow, error) {
	rows, err := q.db.Query(ctx, getDirectChildrenOfRegion, arg.RegionID, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDirectChildrenOfRegionRow{}
	for rows.Next() {
		var i GetDirectChildrenOfRegionRow
		if err := rows.Scan(
			&i.EntityType,
			&i.EntityID,
			&i.LocalityID,
			&i.DisplayName,
			&i.DisplayHierarchy,
			&i.LocalityTypeID,
			&i.CountryID,
			&i.CountryCode,
			&i.Population,
			&i.Latitude,
			&i.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocalitiesNearPoint = `-- name: GetLocalitiesNearPoint :many
WITH nearby_locations AS (
    -- First: use GIST index to find locations within radius (fast spatial filter)
    SELECT ll.locality_id, ll.latitude, ll.longitude, ll.location, ll.source_id
    FROM geo_locality_locations ll
    WHERE ll.publisher_id IS NULL  -- System-wide records only
      AND ST_DWithin(ll.location, ST_SetSRID(ST_MakePoint($1, $2), 4326)::geography, $4)
),
best_coords AS (
    -- Then: resolve priority only for nearby localities (much smaller set)
    SELECT DISTINCT ON (nl.locality_id)
        nl.locality_id,
        nl.latitude,
        nl.longitude,
        nl.location,
        nl.source_id as coordinate_source_id
    FROM nearby_locations nl
    JOIN geo_data_sources ds ON ds.id = nl.source_id AND ds.is_active = true
    ORDER BY nl.locality_id,
             CASE ds.key WHEN 'admin' THEN 1 ELSE 2 END,
             ds.priority
),
best_elevs AS (
    SELECT DISTINCT ON (le.locality_id)
        le.locality_id,
        le.elevation_m,
        le.source_id as elevation_source_id
    FROM geo_locality_elevations le
    JOIN geo_data_sources ds ON ds.id = le.source_id AND ds.is_active = true
    WHERE le.publisher_id IS NULL
      AND le.locality_id IN (SELECT locality_id FROM best_coords)
    ORDER BY le.locality_id,
             CASE ds.key WHEN 'admin' THEN 1 ELSE 2 END,
             ds.priority
)
SELECT
    l.id,
    l.parent_overture_id,
    l.locality_type_id,
    l.name,
    l.name_ascii,
    l.timezone,
    l.population,
    l.continent_id,
    l.country_id,
    l.source_id,
    l.overture_id,
    l.created_at,
    l.updated_at,
    bc.latitude,
    bc.longitude,
    bc.coordinate_source_id,
    be.elevation_m,
    be.elevation_source_id,
    lt.code as locality_type_code,
    c.code as country_code,
    s.inherited_region_id,
    ST_Distance(bc.location, ST_SetSRID(ST_MakePoint($1, $2), 4326)::geography) as distance_m
FROM geo_localities l
JOIN best_coords bc ON bc.locality_id = l.id
LEFT JOIN best_elevs be ON be.locality_id = l.id
LEFT JOIN geo_locality_types lt ON l.locality_type_id = lt.id
JOIN geo_countries c ON l.country_id = c.id
LEFT JOIN geo_search_index s ON s.entity_type = 'locality' AND s.entity_id = l.id
ORDER BY distance_m
LIMIT $3
`

type GetLocalitiesNearPointParams struct {
	Lng      interface{} `json:"lng"`
	Lat      interface{} `json:"lat"`
	LimitVal int32       `json:"limit_val"`
	RadiusM  interface{} `json:"radius_m"`
}

type GetLocalitiesNearPointRow struct {
	ID                 int32              `json:"id"`
	ParentOvertureID   *string            `json:"parent_overture_id"`
	LocalityTypeID     *int16             `json:"locality_type_id"`
	Name               string             `json:"name"`
	NameAscii          *string            `json:"name_ascii"`
	Timezone           string             `json:"timezone"`
	Population         *int32             `json:"population"`
	ContinentID        *int16             `json:"continent_id"`
	CountryID          *int16             `json:"country_id"`
	SourceID           *int32             `json:"source_id"`
	OvertureID         *string            `json:"overture_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	Latitude           float64            `json:"latitude"`
	Longitude          float64            `json:"longitude"`
	CoordinateSourceID int32              `json:"coordinate_source_id"`
	ElevationM         *int32             `json:"elevation_m"`
	ElevationSourceID  *int32             `json:"elevation_source_id"`
	LocalityTypeCode   *string            `json:"locality_type_code"`
	CountryCode        string             `json:"country_code"`
	InheritedRegionID  *int32             `json:"inherited_region_id"`
	DistanceM          interface{}        `json:"distance_m"`
}

// Returns localities near a point with inherited region from search index
// Uses GIST index on geo_locality_locations.location for fast spatial filtering
// Priority resolution via LATERAL join AFTER spatial filter for efficiency
func (q *Queries) GetLocalitiesNearPoint(ctx context.Context, arg GetLocalitiesNearPointParams) ([]GetLocalitiesNearPointRow, error) {
	rows, err := q.db.Query(ctx, getLocalitiesNearPoint,
		arg.Lng,
		arg.Lat,
		arg.LimitVal,
		arg.RadiusM,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLocalitiesNearPointRow{}
	for rows.Next() {
		var i GetLocalitiesNearPointRow
		if err := rows.Scan(
			&i.ID,
			&i.ParentOvertureID,
			&i.LocalityTypeID,
			&i.Name,
			&i.NameAscii,
			&i.Timezone,
			&i.Population,
			&i.ContinentID,
			&i.CountryID,
			&i.SourceID,
			&i.OvertureID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Latitude,
			&i.Longitude,
			&i.CoordinateSourceID,
			&i.ElevationM,
			&i.ElevationSourceID,
			&i.LocalityTypeCode,
			&i.CountryCode,
			&i.InheritedRegionID,
			&i.DistanceM,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocalityByID = `-- name: GetLocalityByID :one
WITH original_coords AS (
    SELECT DISTINCT ON (ll.locality_id)
        ll.locality_id,
        ll.latitude as original_latitude,
        ll.longitude as original_longitude
    FROM geo_locality_locations ll
    JOIN geo_data_sources ds ON ds.id = ll.source_id AND ds.is_active = true
    WHERE ll.locality_id = $1
      AND ll.publisher_id IS NULL
      AND ds.key != 'admin'
    ORDER BY ll.locality_id, ds.priority
),
original_elevs AS (
    SELECT DISTINCT ON (le.locality_id)
        le.locality_id,
        le.elevation_m as original_elevation_m
    FROM geo_locality_elevations le
    JOIN geo_data_sources ds ON ds.id = le.source_id AND ds.is_active = true
    WHERE le.locality_id = $1
      AND le.publisher_id IS NULL
      AND ds.key != 'admin'
    ORDER BY le.locality_id, ds.priority
)
SELECT
    l.id,
    l.parent_overture_id,
    l.locality_type_id,
    l.name,
    l.name_ascii,
    l.timezone,
    l.population,
    l.continent_id,
    l.country_id,
    l.source_id,
    l.overture_id,
    l.created_at,
    l.updated_at,
    -- Coordinates from resolved view (priority: admin > default)
    rc.latitude,
    rc.longitude,
    rc.coordinate_source_id,
    rc.coordinate_source_key,
    rc.elevation_m,
    rc.elevation_source_id,
    rc.elevation_source_key,
    -- Original (non-admin) coordinates for "Default" view
    oc.original_latitude,
    oc.original_longitude,
    oe.original_elevation_m,
    lt.code as locality_type_code,
    lt.name as locality_type_name,
    s.display_hierarchy,
    s.inherited_region_id,
    s.direct_parent_type,
    s.direct_parent_id,
    c.name as country_name,
    c.code as country_code
FROM geo_localities l
LEFT JOIN geo_locality_resolved_coords rc ON rc.locality_id = l.id
LEFT JOIN original_coords oc ON oc.locality_id = l.id
LEFT JOIN original_elevs oe ON oe.locality_id = l.id
LEFT JOIN geo_locality_types lt ON l.locality_type_id = lt.id
LEFT JOIN geo_search_index s ON s.entity_type = 'locality' AND s.entity_id = l.id
JOIN geo_countries c ON l.country_id = c.id
WHERE l.id = $1
`

type GetLocalityByIDRow struct {
	ID                  int32              `json:"id"`
	ParentOvertureID    *string            `json:"parent_overture_id"`
	LocalityTypeID      *int16             `json:"locality_type_id"`
	Name                string             `json:"name"`
	NameAscii           *string            `json:"name_ascii"`
	Timezone            string             `json:"timezone"`
	Population          *int32             `json:"population"`
	ContinentID         *int16             `json:"continent_id"`
	CountryID           *int16             `json:"country_id"`
	SourceID            *int32             `json:"source_id"`
	OvertureID          *string            `json:"overture_id"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	Latitude            *float64           `json:"latitude"`
	Longitude           *float64           `json:"longitude"`
	CoordinateSourceID  *int32             `json:"coordinate_source_id"`
	CoordinateSourceKey *string            `json:"coordinate_source_key"`
	ElevationM          *int32             `json:"elevation_m"`
	ElevationSourceID   *int32             `json:"elevation_source_id"`
	ElevationSourceKey  *string            `json:"elevation_source_key"`
	OriginalLatitude    *float64           `json:"original_latitude"`
	OriginalLongitude   *float64           `json:"original_longitude"`
	OriginalElevationM  *int32             `json:"original_elevation_m"`
	LocalityTypeCode    *string            `json:"locality_type_code"`
	LocalityTypeName    *string            `json:"locality_type_name"`
	DisplayHierarchy    *string            `json:"display_hierarchy"`
	InheritedRegionID   *int32             `json:"inherited_region_id"`
	DirectParentType    *string            `json:"direct_parent_type"`
	DirectParentID      *int32             `json:"direct_parent_id"`
	CountryName         string             `json:"country_name"`
	CountryCode         string             `json:"country_code"`
}

// Returns locality with resolved hierarchy from search index
// Uses geo_locality_resolved_coords view for best system-wide coordinates
// For publisher-specific resolution, use GetEffectiveLocalityLocation from locality_locations_manual.go
// Also returns original (non-admin) coordinates for comparison
func (q *Queries) GetLocalityByID(ctx context.Context, id int32) (GetLocalityByIDRow, error) {
	row := q.db.QueryRow(ctx, getLocalityByID, id)
	var i GetLocalityByIDRow
	err := row.Scan(
		&i.ID,
		&i.ParentOvertureID,
		&i.LocalityTypeID,
		&i.Name,
		&i.NameAscii,
		&i.Timezone,
		&i.Population,
		&i.ContinentID,
		&i.CountryID,
		&i.SourceID,
		&i.OvertureID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Latitude,
		&i.Longitude,
		&i.CoordinateSourceID,
		&i.CoordinateSourceKey,
		&i.ElevationM,
		&i.ElevationSourceID,
		&i.ElevationSourceKey,
		&i.OriginalLatitude,
		&i.OriginalLongitude,
		&i.OriginalElevationM,
		&i.LocalityTypeCode,
		&i.LocalityTypeName,
		&i.DisplayHierarchy,
		&i.InheritedRegionID,
		&i.DirectParentType,
		&i.DirectParentID,
		&i.CountryName,
		&i.CountryCode,
	)
	return i, err
}

const getLocalityTypes = `-- name: GetLocalityTypes :many
SELECT id, code, name, overture_subtype, sort_order, created_at FROM geo_locality_types ORDER BY sort_order, name
`

func (q *Queries) GetLocalityTypes(ctx context.Context) ([]GeoLocalityType, error) {
	rows, err := q.db.Query(ctx, getLocalityTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GeoLocalityType{}
	for rows.Next() {
		var i GeoLocalityType
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.OvertureSubtype,
			&i.SortOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocalityWithHierarchy = `-- name: GetLocalityWithHierarchy :one
SELECT
    l.id,
    l.parent_overture_id,
    l.locality_type_id,
    l.name,
    l.name_ascii,
    l.timezone,
    l.population,
    l.continent_id,
    l.country_id,
    l.source_id,
    l.overture_id,
    l.created_at,
    l.updated_at,
    l.boundary,
    -- Coordinates from resolved view (priority: admin > default)
    rc.latitude,
    rc.longitude,
    rc.coordinate_source_id,
    rc.elevation_m,
    rc.elevation_source_id,
    lt.code as locality_type_code,
    lt.name as locality_type_name,
    s.display_hierarchy,
    s.hierarchy_path,
    s.inherited_region_id,
    s.direct_parent_type,
    s.direct_parent_id,
    c.name as country_name,
    c.code as country_code
FROM geo_localities l
LEFT JOIN geo_locality_resolved_coords rc ON rc.locality_id = l.id
LEFT JOIN geo_locality_types lt ON l.locality_type_id = lt.id
LEFT JOIN geo_search_index s ON s.entity_type = 'locality' AND s.entity_id = l.id
JOIN geo_countries c ON l.country_id = c.id
WHERE l.id = $1
`

type GetLocalityWithHierarchyRow struct {
	ID                 int32              `json:"id"`
	ParentOvertureID   *string            `json:"parent_overture_id"`
	LocalityTypeID     *int16             `json:"locality_type_id"`
	Name               string             `json:"name"`
	NameAscii          *string            `json:"name_ascii"`
	Timezone           string             `json:"timezone"`
	Population         *int32             `json:"population"`
	ContinentID        *int16             `json:"continent_id"`
	CountryID          *int16             `json:"country_id"`
	SourceID           *int32             `json:"source_id"`
	OvertureID         *string            `json:"overture_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	Boundary           interface{}        `json:"boundary"`
	Latitude           *float64           `json:"latitude"`
	Longitude          *float64           `json:"longitude"`
	CoordinateSourceID *int32             `json:"coordinate_source_id"`
	ElevationM         *int32             `json:"elevation_m"`
	ElevationSourceID  *int32             `json:"elevation_source_id"`
	LocalityTypeCode   *string            `json:"locality_type_code"`
	LocalityTypeName   *string            `json:"locality_type_name"`
	DisplayHierarchy   *string            `json:"display_hierarchy"`
	HierarchyPath      []byte             `json:"hierarchy_path"`
	InheritedRegionID  *int32             `json:"inherited_region_id"`
	DirectParentType   *string            `json:"direct_parent_type"`
	DirectParentID     *int32             `json:"direct_parent_id"`
	CountryName        string             `json:"country_name"`
	CountryCode        string             `json:"country_code"`
}

// Returns locality with full hierarchy from search index
// Uses geo_locality_resolved_coords view for best system-wide coordinates
func (q *Queries) GetLocalityWithHierarchy(ctx context.Context, id int32) (GetLocalityWithHierarchyRow, error) {
	row := q.db.QueryRow(ctx, getLocalityWithHierarchy, id)
	var i GetLocalityWithHierarchyRow
	err := row.Scan(
		&i.ID,
		&i.ParentOvertureID,
		&i.LocalityTypeID,
		&i.Name,
		&i.NameAscii,
		&i.Timezone,
		&i.Population,
		&i.ContinentID,
		&i.CountryID,
		&i.SourceID,
		&i.OvertureID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Boundary,
		&i.Latitude,
		&i.Longitude,
		&i.CoordinateSourceID,
		&i.ElevationM,
		&i.ElevationSourceID,
		&i.LocalityTypeCode,
		&i.LocalityTypeName,
		&i.DisplayHierarchy,
		&i.HierarchyPath,
		&i.InheritedRegionID,
		&i.DirectParentType,
		&i.DirectParentID,
		&i.CountryName,
		&i.CountryCode,
	)
	return i, err
}

const getRegionTypes = `-- name: GetRegionTypes :many
SELECT id, code, name, overture_subtype, sort_order, created_at FROM geo_region_types ORDER BY sort_order, name
`

func (q *Queries) GetRegionTypes(ctx context.Context) ([]GeoRegionType, error) {
	rows, err := q.db.Query(ctx, getRegionTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GeoRegionType{}
	for rows.Next() {
		var i GeoRegionType
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.OvertureSubtype,
			&i.SortOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSearchIndexStats = `-- name: GetSearchIndexStats :one
SELECT
    COUNT(*) as total_entries,
    COUNT(*) FILTER (WHERE entity_type = 'locality') as localities_count,
    COUNT(*) FILTER (WHERE entity_type = 'region') as regions_count,
    COUNT(*) FILTER (WHERE entity_type = 'country') as countries_count,
    SUM(population) FILTER (WHERE population IS NOT NULL) as total_population
FROM geo_search_index
`

type GetSearchIndexStatsRow struct {
	TotalEntries    int64 `json:"total_entries"`
	LocalitiesCount int64 `json:"localities_count"`
	RegionsCount    int64 `json:"regions_count"`
	CountriesCount  int64 `json:"countries_count"`
	TotalPopulation int64 `json:"total_population"`
}

func (q *Queries) GetSearchIndexStats(ctx context.Context) (GetSearchIndexStatsRow, error) {
	row := q.db.QueryRow(ctx, getSearchIndexStats)
	var i GetSearchIndexStatsRow
	err := row.Scan(
		&i.TotalEntries,
		&i.LocalitiesCount,
		&i.RegionsCount,
		&i.CountriesCount,
		&i.TotalPopulation,
	)
	return i, err
}

const listLocalities = `-- name: ListLocalities :many
SELECT
    l.id,
    l.parent_overture_id,
    l.locality_type_id,
    l.name,
    l.name_ascii,
    l.timezone,
    l.population,
    l.continent_id,
    l.country_id,
    l.source_id,
    l.overture_id,
    l.created_at,
    l.updated_at,
    -- Coordinates from resolved view (priority: admin > default)
    rc.latitude,
    rc.longitude,
    rc.coordinate_source_id,
    rc.elevation_m,
    rc.elevation_source_id,
    lt.code as locality_type_code,
    c.code as country_code,
    c.name as country_name,
    s.inherited_region_id,
    s.direct_parent_type,
    s.direct_parent_id,
    -- Count children using search index
    (SELECT COUNT(*) FROM geo_search_index child
     WHERE child.direct_parent_type = 'locality' AND child.direct_parent_id = l.id)::int as children_count
FROM geo_localities l
LEFT JOIN geo_locality_resolved_coords rc ON rc.locality_id = l.id
LEFT JOIN geo_locality_types lt ON l.locality_type_id = lt.id
LEFT JOIN geo_search_index s ON s.entity_type = 'locality' AND s.entity_id = l.id
JOIN geo_countries c ON l.country_id = c.id
WHERE ($1::int IS NULL OR l.country_id = $1)
  AND ($2::smallint IS NULL OR l.locality_type_id = $2)
  AND ($3::int IS NULL OR s.inherited_region_id = $3)
ORDER BY l.population DESC NULLS LAST, l.name
LIMIT $5 OFFSET $4
`

type ListLocalitiesParams struct {
	CountryID         *int32 `json:"country_id"`
	LocalityTypeID    *int16 `json:"locality_type_id"`
	InheritedRegionID *int32 `json:"inherited_region_id"`
	OffsetVal         int32  `json:"offset_val"`
	LimitVal          int32  `json:"limit_val"`
}

type ListLocalitiesRow struct {
	ID                 int32              `json:"id"`
	ParentOvertureID   *string            `json:"parent_overture_id"`
	LocalityTypeID     *int16             `json:"locality_type_id"`
	Name               string             `json:"name"`
	NameAscii          *string            `json:"name_ascii"`
	Timezone           string             `json:"timezone"`
	Population         *int32             `json:"population"`
	ContinentID        *int16             `json:"continent_id"`
	CountryID          *int16             `json:"country_id"`
	SourceID           *int32             `json:"source_id"`
	OvertureID         *string            `json:"overture_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	Latitude           *float64           `json:"latitude"`
	Longitude          *float64           `json:"longitude"`
	CoordinateSourceID *int32             `json:"coordinate_source_id"`
	ElevationM         *int32             `json:"elevation_m"`
	ElevationSourceID  *int32             `json:"elevation_source_id"`
	LocalityTypeCode   *string            `json:"locality_type_code"`
	CountryCode        string             `json:"country_code"`
	CountryName        string             `json:"country_name"`
	InheritedRegionID  *int32             `json:"inherited_region_id"`
	DirectParentType   *string            `json:"direct_parent_type"`
	DirectParentID     *int32             `json:"direct_parent_id"`
	ChildrenCount      int32              `json:"children_count"`
}

// List localities with search index hierarchy data
// Uses geo_locality_resolved_coords view for best system-wide coordinates
func (q *Queries) ListLocalities(ctx context.Context, arg ListLocalitiesParams) ([]ListLocalitiesRow, error) {
	rows, err := q.db.Query(ctx, listLocalities,
		arg.CountryID,
		arg.LocalityTypeID,
		arg.InheritedRegionID,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLocalitiesRow{}
	for rows.Next() {
		var i ListLocalitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.ParentOvertureID,
			&i.LocalityTypeID,
			&i.Name,
			&i.NameAscii,
			&i.Timezone,
			&i.Population,
			&i.ContinentID,
			&i.CountryID,
			&i.SourceID,
			&i.OvertureID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Latitude,
			&i.Longitude,
			&i.CoordinateSourceID,
			&i.ElevationM,
			&i.ElevationSourceID,
			&i.LocalityTypeCode,
			&i.CountryCode,
			&i.CountryName,
			&i.InheritedRegionID,
			&i.DirectParentType,
			&i.DirectParentID,
			&i.ChildrenCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchLocalities = `-- name: SearchLocalities :many

WITH words AS (
    SELECT word, row_number() OVER () AS pos
    FROM unnest(string_to_array(lower($2), ' ')) AS word
    WHERE word <> ''
),
search_terms AS (
    SELECT DISTINCT term FROM (
        -- Individual words
        SELECT word AS term FROM words
        UNION ALL
        -- Consecutive pairs (e.g., "new jersey" from "lakewood new jersey")
        SELECT w1.word || ' ' || w2.word AS term
        FROM words w1
        JOIN words w2 ON w2.pos = w1.pos + 1
        UNION ALL
        -- Full phrase
        SELECT lower($2) AS term
    ) all_terms
    WHERE term IS NOT NULL AND term <> ''
),
individual_terms AS (
    SELECT unnest(string_to_array(lower($2), ' ')) AS term
),
term_count AS (
    SELECT COUNT(*)::int AS total FROM individual_terms WHERE term <> ''
),
exact_matches AS (
    SELECT
        s.entity_type,
        s.entity_id,
        s.locality_id,
        s.display_name,
        s.display_hierarchy,
        s.display_names,
        s.locality_type_id,
        s.direct_parent_type,
        s.direct_parent_id,
        s.inherited_region_id,
        s.country_id,
        s.continent_id,
        s.country_code,
        s.population,
        s.latitude,
        s.longitude,
        s.timezone,
        (SELECT COUNT(*) FROM search_terms st WHERE st.term <> '' AND st.term = ANY(s.keywords))::int AS matched_terms,
        CASE WHEN lower(s.display_name) = ANY(SELECT term FROM search_terms WHERE term <> '') THEN 1 ELSE 0 END AS name_match_bonus,
        CASE WHEN lower(s.display_name) LIKE '%' || lower($2) || '%' THEN 2 ELSE 0 END AS phrase_match_bonus,
        CASE
            WHEN lower($2) = ANY(s.keywords) THEN 3
            WHEN (SELECT COUNT(*) FROM search_terms st WHERE st.term <> '' AND st.term = ANY(s.keywords)) = (SELECT COUNT(*) FROM search_terms WHERE term <> '') THEN 3
            ELSE 0
        END AS all_terms_bonus,
        1 AS tier,
        CASE s.locality_type_id
            WHEN 1 THEN 1  -- city
            WHEN 2 THEN 2  -- town
            WHEN 3 THEN 3  -- village
            WHEN 4 THEN 4  -- hamlet
            WHEN 5 THEN 5  -- neighborhood
            ELSE 10
        END AS type_priority
    FROM geo_search_index s
    WHERE s.keywords && (SELECT ARRAY_AGG(term) FROM search_terms WHERE term <> '')
      AND ($3::text[] IS NULL OR COALESCE(cardinality($3::text[]), 0) = 0 OR s.entity_type = ANY($3))
      AND ($4::int IS NULL OR s.country_id = $4)
      AND ($5::int IS NULL OR s.inherited_region_id = $5)
),
fuzzy_matches AS (
    SELECT
        s.entity_type,
        s.entity_id,
        s.locality_id,
        s.display_name,
        s.display_hierarchy,
        s.display_names,
        s.locality_type_id,
        s.direct_parent_type,
        s.direct_parent_id,
        s.inherited_region_id,
        s.country_id,
        s.continent_id,
        s.country_code,
        s.population,
        s.latitude,
        s.longitude,
        s.timezone,
        0 AS matched_terms,
        0 AS name_match_bonus,
        0 AS phrase_match_bonus,
        0 AS all_terms_bonus,
        2 AS tier,
        CASE s.locality_type_id
            WHEN 1 THEN 1
            WHEN 2 THEN 2
            WHEN 3 THEN 3
            WHEN 4 THEN 4
            WHEN 5 THEN 5
            ELSE 10
        END AS type_priority
    FROM geo_search_index s
    WHERE s.display_name % $2
      AND (s.entity_type, s.entity_id) NOT IN (SELECT entity_type, entity_id FROM exact_matches)
      AND ($3::text[] IS NULL OR COALESCE(cardinality($3::text[]), 0) = 0 OR s.entity_type = ANY($3))
      AND ($4::int IS NULL OR s.country_id = $4)
    LIMIT 50
),
all_matches AS (
    SELECT entity_type, entity_id, locality_id, display_name, display_hierarchy, display_names, locality_type_id, direct_parent_type, direct_parent_id, inherited_region_id, country_id, continent_id, country_code, population, latitude, longitude, timezone, matched_terms, name_match_bonus, phrase_match_bonus, all_terms_bonus, tier, type_priority FROM exact_matches
    UNION ALL
    SELECT entity_type, entity_id, locality_id, display_name, display_hierarchy, display_names, locality_type_id, direct_parent_type, direct_parent_id, inherited_region_id, country_id, continent_id, country_code, population, latitude, longitude, timezone, matched_terms, name_match_bonus, phrase_match_bonus, all_terms_bonus, tier, type_priority FROM fuzzy_matches
),
deduplicated AS (
    SELECT DISTINCT ON (display_name, country_code)
        entity_type, entity_id, locality_id, display_name, display_hierarchy, display_names,
        locality_type_id, direct_parent_type, direct_parent_id, inherited_region_id, country_id, continent_id, country_code,
        population, latitude, longitude, timezone, matched_terms, name_match_bonus,
        phrase_match_bonus, all_terms_bonus, tier, type_priority
    FROM all_matches
    ORDER BY display_name, country_code,
             tier ASC,
             matched_terms DESC,
             all_terms_bonus DESC,
             population DESC NULLS LAST,
             type_priority ASC
)
SELECT entity_type, entity_id, locality_id, display_name, display_hierarchy, display_names,
       locality_type_id, direct_parent_type, direct_parent_id, inherited_region_id, country_id, continent_id, country_code,
       population, latitude, longitude, timezone, matched_terms, name_match_bonus, tier
FROM deduplicated
ORDER BY tier, all_terms_bonus DESC, phrase_match_bonus DESC, matched_terms DESC, name_match_bonus DESC, population DESC NULLS LAST
LIMIT $1
`

type SearchLocalitiesParams struct {
	LimitVal          int32    `json:"limit_val"`
	Query             string   `json:"query"`
	EntityTypes       []string `json:"entity_types"`
	CountryID         *int32   `json:"country_id"`
	InheritedRegionID *int32   `json:"inherited_region_id"`
}

type SearchLocalitiesRow struct {
	EntityType        string   `json:"entity_type"`
	EntityID          int32    `json:"entity_id"`
	LocalityID        *int32   `json:"locality_id"`
	DisplayName       string   `json:"display_name"`
	DisplayHierarchy  string   `json:"display_hierarchy"`
	DisplayNames      []byte   `json:"display_names"`
	LocalityTypeID    *int16   `json:"locality_type_id"`
	DirectParentType  *string  `json:"direct_parent_type"`
	DirectParentID    *int32   `json:"direct_parent_id"`
	InheritedRegionID *int32   `json:"inherited_region_id"`
	CountryID         *int16   `json:"country_id"`
	ContinentID       *int16   `json:"continent_id"`
	CountryCode       *string  `json:"country_code"`
	Population        *int64   `json:"population"`
	Latitude          *float64 `json:"latitude"`
	Longitude         *float64 `json:"longitude"`
	Timezone          *string  `json:"timezone"`
	MatchedTerms      int32    `json:"matched_terms"`
	NameMatchBonus    int32    `json:"name_match_bonus"`
	Tier              int32    `json:"tier"`
}

// ============================================
// Localities Queries for Overture Geographic Data
// Uses geo_search_index for denormalized hierarchy data
// ============================================
// Tiered search: exact keyword match -> fuzzy trigram -> population ranking
// Uses geo_search_index which has resolved hierarchy via parent_overture_id
// Generates search terms including individual words, consecutive pairs, and full phrase
// e.g. "lakewood new jersey" -> ["lakewood", "new", "jersey", "lakewood new", "new jersey", "lakewood new jersey"]
func (q *Queries) SearchLocalities(ctx context.Context, arg SearchLocalitiesParams) ([]SearchLocalitiesRow, error) {
	rows, err := q.db.Query(ctx, searchLocalities,
		arg.LimitVal,
		arg.Query,
		arg.EntityTypes,
		arg.CountryID,
		arg.InheritedRegionID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchLocalitiesRow{}
	for rows.Next() {
		var i SearchLocalitiesRow
		if err := rows.Scan(
			&i.EntityType,
			&i.EntityID,
			&i.LocalityID,
			&i.DisplayName,
			&i.DisplayHierarchy,
			&i.DisplayNames,
			&i.LocalityTypeID,
			&i.DirectParentType,
			&i.DirectParentID,
			&i.InheritedRegionID,
			&i.CountryID,
			&i.ContinentID,
			&i.CountryCode,
			&i.Population,
			&i.Latitude,
			&i.Longitude,
			&i.Timezone,
			&i.MatchedTerms,
			&i.NameMatchBonus,
			&i.Tier,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchLocalitiesWithPublisherCoverage = `-- name: SearchLocalitiesWithPublisherCoverage :many
WITH publisher_coverage_areas AS (
    SELECT
        pc.continent_id,
        pc.country_id,
        pc.region_id,
        pc.locality_id
    FROM publisher_coverage pc
    WHERE pc.publisher_id = $2::int
      AND pc.is_active = true
),
words AS (
    SELECT word, row_number() OVER () AS pos
    FROM unnest(string_to_array(lower($3), ' ')) AS word
    WHERE word <> ''
),
search_terms AS (
    SELECT DISTINCT term FROM (
        -- Individual words
        SELECT word AS term FROM words
        UNION ALL
        -- Consecutive pairs (e.g., "new jersey" from "lakewood new jersey")
        SELECT w1.word || ' ' || w2.word AS term
        FROM words w1
        JOIN words w2 ON w2.pos = w1.pos + 1
        UNION ALL
        -- Full phrase
        SELECT lower($3) AS term
    ) all_terms
    WHERE term IS NOT NULL AND term <> ''
),
individual_terms AS (
    SELECT unnest(string_to_array(lower($3), ' ')) AS term
),
term_count AS (
    SELECT COUNT(*)::int AS total FROM individual_terms
),
keyword_matches AS MATERIALIZED (
    SELECT
        s.entity_type,
        s.entity_id,
        s.locality_id,
        s.display_name,
        s.display_hierarchy,
        s.display_names,
        s.locality_type_id,
        s.direct_parent_type,
        s.direct_parent_id,
        s.inherited_region_id,
        s.country_id,
        s.continent_id,
        s.country_code,
        s.population,
        s.latitude,
        s.longitude,
        s.timezone,
        s.keywords,
        s.ancestor_region_ids
    FROM geo_search_index s
    WHERE s.keywords && (SELECT ARRAY_AGG(term) FROM search_terms WHERE term <> '')
      AND s.entity_type = 'locality'
),
exact_matches AS (
    SELECT
        s.entity_type,
        s.entity_id,
        s.locality_id,
        s.display_name,
        s.display_hierarchy,
        s.display_names,
        s.locality_type_id,
        s.direct_parent_type,
        s.direct_parent_id,
        s.inherited_region_id,
        s.country_id,
        s.continent_id,
        s.country_code,
        s.population,
        s.latitude,
        s.longitude,
        s.timezone,
        (SELECT COUNT(*) FROM search_terms st WHERE st.term <> '' AND st.term = ANY(s.keywords))::int AS matched_terms,
        CASE WHEN lower(s.display_name) = ANY(SELECT term FROM search_terms WHERE term <> '') THEN 1 ELSE 0 END AS name_match_bonus,
        CASE WHEN lower(s.display_name) LIKE '%' || lower($3) || '%' THEN 2 ELSE 0 END AS phrase_match_bonus,
        CASE
            WHEN lower($3) = ANY(s.keywords) THEN 3
            WHEN (SELECT COUNT(*) FROM search_terms st WHERE st.term <> '' AND st.term = ANY(s.keywords)) = (SELECT COUNT(*) FROM search_terms WHERE term <> '') THEN 3
            ELSE 0
        END AS all_terms_bonus,
        1 AS tier,
        CASE s.locality_type_id
            WHEN 1 THEN 1  -- city
            WHEN 2 THEN 2  -- town
            WHEN 3 THEN 3  -- village
            WHEN 4 THEN 4  -- hamlet
            WHEN 5 THEN 5  -- neighborhood
            ELSE 10
        END AS type_priority
    FROM keyword_matches s
    WHERE (
        -- Direct locality match
        s.entity_id IN (SELECT locality_id FROM publisher_coverage_areas WHERE locality_id IS NOT NULL)
        -- Region match (locality's ancestor regions)
        OR s.ancestor_region_ids && (SELECT ARRAY_AGG(region_id) FROM publisher_coverage_areas WHERE region_id IS NOT NULL)
        -- Country match
        OR s.country_id IN (SELECT country_id FROM publisher_coverage_areas WHERE country_id IS NOT NULL)
        -- Continent match
        OR s.continent_id IN (SELECT continent_id FROM publisher_coverage_areas WHERE continent_id IS NOT NULL)
    )
),
fuzzy_candidates AS MATERIALIZED (
    SELECT
        s.entity_type,
        s.entity_id,
        s.locality_id,
        s.display_name,
        s.display_hierarchy,
        s.display_names,
        s.locality_type_id,
        s.direct_parent_type,
        s.direct_parent_id,
        s.inherited_region_id,
        s.country_id,
        s.continent_id,
        s.country_code,
        s.population,
        s.latitude,
        s.longitude,
        s.timezone,
        s.ancestor_region_ids
    FROM geo_search_index s
    WHERE s.display_name % $3
      AND s.entity_type = 'locality'
    LIMIT 200
),
fuzzy_matches AS (
    SELECT
        s.entity_type,
        s.entity_id,
        s.locality_id,
        s.display_name,
        s.display_hierarchy,
        s.display_names,
        s.locality_type_id,
        s.direct_parent_type,
        s.direct_parent_id,
        s.inherited_region_id,
        s.country_id,
        s.continent_id,
        s.country_code,
        s.population,
        s.latitude,
        s.longitude,
        s.timezone,
        0 AS matched_terms,
        0 AS name_match_bonus,
        0 AS phrase_match_bonus,
        0 AS all_terms_bonus,
        2 AS tier,
        CASE s.locality_type_id
            WHEN 1 THEN 1
            WHEN 2 THEN 2
            WHEN 3 THEN 3
            WHEN 4 THEN 4
            WHEN 5 THEN 5
            ELSE 10
        END AS type_priority
    FROM fuzzy_candidates s
    WHERE (s.entity_type, s.entity_id) NOT IN (SELECT entity_type, entity_id FROM exact_matches)
      AND (
          s.entity_id IN (SELECT locality_id FROM publisher_coverage_areas WHERE locality_id IS NOT NULL)
          OR s.ancestor_region_ids && (SELECT ARRAY_AGG(region_id) FROM publisher_coverage_areas WHERE region_id IS NOT NULL)
          OR s.country_id IN (SELECT country_id FROM publisher_coverage_areas WHERE country_id IS NOT NULL)
          OR s.continent_id IN (SELECT continent_id FROM publisher_coverage_areas WHERE continent_id IS NOT NULL)
      )
    LIMIT 50
),
all_matches AS (
    SELECT entity_type, entity_id, locality_id, display_name, display_hierarchy, display_names, locality_type_id, direct_parent_type, direct_parent_id, inherited_region_id, country_id, continent_id, country_code, population, latitude, longitude, timezone, matched_terms, name_match_bonus, phrase_match_bonus, all_terms_bonus, tier, type_priority FROM exact_matches
    UNION ALL
    SELECT entity_type, entity_id, locality_id, display_name, display_hierarchy, display_names, locality_type_id, direct_parent_type, direct_parent_id, inherited_region_id, country_id, continent_id, country_code, population, latitude, longitude, timezone, matched_terms, name_match_bonus, phrase_match_bonus, all_terms_bonus, tier, type_priority FROM fuzzy_matches
),
deduplicated AS (
    SELECT DISTINCT ON (display_name, country_code)
        entity_type, entity_id, locality_id, display_name, display_hierarchy, display_names,
        locality_type_id, direct_parent_type, direct_parent_id, inherited_region_id, country_id, continent_id, country_code,
        population, latitude, longitude, timezone, matched_terms, name_match_bonus,
        phrase_match_bonus, all_terms_bonus, tier, type_priority
    FROM all_matches
    ORDER BY display_name, country_code,
             tier ASC,
             matched_terms DESC,
             all_terms_bonus DESC,
             population DESC NULLS LAST,
             type_priority ASC
)
SELECT entity_type, entity_id, locality_id, display_name, display_hierarchy, display_names,
       locality_type_id, direct_parent_type, direct_parent_id, inherited_region_id, country_id, continent_id, country_code,
       population, latitude, longitude, timezone, matched_terms, name_match_bonus, tier
FROM deduplicated
ORDER BY tier, all_terms_bonus DESC, phrase_match_bonus DESC, matched_terms DESC, name_match_bonus DESC, population DESC NULLS LAST
LIMIT $1
`

type SearchLocalitiesWithPublisherCoverageParams struct {
	LimitVal    int32  `json:"limit_val"`
	PublisherID int32  `json:"publisher_id"`
	Query       string `json:"query"`
}

type SearchLocalitiesWithPublisherCoverageRow struct {
	EntityType        string   `json:"entity_type"`
	EntityID          int32    `json:"entity_id"`
	LocalityID        *int32   `json:"locality_id"`
	DisplayName       string   `json:"display_name"`
	DisplayHierarchy  string   `json:"display_hierarchy"`
	DisplayNames      []byte   `json:"display_names"`
	LocalityTypeID    *int16   `json:"locality_type_id"`
	DirectParentType  *string  `json:"direct_parent_type"`
	DirectParentID    *int32   `json:"direct_parent_id"`
	InheritedRegionID *int32   `json:"inherited_region_id"`
	CountryID         *int16   `json:"country_id"`
	ContinentID       *int16   `json:"continent_id"`
	CountryCode       *string  `json:"country_code"`
	Population        *int64   `json:"population"`
	Latitude          *float64 `json:"latitude"`
	Longitude         *float64 `json:"longitude"`
	Timezone          *string  `json:"timezone"`
	MatchedTerms      int32    `json:"matched_terms"`
	NameMatchBonus    int32    `json:"name_match_bonus"`
	Tier              int32    `json:"tier"`
}

// Search localities filtered to a publisher's coverage areas (hierarchy-aware)
// Returns only localities that fall within the publisher's coverage:
// - Direct locality coverage match
// - Within a covered region (via ancestor_region_ids)
// - Within a covered country
// - Within a covered continent
// Uses MATERIALIZED CTEs to force GIN index usage before coverage filtering
// MATERIALIZED forces GIN index usage before coverage filter (critical for performance)
// MATERIALIZED forces trigram index usage before coverage filter
func (q *Queries) SearchLocalitiesWithPublisherCoverage(ctx context.Context, arg SearchLocalitiesWithPublisherCoverageParams) ([]SearchLocalitiesWithPublisherCoverageRow, error) {
	rows, err := q.db.Query(ctx, searchLocalitiesWithPublisherCoverage, arg.LimitVal, arg.PublisherID, arg.Query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchLocalitiesWithPublisherCoverageRow{}
	for rows.Next() {
		var i SearchLocalitiesWithPublisherCoverageRow
		if err := rows.Scan(
			&i.EntityType,
			&i.EntityID,
			&i.LocalityID,
			&i.DisplayName,
			&i.DisplayHierarchy,
			&i.DisplayNames,
			&i.LocalityTypeID,
			&i.DirectParentType,
			&i.DirectParentID,
			&i.InheritedRegionID,
			&i.CountryID,
			&i.ContinentID,
			&i.CountryCode,
			&i.Population,
			&i.Latitude,
			&i.Longitude,
			&i.Timezone,
			&i.MatchedTerms,
			&i.NameMatchBonus,
			&i.Tier,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLocalityTimezone = `-- name: UpdateLocalityTimezone :exec
UPDATE geo_localities
SET timezone = $1,
    updated_at = now()
WHERE id = $2
`

type UpdateLocalityTimezoneParams struct {
	Timezone string `json:"timezone"`
	ID       int32  `json:"id"`
}

func (q *Queries) UpdateLocalityTimezone(ctx context.Context, arg UpdateLocalityTimezoneParams) error {
	_, err := q.db.Exec(ctx, updateLocalityTimezone, arg.Timezone, arg.ID)
	return err
}
