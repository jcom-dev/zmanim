// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: publisher_snapshots.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPublisherImportHistory = `-- name: CreatePublisherImportHistory :one

INSERT INTO publisher_import_history (
    publisher_id,
    imported_by,
    format_type,
    format_version,
    source_publisher_id,
    zmanim_created,
    zmanim_updated,
    zmanim_unchanged,
    zmanim_not_in_import,
    coverage_created,
    coverage_updated,
    profile_updated,
    import_summary
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
RETURNING id, publisher_id, imported_by, imported_at, format_type, format_version, source_publisher_id, zmanim_created, zmanim_updated, zmanim_unchanged, zmanim_not_in_import, coverage_created, coverage_updated, profile_updated, import_summary
`

type CreatePublisherImportHistoryParams struct {
	PublisherID       int32  `json:"publisher_id"`
	ImportedBy        string `json:"imported_by"`
	FormatType        string `json:"format_type"`
	FormatVersion     int32  `json:"format_version"`
	SourcePublisherID *int32 `json:"source_publisher_id"`
	ZmanimCreated     int32  `json:"zmanim_created"`
	ZmanimUpdated     int32  `json:"zmanim_updated"`
	ZmanimUnchanged   int32  `json:"zmanim_unchanged"`
	ZmanimNotInImport int32  `json:"zmanim_not_in_import"`
	CoverageCreated   *int32 `json:"coverage_created"`
	CoverageUpdated   *int32 `json:"coverage_updated"`
	ProfileUpdated    *bool  `json:"profile_updated"`
	ImportSummary     []byte `json:"import_summary"`
}

// ============================================
// IMPORT AUDIT TRAIL
// ============================================
// Record import event in audit trail
func (q *Queries) CreatePublisherImportHistory(ctx context.Context, arg CreatePublisherImportHistoryParams) (PublisherImportHistory, error) {
	row := q.db.QueryRow(ctx, createPublisherImportHistory,
		arg.PublisherID,
		arg.ImportedBy,
		arg.FormatType,
		arg.FormatVersion,
		arg.SourcePublisherID,
		arg.ZmanimCreated,
		arg.ZmanimUpdated,
		arg.ZmanimUnchanged,
		arg.ZmanimNotInImport,
		arg.CoverageCreated,
		arg.CoverageUpdated,
		arg.ProfileUpdated,
		arg.ImportSummary,
	)
	var i PublisherImportHistory
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.ImportedBy,
		&i.ImportedAt,
		&i.FormatType,
		&i.FormatVersion,
		&i.SourcePublisherID,
		&i.ZmanimCreated,
		&i.ZmanimUpdated,
		&i.ZmanimUnchanged,
		&i.ZmanimNotInImport,
		&i.CoverageCreated,
		&i.CoverageUpdated,
		&i.ProfileUpdated,
		&i.ImportSummary,
	)
	return i, err
}

const createPublisherSnapshot = `-- name: CreatePublisherSnapshot :one

INSERT INTO publisher_snapshots (
    publisher_id,
    description,
    snapshot_data,
    created_by
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, publisher_id, description, snapshot_data, created_by, created_at
`

type CreatePublisherSnapshotParams struct {
	PublisherID  int32   `json:"publisher_id"`
	Description  *string `json:"description"`
	SnapshotData []byte  `json:"snapshot_data"`
	CreatedBy    *string `json:"created_by"`
}

// ============================================
// PUBLISHER SNAPSHOT (ZMANIM-ONLY) QUERIES
// ============================================
// Snapshots store only zmanim data (not profile/coverage)
// Used for version control of publisher algorithms
func (q *Queries) CreatePublisherSnapshot(ctx context.Context, arg CreatePublisherSnapshotParams) (PublisherSnapshot, error) {
	row := q.db.QueryRow(ctx, createPublisherSnapshot,
		arg.PublisherID,
		arg.Description,
		arg.SnapshotData,
		arg.CreatedBy,
	)
	var i PublisherSnapshot
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.Description,
		&i.SnapshotData,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const deletePublisherCoverageForImport = `-- name: DeletePublisherCoverageForImport :exec
DELETE FROM publisher_coverage
WHERE publisher_id = $1
`

// Delete all coverage for a publisher (before re-importing)
func (q *Queries) DeletePublisherCoverageForImport(ctx context.Context, publisherID int32) error {
	_, err := q.db.Exec(ctx, deletePublisherCoverageForImport, publisherID)
	return err
}

const deletePublisherSnapshot = `-- name: DeletePublisherSnapshot :exec
DELETE FROM publisher_snapshots
WHERE id = $1 AND publisher_id = $2
`

type DeletePublisherSnapshotParams struct {
	ID          int32 `json:"id"`
	PublisherID int32 `json:"publisher_id"`
}

func (q *Queries) DeletePublisherSnapshot(ctx context.Context, arg DeletePublisherSnapshotParams) error {
	_, err := q.db.Exec(ctx, deletePublisherSnapshot, arg.ID, arg.PublisherID)
	return err
}

const getAllPublisherZmanimKeys = `-- name: GetAllPublisherZmanimKeys :many
SELECT zman_key
FROM publisher_zmanim
WHERE publisher_id = $1 AND deleted_at IS NULL
`

// Get all active zman keys for a publisher (for diff comparison)
func (q *Queries) GetAllPublisherZmanimKeys(ctx context.Context, publisherID int32) ([]string, error) {
	rows, err := q.db.Query(ctx, getAllPublisherZmanimKeys, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var zman_key string
		if err := rows.Scan(&zman_key); err != nil {
			return nil, err
		}
		items = append(items, zman_key)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompletePublisherExport = `-- name: GetCompletePublisherExport :one

SELECT
    p.id,
    p.name,
    p.contact_email,
    p.phone,
    p.website,
    COALESCE(p.description, '') as description,
    COALESCE(p.bio, '') as bio,
    p.logo_url,
    p.logo_data,
    p.latitude,
    p.longitude,
    p.timezone,
    p.ignore_elevation,
    p.is_published,
    p.is_verified,
    p.is_certified,
    ps.key as status_key,
    ps.display_name_hebrew as status_display_hebrew,
    ps.display_name_english as status_display_english,
    p.created_at,
    p.updated_at
FROM publishers p
JOIN publisher_statuses ps ON ps.id = p.status_id
WHERE p.id = $1
`

type GetCompletePublisherExportRow struct {
	ID                   int32              `json:"id"`
	Name                 string             `json:"name"`
	ContactEmail         string             `json:"contact_email"`
	Phone                *string            `json:"phone"`
	Website              *string            `json:"website"`
	Description          string             `json:"description"`
	Bio                  string             `json:"bio"`
	LogoUrl              *string            `json:"logo_url"`
	LogoData             *string            `json:"logo_data"`
	Latitude             *float64           `json:"latitude"`
	Longitude            *float64           `json:"longitude"`
	Timezone             *string            `json:"timezone"`
	IgnoreElevation      bool               `json:"ignore_elevation"`
	IsPublished          bool               `json:"is_published"`
	IsVerified           bool               `json:"is_verified"`
	IsCertified          bool               `json:"is_certified"`
	StatusKey            string             `json:"status_key"`
	StatusDisplayHebrew  string             `json:"status_display_hebrew"`
	StatusDisplayEnglish string             `json:"status_display_english"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

// ============================================
// COMPLETE PUBLISHER EXPORT (ADMIN/BACKUP)
// ============================================
// Complete export includes profile, logo, coverage, zmanim
// Different from publisher-accessible snapshot (zmanim-only)
// Get complete publisher data for backup/admin export
func (q *Queries) GetCompletePublisherExport(ctx context.Context, id int32) (GetCompletePublisherExportRow, error) {
	row := q.db.QueryRow(ctx, getCompletePublisherExport, id)
	var i GetCompletePublisherExportRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ContactEmail,
		&i.Phone,
		&i.Website,
		&i.Description,
		&i.Bio,
		&i.LogoUrl,
		&i.LogoData,
		&i.Latitude,
		&i.Longitude,
		&i.Timezone,
		&i.IgnoreElevation,
		&i.IsPublished,
		&i.IsVerified,
		&i.IsCertified,
		&i.StatusKey,
		&i.StatusDisplayHebrew,
		&i.StatusDisplayEnglish,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCoverageLevelIdByKey = `-- name: GetCoverageLevelIdByKey :one
SELECT id
FROM coverage_levels
WHERE key = $1
`

// Lookup coverage level ID from key for import
func (q *Queries) GetCoverageLevelIdByKey(ctx context.Context, key string) (int16, error) {
	row := q.db.QueryRow(ctx, getCoverageLevelIdByKey, key)
	var id int16
	err := row.Scan(&id)
	return id, err
}

const getDeletedZmanByKey = `-- name: GetDeletedZmanByKey :one
SELECT id, zman_key
FROM publisher_zmanim
WHERE publisher_id = $1 AND zman_key = $2 AND deleted_at IS NOT NULL
`

type GetDeletedZmanByKeyParams struct {
	PublisherID int32  `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

type GetDeletedZmanByKeyRow struct {
	ID      int32  `json:"id"`
	ZmanKey string `json:"zman_key"`
}

// Check if a zman exists in deleted state (for restore decision)
func (q *Queries) GetDeletedZmanByKey(ctx context.Context, arg GetDeletedZmanByKeyParams) (GetDeletedZmanByKeyRow, error) {
	row := q.db.QueryRow(ctx, getDeletedZmanByKey, arg.PublisherID, arg.ZmanKey)
	var i GetDeletedZmanByKeyRow
	err := row.Scan(&i.ID, &i.ZmanKey)
	return i, err
}

const getLatestPublisherSnapshot = `-- name: GetLatestPublisherSnapshot :one
SELECT id, publisher_id, description, snapshot_data, created_by, created_at
FROM publisher_snapshots
WHERE publisher_id = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestPublisherSnapshot(ctx context.Context, publisherID int32) (PublisherSnapshot, error) {
	row := q.db.QueryRow(ctx, getLatestPublisherSnapshot, publisherID)
	var i PublisherSnapshot
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.Description,
		&i.SnapshotData,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getPublisherCoverageForExport = `-- name: GetPublisherCoverageForExport :many
SELECT
    pc.id,
    cl.key as coverage_level_key,
    cl.display_name_hebrew as coverage_level_display_hebrew,
    cl.display_name_english as coverage_level_display_english,
    pc.continent_id,
    ct.name as continent_name,
    pc.country_id,
    co.code as country_code,
    co.name as country_name,
    pc.region_id,
    r.code as region_code,
    r.name as region_name,
    pc.locality_id,
    l.name as locality_name,
    rc.latitude as locality_latitude,
    rc.longitude as locality_longitude,
    pc.priority,
    pc.is_active,
    pc.created_at
FROM publisher_coverage pc
JOIN coverage_levels cl ON cl.id = pc.coverage_level_id
LEFT JOIN geo_continents ct ON pc.continent_id = ct.id
LEFT JOIN geo_countries co ON pc.country_id = co.id
LEFT JOIN geo_regions r ON pc.region_id = r.id
LEFT JOIN geo_localities l ON pc.locality_id = l.id
LEFT JOIN geo_locality_resolved_coords rc ON rc.locality_id = l.id
WHERE pc.publisher_id = $1
ORDER BY cl.sort_order, pc.priority DESC, pc.created_at DESC
`

type GetPublisherCoverageForExportRow struct {
	ID                          int32              `json:"id"`
	CoverageLevelKey            string             `json:"coverage_level_key"`
	CoverageLevelDisplayHebrew  string             `json:"coverage_level_display_hebrew"`
	CoverageLevelDisplayEnglish string             `json:"coverage_level_display_english"`
	ContinentID                 *int16             `json:"continent_id"`
	ContinentName               *string            `json:"continent_name"`
	CountryID                   *int16             `json:"country_id"`
	CountryCode                 *string            `json:"country_code"`
	CountryName                 *string            `json:"country_name"`
	RegionID                    *int32             `json:"region_id"`
	RegionCode                  *string            `json:"region_code"`
	RegionName                  *string            `json:"region_name"`
	LocalityID                  *int32             `json:"locality_id"`
	LocalityName                *string            `json:"locality_name"`
	LocalityLatitude            *float64           `json:"locality_latitude"`
	LocalityLongitude           *float64           `json:"locality_longitude"`
	Priority                    *int32             `json:"priority"`
	IsActive                    bool               `json:"is_active"`
	CreatedAt                   pgtype.Timestamptz `json:"created_at"`
}

// Get all coverage areas for complete export
func (q *Queries) GetPublisherCoverageForExport(ctx context.Context, publisherID int32) ([]GetPublisherCoverageForExportRow, error) {
	rows, err := q.db.Query(ctx, getPublisherCoverageForExport, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherCoverageForExportRow{}
	for rows.Next() {
		var i GetPublisherCoverageForExportRow
		if err := rows.Scan(
			&i.ID,
			&i.CoverageLevelKey,
			&i.CoverageLevelDisplayHebrew,
			&i.CoverageLevelDisplayEnglish,
			&i.ContinentID,
			&i.ContinentName,
			&i.CountryID,
			&i.CountryCode,
			&i.CountryName,
			&i.RegionID,
			&i.RegionCode,
			&i.RegionName,
			&i.LocalityID,
			&i.LocalityName,
			&i.LocalityLatitude,
			&i.LocalityLongitude,
			&i.Priority,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherSnapshot = `-- name: GetPublisherSnapshot :one
SELECT id, publisher_id, description, snapshot_data, created_by, created_at
FROM publisher_snapshots
WHERE id = $1 AND publisher_id = $2
`

type GetPublisherSnapshotParams struct {
	ID          int32 `json:"id"`
	PublisherID int32 `json:"publisher_id"`
}

func (q *Queries) GetPublisherSnapshot(ctx context.Context, arg GetPublisherSnapshotParams) (PublisherSnapshot, error) {
	row := q.db.QueryRow(ctx, getPublisherSnapshot, arg.ID, arg.PublisherID)
	var i PublisherSnapshot
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.Description,
		&i.SnapshotData,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getPublisherZmanForSnapshotCompare = `-- name: GetPublisherZmanForSnapshotCompare :one
SELECT
    pz.id,
    pz.zman_key,
    pz.hebrew_name,
    pz.english_name,
    pz.transliteration,
    pz.description,
    pz.formula_dsl,
    pz.ai_explanation,
    pz.publisher_comment,
    pz.is_enabled,
    pz.is_visible,
    pz.is_published,
    pz.is_beta,
    pz.is_custom,
    pz.display_status,
    pz.time_category_id,
    tc.key AS category,
    tc.display_name_hebrew AS category_display_hebrew,
    tc.display_name_english AS category_display_english,
    pz.master_zman_id,
    pz.linked_publisher_zman_id,
    pz.current_version
FROM publisher_zmanim pz
JOIN time_categories tc ON tc.id = pz.time_category_id
WHERE pz.publisher_id = $1 AND pz.zman_key = $2 AND pz.deleted_at IS NULL
`

type GetPublisherZmanForSnapshotCompareParams struct {
	PublisherID int32  `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

type GetPublisherZmanForSnapshotCompareRow struct {
	ID                     int32         `json:"id"`
	ZmanKey                string        `json:"zman_key"`
	HebrewName             string        `json:"hebrew_name"`
	EnglishName            string        `json:"english_name"`
	Transliteration        *string       `json:"transliteration"`
	Description            *string       `json:"description"`
	FormulaDsl             string        `json:"formula_dsl"`
	AiExplanation          *string       `json:"ai_explanation"`
	PublisherComment       *string       `json:"publisher_comment"`
	IsEnabled              bool          `json:"is_enabled"`
	IsVisible              bool          `json:"is_visible"`
	IsPublished            bool          `json:"is_published"`
	IsBeta                 bool          `json:"is_beta"`
	IsCustom               bool          `json:"is_custom"`
	DisplayStatus          DisplayStatus `json:"display_status"`
	TimeCategoryID         *int32        `json:"time_category_id"`
	Category               string        `json:"category"`
	CategoryDisplayHebrew  string        `json:"category_display_hebrew"`
	CategoryDisplayEnglish string        `json:"category_display_english"`
	MasterZmanID           *int32        `json:"master_zman_id"`
	LinkedPublisherZmanID  *int32        `json:"linked_publisher_zman_id"`
	CurrentVersion         *int32        `json:"current_version"`
}

// Get a specific zman by key for comparison during restore
func (q *Queries) GetPublisherZmanForSnapshotCompare(ctx context.Context, arg GetPublisherZmanForSnapshotCompareParams) (GetPublisherZmanForSnapshotCompareRow, error) {
	row := q.db.QueryRow(ctx, getPublisherZmanForSnapshotCompare, arg.PublisherID, arg.ZmanKey)
	var i GetPublisherZmanForSnapshotCompareRow
	err := row.Scan(
		&i.ID,
		&i.ZmanKey,
		&i.HebrewName,
		&i.EnglishName,
		&i.Transliteration,
		&i.Description,
		&i.FormulaDsl,
		&i.AiExplanation,
		&i.PublisherComment,
		&i.IsEnabled,
		&i.IsVisible,
		&i.IsPublished,
		&i.IsBeta,
		&i.IsCustom,
		&i.DisplayStatus,
		&i.TimeCategoryID,
		&i.Category,
		&i.CategoryDisplayHebrew,
		&i.CategoryDisplayEnglish,
		&i.MasterZmanID,
		&i.LinkedPublisherZmanID,
		&i.CurrentVersion,
	)
	return i, err
}

const getPublisherZmanTagsForExport = `-- name: GetPublisherZmanTagsForExport :many

SELECT
    zt.tag_key,
    pzt.is_negated
FROM publisher_zman_tags pzt
JOIN zman_tags zt ON zt.id = pzt.tag_id
WHERE pzt.publisher_zman_id = $1
ORDER BY zt.tag_key
`

type GetPublisherZmanTagsForExportRow struct {
	TagKey    string `json:"tag_key"`
	IsNegated bool   `json:"is_negated"`
}

// ============================================
// TAG EXPORT QUERIES
// ============================================
// Get all tags for a specific zman for export
func (q *Queries) GetPublisherZmanTagsForExport(ctx context.Context, publisherZmanID int32) ([]GetPublisherZmanTagsForExportRow, error) {
	rows, err := q.db.Query(ctx, getPublisherZmanTagsForExport, publisherZmanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherZmanTagsForExportRow{}
	for rows.Next() {
		var i GetPublisherZmanTagsForExportRow
		if err := rows.Scan(&i.TagKey, &i.IsNegated); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherZmanimForCompleteExport = `-- name: GetPublisherZmanimForCompleteExport :many
SELECT
    pz.id,
    pz.zman_key,
    pz.hebrew_name,
    pz.english_name,
    pz.transliteration,
    pz.description,
    pz.formula_dsl,
    pz.ai_explanation,
    pz.publisher_comment,
    pz.is_enabled,
    pz.is_visible,
    pz.is_published,
    pz.is_beta,
    pz.is_custom,
    pz.rounding_mode,
    pz.display_status,
    tc.key AS category,
    tc.display_name_hebrew AS category_display_hebrew,
    tc.display_name_english AS category_display_english,
    pz.master_zman_id,
    pz.linked_publisher_zman_id,
    pz.current_version,
    pz.created_at,
    pz.updated_at
FROM publisher_zmanim pz
LEFT JOIN time_categories tc ON tc.id = pz.time_category_id
WHERE pz.publisher_id = $1 AND pz.deleted_at IS NULL
ORDER BY pz.zman_key
`

type GetPublisherZmanimForCompleteExportRow struct {
	ID                     int32              `json:"id"`
	ZmanKey                string             `json:"zman_key"`
	HebrewName             string             `json:"hebrew_name"`
	EnglishName            string             `json:"english_name"`
	Transliteration        *string            `json:"transliteration"`
	Description            *string            `json:"description"`
	FormulaDsl             string             `json:"formula_dsl"`
	AiExplanation          *string            `json:"ai_explanation"`
	PublisherComment       *string            `json:"publisher_comment"`
	IsEnabled              bool               `json:"is_enabled"`
	IsVisible              bool               `json:"is_visible"`
	IsPublished            bool               `json:"is_published"`
	IsBeta                 bool               `json:"is_beta"`
	IsCustom               bool               `json:"is_custom"`
	RoundingMode           string             `json:"rounding_mode"`
	DisplayStatus          DisplayStatus      `json:"display_status"`
	Category               *string            `json:"category"`
	CategoryDisplayHebrew  *string            `json:"category_display_hebrew"`
	CategoryDisplayEnglish *string            `json:"category_display_english"`
	MasterZmanID           *int32             `json:"master_zman_id"`
	LinkedPublisherZmanID  *int32             `json:"linked_publisher_zman_id"`
	CurrentVersion         *int32             `json:"current_version"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
}

// Get all zmanim for complete export
func (q *Queries) GetPublisherZmanimForCompleteExport(ctx context.Context, publisherID int32) ([]GetPublisherZmanimForCompleteExportRow, error) {
	rows, err := q.db.Query(ctx, getPublisherZmanimForCompleteExport, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherZmanimForCompleteExportRow{}
	for rows.Next() {
		var i GetPublisherZmanimForCompleteExportRow
		if err := rows.Scan(
			&i.ID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.Transliteration,
			&i.Description,
			&i.FormulaDsl,
			&i.AiExplanation,
			&i.PublisherComment,
			&i.IsEnabled,
			&i.IsVisible,
			&i.IsPublished,
			&i.IsBeta,
			&i.IsCustom,
			&i.RoundingMode,
			&i.DisplayStatus,
			&i.Category,
			&i.CategoryDisplayHebrew,
			&i.CategoryDisplayEnglish,
			&i.MasterZmanID,
			&i.LinkedPublisherZmanID,
			&i.CurrentVersion,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherZmanimForSnapshot = `-- name: GetPublisherZmanimForSnapshot :many

SELECT
    pz.id,
    pz.zman_key,
    pz.hebrew_name,
    pz.english_name,
    pz.transliteration,
    pz.description,
    pz.formula_dsl,
    pz.ai_explanation,
    pz.publisher_comment,
    pz.is_enabled,
    pz.is_visible,
    pz.is_published,
    pz.is_beta,
    pz.is_custom,
    pz.rounding_mode,
    pz.display_status,
    pz.time_category_id,
    tc.key AS category,
    tc.display_name_hebrew AS category_display_hebrew,
    tc.display_name_english AS category_display_english,
    pz.master_zman_id,
    pz.linked_publisher_zman_id
FROM publisher_zmanim pz
JOIN time_categories tc ON tc.id = pz.time_category_id
WHERE pz.publisher_id = $1 AND pz.deleted_at IS NULL
`

type GetPublisherZmanimForSnapshotRow struct {
	ID                     int32         `json:"id"`
	ZmanKey                string        `json:"zman_key"`
	HebrewName             string        `json:"hebrew_name"`
	EnglishName            string        `json:"english_name"`
	Transliteration        *string       `json:"transliteration"`
	Description            *string       `json:"description"`
	FormulaDsl             string        `json:"formula_dsl"`
	AiExplanation          *string       `json:"ai_explanation"`
	PublisherComment       *string       `json:"publisher_comment"`
	IsEnabled              bool          `json:"is_enabled"`
	IsVisible              bool          `json:"is_visible"`
	IsPublished            bool          `json:"is_published"`
	IsBeta                 bool          `json:"is_beta"`
	IsCustom               bool          `json:"is_custom"`
	RoundingMode           string        `json:"rounding_mode"`
	DisplayStatus          DisplayStatus `json:"display_status"`
	TimeCategoryID         *int32        `json:"time_category_id"`
	Category               string        `json:"category"`
	CategoryDisplayHebrew  string        `json:"category_display_hebrew"`
	CategoryDisplayEnglish string        `json:"category_display_english"`
	MasterZmanID           *int32        `json:"master_zman_id"`
	LinkedPublisherZmanID  *int32        `json:"linked_publisher_zman_id"`
}

// ============================================
// ZMANIM SNAPSHOT DATA QUERIES
// ============================================
// Get all active (non-deleted) zmanim for snapshot export
func (q *Queries) GetPublisherZmanimForSnapshot(ctx context.Context, publisherID int32) ([]GetPublisherZmanimForSnapshotRow, error) {
	rows, err := q.db.Query(ctx, getPublisherZmanimForSnapshot, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublisherZmanimForSnapshotRow{}
	for rows.Next() {
		var i GetPublisherZmanimForSnapshotRow
		if err := rows.Scan(
			&i.ID,
			&i.ZmanKey,
			&i.HebrewName,
			&i.EnglishName,
			&i.Transliteration,
			&i.Description,
			&i.FormulaDsl,
			&i.AiExplanation,
			&i.PublisherComment,
			&i.IsEnabled,
			&i.IsVisible,
			&i.IsPublished,
			&i.IsBeta,
			&i.IsCustom,
			&i.RoundingMode,
			&i.DisplayStatus,
			&i.TimeCategoryID,
			&i.Category,
			&i.CategoryDisplayHebrew,
			&i.CategoryDisplayEnglish,
			&i.MasterZmanID,
			&i.LinkedPublisherZmanID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTimeCategoryIDByKey = `-- name: GetTimeCategoryIDByKey :one
SELECT id
FROM time_categories
WHERE key = $1
`

// Lookup time category ID from key for import
func (q *Queries) GetTimeCategoryIDByKey(ctx context.Context, key string) (int32, error) {
	row := q.db.QueryRow(ctx, getTimeCategoryIDByKey, key)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getZmanTagIdByKey = `-- name: GetZmanTagIdByKey :one

SELECT id
FROM zman_tags
WHERE tag_key = $1
`

// ============================================
// IMPORT QUERIES
// ============================================
// Lookup tag ID from tag key for import
func (q *Queries) GetZmanTagIdByKey(ctx context.Context, tagKey string) (int32, error) {
	row := q.db.QueryRow(ctx, getZmanTagIdByKey, tagKey)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertPublisherCoverageFromImport = `-- name: InsertPublisherCoverageFromImport :one
INSERT INTO publisher_coverage (
    publisher_id,
    coverage_level_id,
    continent_id,
    country_id,
    region_id,
    locality_id,
    priority,
    is_active
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id
`

type InsertPublisherCoverageFromImportParams struct {
	PublisherID     int32  `json:"publisher_id"`
	CoverageLevelID int16  `json:"coverage_level_id"`
	ContinentID     *int16 `json:"continent_id"`
	CountryID       *int16 `json:"country_id"`
	RegionID        *int32 `json:"region_id"`
	LocalityID      *int32 `json:"locality_id"`
	Priority        *int32 `json:"priority"`
	IsActive        bool   `json:"is_active"`
}

// Insert coverage area from import (assumes coverage was deleted first)
func (q *Queries) InsertPublisherCoverageFromImport(ctx context.Context, arg InsertPublisherCoverageFromImportParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertPublisherCoverageFromImport,
		arg.PublisherID,
		arg.CoverageLevelID,
		arg.ContinentID,
		arg.CountryID,
		arg.RegionID,
		arg.LocalityID,
		arg.Priority,
		arg.IsActive,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertZmanFromSnapshot = `-- name: InsertZmanFromSnapshot :exec
INSERT INTO publisher_zmanim (
    publisher_id,
    zman_key,
    hebrew_name,
    english_name,
    transliteration,
    description,
    formula_dsl,
    ai_explanation,
    publisher_comment,
    is_enabled,
    is_visible,
    is_published,
    is_beta,
    is_custom,
    time_category_id,
    master_zman_id,
    linked_publisher_zman_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
)
`

type InsertZmanFromSnapshotParams struct {
	PublisherID           int32   `json:"publisher_id"`
	ZmanKey               string  `json:"zman_key"`
	HebrewName            string  `json:"hebrew_name"`
	EnglishName           string  `json:"english_name"`
	Transliteration       *string `json:"transliteration"`
	Description           *string `json:"description"`
	FormulaDsl            string  `json:"formula_dsl"`
	AiExplanation         *string `json:"ai_explanation"`
	PublisherComment      *string `json:"publisher_comment"`
	IsEnabled             bool    `json:"is_enabled"`
	IsVisible             bool    `json:"is_visible"`
	IsPublished           bool    `json:"is_published"`
	IsBeta                bool    `json:"is_beta"`
	IsCustom              bool    `json:"is_custom"`
	TimeCategoryID        *int32  `json:"time_category_id"`
	MasterZmanID          *int32  `json:"master_zman_id"`
	LinkedPublisherZmanID *int32  `json:"linked_publisher_zman_id"`
}

// Insert a new zman from snapshot (zman doesn't exist at all)
func (q *Queries) InsertZmanFromSnapshot(ctx context.Context, arg InsertZmanFromSnapshotParams) error {
	_, err := q.db.Exec(ctx, insertZmanFromSnapshot,
		arg.PublisherID,
		arg.ZmanKey,
		arg.HebrewName,
		arg.EnglishName,
		arg.Transliteration,
		arg.Description,
		arg.FormulaDsl,
		arg.AiExplanation,
		arg.PublisherComment,
		arg.IsEnabled,
		arg.IsVisible,
		arg.IsPublished,
		arg.IsBeta,
		arg.IsCustom,
		arg.TimeCategoryID,
		arg.MasterZmanID,
		arg.LinkedPublisherZmanID,
	)
	return err
}

const listPublisherSnapshots = `-- name: ListPublisherSnapshots :many
SELECT
    id,
    publisher_id,
    description,
    created_by,
    created_at
FROM publisher_snapshots
WHERE publisher_id = $1
ORDER BY created_at DESC
LIMIT 20
`

type ListPublisherSnapshotsRow struct {
	ID          int32              `json:"id"`
	PublisherID int32              `json:"publisher_id"`
	Description *string            `json:"description"`
	CreatedBy   *string            `json:"created_by"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) ListPublisherSnapshots(ctx context.Context, publisherID int32) ([]ListPublisherSnapshotsRow, error) {
	rows, err := q.db.Query(ctx, listPublisherSnapshots, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPublisherSnapshotsRow{}
	for rows.Next() {
		var i ListPublisherSnapshotsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.Description,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreDeletedZmanForSnapshot = `-- name: RestoreDeletedZmanForSnapshot :exec
UPDATE publisher_zmanim
SET deleted_at = NULL, deleted_by = NULL, updated_at = NOW()
WHERE publisher_id = $1 AND zman_key = $2 AND deleted_at IS NOT NULL
`

type RestoreDeletedZmanForSnapshotParams struct {
	PublisherID int32  `json:"publisher_id"`
	ZmanKey     string `json:"zman_key"`
}

// Restore a soft-deleted zman that exists in snapshot being restored
func (q *Queries) RestoreDeletedZmanForSnapshot(ctx context.Context, arg RestoreDeletedZmanForSnapshotParams) error {
	_, err := q.db.Exec(ctx, restoreDeletedZmanForSnapshot, arg.PublisherID, arg.ZmanKey)
	return err
}

const softDeleteZmanForRestore = `-- name: SoftDeleteZmanForRestore :exec

UPDATE publisher_zmanim
SET deleted_at = NOW(), deleted_by = $3, updated_at = NOW()
WHERE publisher_id = $1 AND zman_key = $2 AND deleted_at IS NULL
`

type SoftDeleteZmanForRestoreParams struct {
	PublisherID int32   `json:"publisher_id"`
	ZmanKey     string  `json:"zman_key"`
	DeletedBy   *string `json:"deleted_by"`
}

// ============================================
// SNAPSHOT RESTORE QUERIES
// ============================================
// Soft delete a zman that exists in current state but not in snapshot being restored
func (q *Queries) SoftDeleteZmanForRestore(ctx context.Context, arg SoftDeleteZmanForRestoreParams) error {
	_, err := q.db.Exec(ctx, softDeleteZmanForRestore, arg.PublisherID, arg.ZmanKey, arg.DeletedBy)
	return err
}

const updatePublisherProfileFromImport = `-- name: UpdatePublisherProfileFromImport :exec

UPDATE publishers
SET
    name = COALESCE($2, name),
    contact_email = COALESCE($3, contact_email),
    description = COALESCE($4, description),
    bio = COALESCE($5, bio),
    logo_url = COALESCE($6, logo_url),
    logo_data = COALESCE($7, logo_data),
    phone = COALESCE($8, phone),
    website = COALESCE($9, website),
    timezone = COALESCE($10, timezone),
    latitude = COALESCE($11, latitude),
    longitude = COALESCE($12, longitude),
    ignore_elevation = COALESCE($13, ignore_elevation),
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

type UpdatePublisherProfileFromImportParams struct {
	ID              int32    `json:"id"`
	Name            string   `json:"name"`
	ContactEmail    string   `json:"contact_email"`
	Description     *string  `json:"description"`
	Bio             *string  `json:"bio"`
	LogoUrl         *string  `json:"logo_url"`
	LogoData        *string  `json:"logo_data"`
	Phone           *string  `json:"phone"`
	Website         *string  `json:"website"`
	Timezone        *string  `json:"timezone"`
	Latitude        *float64 `json:"latitude"`
	Longitude       *float64 `json:"longitude"`
	IgnoreElevation bool     `json:"ignore_elevation"`
}

// ============================================
// PROFILE AND COVERAGE IMPORT
// ============================================
// Update publisher profile fields from import
func (q *Queries) UpdatePublisherProfileFromImport(ctx context.Context, arg UpdatePublisherProfileFromImportParams) error {
	_, err := q.db.Exec(ctx, updatePublisherProfileFromImport,
		arg.ID,
		arg.Name,
		arg.ContactEmail,
		arg.Description,
		arg.Bio,
		arg.LogoUrl,
		arg.LogoData,
		arg.Phone,
		arg.Website,
		arg.Timezone,
		arg.Latitude,
		arg.Longitude,
		arg.IgnoreElevation,
	)
	return err
}

const updateZmanFromSnapshot = `-- name: UpdateZmanFromSnapshot :exec
UPDATE publisher_zmanim
SET
    hebrew_name = $3,
    english_name = $4,
    transliteration = $5,
    description = $6,
    formula_dsl = $7,
    ai_explanation = $8,
    publisher_comment = $9,
    is_enabled = $10,
    is_visible = $11,
    is_published = $12,
    is_beta = $13,
    is_custom = $14,
    time_category_id = $15,
    master_zman_id = $16,
    linked_publisher_zman_id = $17,
    updated_at = NOW()
WHERE publisher_id = $1 AND zman_key = $2 AND deleted_at IS NULL
`

type UpdateZmanFromSnapshotParams struct {
	PublisherID           int32   `json:"publisher_id"`
	ZmanKey               string  `json:"zman_key"`
	HebrewName            string  `json:"hebrew_name"`
	EnglishName           string  `json:"english_name"`
	Transliteration       *string `json:"transliteration"`
	Description           *string `json:"description"`
	FormulaDsl            string  `json:"formula_dsl"`
	AiExplanation         *string `json:"ai_explanation"`
	PublisherComment      *string `json:"publisher_comment"`
	IsEnabled             bool    `json:"is_enabled"`
	IsVisible             bool    `json:"is_visible"`
	IsPublished           bool    `json:"is_published"`
	IsBeta                bool    `json:"is_beta"`
	IsCustom              bool    `json:"is_custom"`
	TimeCategoryID        *int32  `json:"time_category_id"`
	MasterZmanID          *int32  `json:"master_zman_id"`
	LinkedPublisherZmanID *int32  `json:"linked_publisher_zman_id"`
}

// Update an existing zman with data from snapshot (creates new version via trigger)
func (q *Queries) UpdateZmanFromSnapshot(ctx context.Context, arg UpdateZmanFromSnapshotParams) error {
	_, err := q.db.Exec(ctx, updateZmanFromSnapshot,
		arg.PublisherID,
		arg.ZmanKey,
		arg.HebrewName,
		arg.EnglishName,
		arg.Transliteration,
		arg.Description,
		arg.FormulaDsl,
		arg.AiExplanation,
		arg.PublisherComment,
		arg.IsEnabled,
		arg.IsVisible,
		arg.IsPublished,
		arg.IsBeta,
		arg.IsCustom,
		arg.TimeCategoryID,
		arg.MasterZmanID,
		arg.LinkedPublisherZmanID,
	)
	return err
}

const upsertPublisherZmanFromImport = `-- name: UpsertPublisherZmanFromImport :one
INSERT INTO publisher_zmanim (
    publisher_id,
    zman_key,
    hebrew_name,
    english_name,
    transliteration,
    description,
    formula_dsl,
    ai_explanation,
    publisher_comment,
    is_enabled,
    is_visible,
    is_published,
    is_beta,
    is_custom,
    rounding_mode,
    display_status,
    time_category_id,
    master_zman_id,
    linked_publisher_zman_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19
)
ON CONFLICT (publisher_id, zman_key)
WHERE deleted_at IS NULL
DO UPDATE SET
    hebrew_name = EXCLUDED.hebrew_name,
    english_name = EXCLUDED.english_name,
    transliteration = EXCLUDED.transliteration,
    description = EXCLUDED.description,
    formula_dsl = EXCLUDED.formula_dsl,
    ai_explanation = EXCLUDED.ai_explanation,
    publisher_comment = EXCLUDED.publisher_comment,
    is_enabled = EXCLUDED.is_enabled,
    is_visible = EXCLUDED.is_visible,
    is_published = EXCLUDED.is_published,
    is_beta = EXCLUDED.is_beta,
    is_custom = EXCLUDED.is_custom,
    rounding_mode = EXCLUDED.rounding_mode,
    display_status = EXCLUDED.display_status,
    time_category_id = EXCLUDED.time_category_id,
    master_zman_id = EXCLUDED.master_zman_id,
    linked_publisher_zman_id = EXCLUDED.linked_publisher_zman_id,
    updated_at = NOW(),
    deleted_at = NULL,
    deleted_by = NULL
RETURNING id
`

type UpsertPublisherZmanFromImportParams struct {
	PublisherID           int32         `json:"publisher_id"`
	ZmanKey               string        `json:"zman_key"`
	HebrewName            string        `json:"hebrew_name"`
	EnglishName           string        `json:"english_name"`
	Transliteration       *string       `json:"transliteration"`
	Description           *string       `json:"description"`
	FormulaDsl            string        `json:"formula_dsl"`
	AiExplanation         *string       `json:"ai_explanation"`
	PublisherComment      *string       `json:"publisher_comment"`
	IsEnabled             bool          `json:"is_enabled"`
	IsVisible             bool          `json:"is_visible"`
	IsPublished           bool          `json:"is_published"`
	IsBeta                bool          `json:"is_beta"`
	IsCustom              bool          `json:"is_custom"`
	RoundingMode          string        `json:"rounding_mode"`
	DisplayStatus         DisplayStatus `json:"display_status"`
	TimeCategoryID        *int32        `json:"time_category_id"`
	MasterZmanID          *int32        `json:"master_zman_id"`
	LinkedPublisherZmanID *int32        `json:"linked_publisher_zman_id"`
}

// Insert or update a zman during import (handles all fields including rounding_mode)
func (q *Queries) UpsertPublisherZmanFromImport(ctx context.Context, arg UpsertPublisherZmanFromImportParams) (int32, error) {
	row := q.db.QueryRow(ctx, upsertPublisherZmanFromImport,
		arg.PublisherID,
		arg.ZmanKey,
		arg.HebrewName,
		arg.EnglishName,
		arg.Transliteration,
		arg.Description,
		arg.FormulaDsl,
		arg.AiExplanation,
		arg.PublisherComment,
		arg.IsEnabled,
		arg.IsVisible,
		arg.IsPublished,
		arg.IsBeta,
		arg.IsCustom,
		arg.RoundingMode,
		arg.DisplayStatus,
		arg.TimeCategoryID,
		arg.MasterZmanID,
		arg.LinkedPublisherZmanID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}
