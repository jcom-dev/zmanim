// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: admin.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const adminCountAlgorithms = `-- name: AdminCountAlgorithms :one
SELECT COUNT(*)
FROM algorithms a
JOIN algorithm_statuses astatus ON astatus.id = a.status_id
WHERE ($1::text IS NULL OR astatus.key = $1)
`

func (q *Queries) AdminCountAlgorithms(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, adminCountAlgorithms, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const adminCountPublishers = `-- name: AdminCountPublishers :one
SELECT COUNT(*)
FROM publishers p
JOIN publisher_statuses ps ON ps.id = p.status_id
WHERE ($1::text IS NULL OR ps.key = $1)
`

func (q *Queries) AdminCountPublishers(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, adminCountPublishers, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const adminCreatePublisher = `-- name: AdminCreatePublisher :one

INSERT INTO publishers (name, slug, contact_email, website, description, status_id)
VALUES ($1, $2, $3, $4, $5, (SELECT id FROM publisher_statuses WHERE key = 'active'))
RETURNING id, name, slug, contact_email, website, description,
          status_id, created_at, updated_at
`

type AdminCreatePublisherParams struct {
	Name         string  `json:"name"`
	Slug         *string `json:"slug"`
	ContactEmail string  `json:"contact_email"`
	Website      *string `json:"website"`
	Description  *string `json:"description"`
}

type AdminCreatePublisherRow struct {
	ID           int32              `json:"id"`
	Name         string             `json:"name"`
	Slug         *string            `json:"slug"`
	ContactEmail string             `json:"contact_email"`
	Website      *string            `json:"website"`
	Description  *string            `json:"description"`
	StatusID     int16              `json:"status_id"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

// Publisher Creation --
func (q *Queries) AdminCreatePublisher(ctx context.Context, arg AdminCreatePublisherParams) (AdminCreatePublisherRow, error) {
	row := q.db.QueryRow(ctx, adminCreatePublisher,
		arg.Name,
		arg.Slug,
		arg.ContactEmail,
		arg.Website,
		arg.Description,
	)
	var i AdminCreatePublisherRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.ContactEmail,
		&i.Website,
		&i.Description,
		&i.StatusID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const adminDeletePublisher = `-- name: AdminDeletePublisher :exec
DELETE FROM publishers WHERE id = $1
`

func (q *Queries) AdminDeletePublisher(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, adminDeletePublisher, id)
	return err
}

const adminGetPublisher = `-- name: AdminGetPublisher :one
SELECT p.id, p.clerk_user_id, p.name, p.contact_email, p.description, p.bio,
       p.website, p.logo_url, p.status_id,
       ps.key as status_key,
       ps.display_name_hebrew as status_display_hebrew,
       ps.display_name_english as status_display_english,
       p.created_at, p.updated_at
FROM publishers p
JOIN publisher_statuses ps ON ps.id = p.status_id
WHERE p.id = $1
`

type AdminGetPublisherRow struct {
	ID                   int32              `json:"id"`
	ClerkUserID          *string            `json:"clerk_user_id"`
	Name                 string             `json:"name"`
	ContactEmail         string             `json:"contact_email"`
	Description          *string            `json:"description"`
	Bio                  *string            `json:"bio"`
	Website              *string            `json:"website"`
	LogoUrl              *string            `json:"logo_url"`
	StatusID             int16              `json:"status_id"`
	StatusKey            string             `json:"status_key"`
	StatusDisplayHebrew  string             `json:"status_display_hebrew"`
	StatusDisplayEnglish string             `json:"status_display_english"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) AdminGetPublisher(ctx context.Context, id int32) (AdminGetPublisherRow, error) {
	row := q.db.QueryRow(ctx, adminGetPublisher, id)
	var i AdminGetPublisherRow
	err := row.Scan(
		&i.ID,
		&i.ClerkUserID,
		&i.Name,
		&i.ContactEmail,
		&i.Description,
		&i.Bio,
		&i.Website,
		&i.LogoUrl,
		&i.StatusID,
		&i.StatusKey,
		&i.StatusDisplayHebrew,
		&i.StatusDisplayEnglish,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const adminGetPublisherStats = `-- name: AdminGetPublisherStats :one

SELECT
    COUNT(*) FILTER (WHERE ps.key IN ('active', 'pending', 'suspended')) as total,
    COUNT(*) FILTER (WHERE ps.key = 'active') as active,
    COUNT(*) FILTER (WHERE ps.key IN ('pending')) as pending,
    COUNT(*) FILTER (WHERE ps.key = 'suspended') as suspended
FROM publishers p
JOIN publisher_statuses ps ON ps.id = p.status_id
`

type AdminGetPublisherStatsRow struct {
	Total     int64 `json:"total"`
	Active    int64 `json:"active"`
	Pending   int64 `json:"pending"`
	Suspended int64 `json:"suspended"`
}

// Admin Statistics (legacy query for backward compatibility) --
func (q *Queries) AdminGetPublisherStats(ctx context.Context) (AdminGetPublisherStatsRow, error) {
	row := q.db.QueryRow(ctx, adminGetPublisherStats)
	var i AdminGetPublisherStatsRow
	err := row.Scan(
		&i.Total,
		&i.Active,
		&i.Pending,
		&i.Suspended,
	)
	return i, err
}

const adminGetStatistics = `-- name: AdminGetStatistics :one

SELECT
    (SELECT COUNT(*) FROM publishers) as total_publishers,
    (SELECT COUNT(*) FROM publishers p
     JOIN publisher_statuses ps ON ps.id = p.status_id
     WHERE ps.key = 'active') as active_publishers,
    (SELECT COUNT(*) FROM publishers p
     JOIN publisher_statuses ps ON ps.id = p.status_id
     WHERE ps.key = 'pending') as pending_publishers,
    (SELECT COUNT(*) FROM algorithms a
     JOIN algorithm_statuses astatus ON astatus.id = a.status_id
     WHERE astatus.key = 'active') as published_algorithms,
    (SELECT COUNT(*) FROM geo_localities) as total_localities,
    (SELECT COUNT(*) FROM publisher_coverage WHERE is_active = true) as active_coverage_areas
`

type AdminGetStatisticsRow struct {
	TotalPublishers     int64 `json:"total_publishers"`
	ActivePublishers    int64 `json:"active_publishers"`
	PendingPublishers   int64 `json:"pending_publishers"`
	PublishedAlgorithms int64 `json:"published_algorithms"`
	TotalLocalities     int64 `json:"total_localities"`
	ActiveCoverageAreas int64 `json:"active_coverage_areas"`
}

// Admin Statistics --
func (q *Queries) AdminGetStatistics(ctx context.Context) (AdminGetStatisticsRow, error) {
	row := q.db.QueryRow(ctx, adminGetStatistics)
	var i AdminGetStatisticsRow
	err := row.Scan(
		&i.TotalPublishers,
		&i.ActivePublishers,
		&i.PendingPublishers,
		&i.PublishedAlgorithms,
		&i.TotalLocalities,
		&i.ActiveCoverageAreas,
	)
	return i, err
}

const adminHardDeletePublisher = `-- name: AdminHardDeletePublisher :one
SELECT hard_delete_publisher($1) as deletion_summary
`

func (q *Queries) AdminHardDeletePublisher(ctx context.Context, pPublisherID int32) ([]byte, error) {
	row := q.db.QueryRow(ctx, adminHardDeletePublisher, pPublisherID)
	var deletion_summary []byte
	err := row.Scan(&deletion_summary)
	return deletion_summary, err
}

const adminListAlgorithms = `-- name: AdminListAlgorithms :many

SELECT
    a.id, a.publisher_id, a.name, a.status_id,
    astatus.key as status_key,
    astatus.display_name_hebrew as status_display_hebrew,
    astatus.display_name_english as status_display_english,
    a.is_public,
    a.created_at, a.updated_at,
    p.name as publisher_name
FROM algorithms a
JOIN algorithm_statuses astatus ON astatus.id = a.status_id
JOIN publishers p ON a.publisher_id = p.id
WHERE ($1::text IS NULL OR astatus.key = $1)
ORDER BY a.updated_at DESC
LIMIT $2 OFFSET $3
`

type AdminListAlgorithmsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type AdminListAlgorithmsRow struct {
	ID                   int32              `json:"id"`
	PublisherID          int32              `json:"publisher_id"`
	Name                 string             `json:"name"`
	StatusID             *int16             `json:"status_id"`
	StatusKey            string             `json:"status_key"`
	StatusDisplayHebrew  string             `json:"status_display_hebrew"`
	StatusDisplayEnglish string             `json:"status_display_english"`
	IsPublic             *bool              `json:"is_public"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	PublisherName        string             `json:"publisher_name"`
}

// Admin Algorithm Management --
func (q *Queries) AdminListAlgorithms(ctx context.Context, arg AdminListAlgorithmsParams) ([]AdminListAlgorithmsRow, error) {
	rows, err := q.db.Query(ctx, adminListAlgorithms, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminListAlgorithmsRow{}
	for rows.Next() {
		var i AdminListAlgorithmsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublisherID,
			&i.Name,
			&i.StatusID,
			&i.StatusKey,
			&i.StatusDisplayHebrew,
			&i.StatusDisplayEnglish,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublisherName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListAllPublishers = `-- name: AdminListAllPublishers :many

SELECT p.id, p.clerk_user_id, p.name, p.contact_email, p.website,
       p.logo_url, p.description, p.status_id,
       ps.key as status_key,
       ps.display_name_hebrew as status_display_hebrew,
       ps.display_name_english as status_display_english,
       p.is_certified, p.suspension_reason,
       p.deleted_at, p.deleted_by, p.created_at, p.updated_at
FROM publishers p
JOIN publisher_statuses ps ON ps.id = p.status_id
WHERE ($1::boolean = true OR p.deleted_at IS NULL)
ORDER BY
    CASE WHEN $1::boolean = true THEN p.deleted_at END DESC NULLS FIRST,
    p.created_at DESC
`

type AdminListAllPublishersRow struct {
	ID                   int32              `json:"id"`
	ClerkUserID          *string            `json:"clerk_user_id"`
	Name                 string             `json:"name"`
	ContactEmail         string             `json:"contact_email"`
	Website              *string            `json:"website"`
	LogoUrl              *string            `json:"logo_url"`
	Description          *string            `json:"description"`
	StatusID             int16              `json:"status_id"`
	StatusKey            string             `json:"status_key"`
	StatusDisplayHebrew  string             `json:"status_display_hebrew"`
	StatusDisplayEnglish string             `json:"status_display_english"`
	IsCertified          bool               `json:"is_certified"`
	SuspensionReason     *string            `json:"suspension_reason"`
	DeletedAt            pgtype.Timestamptz `json:"deleted_at"`
	DeletedBy            *string            `json:"deleted_by"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

// Extended Admin Publisher Listing (with all fields, including soft-deleted) --
func (q *Queries) AdminListAllPublishers(ctx context.Context, dollar_1 bool) ([]AdminListAllPublishersRow, error) {
	rows, err := q.db.Query(ctx, adminListAllPublishers, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminListAllPublishersRow{}
	for rows.Next() {
		var i AdminListAllPublishersRow
		if err := rows.Scan(
			&i.ID,
			&i.ClerkUserID,
			&i.Name,
			&i.ContactEmail,
			&i.Website,
			&i.LogoUrl,
			&i.Description,
			&i.StatusID,
			&i.StatusKey,
			&i.StatusDisplayHebrew,
			&i.StatusDisplayEnglish,
			&i.IsCertified,
			&i.SuspensionReason,
			&i.DeletedAt,
			&i.DeletedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListPublishers = `-- name: AdminListPublishers :many


SELECT p.id, p.clerk_user_id, p.name, p.contact_email, p.status_id,
       ps.key as status_key,
       ps.display_name_hebrew as status_display_hebrew,
       ps.display_name_english as status_display_english,
       p.created_at, p.updated_at
FROM publishers p
JOIN publisher_statuses ps ON ps.id = p.status_id
WHERE ($1::text IS NULL OR ps.key = $1)
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type AdminListPublishersParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type AdminListPublishersRow struct {
	ID                   int32              `json:"id"`
	ClerkUserID          *string            `json:"clerk_user_id"`
	Name                 string             `json:"name"`
	ContactEmail         string             `json:"contact_email"`
	StatusID             int16              `json:"status_id"`
	StatusKey            string             `json:"status_key"`
	StatusDisplayHebrew  string             `json:"status_display_hebrew"`
	StatusDisplayEnglish string             `json:"status_display_english"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

// Admin SQL Queries
// SQLc will generate type-safe Go code from these queries
// Admin Publisher Management --
func (q *Queries) AdminListPublishers(ctx context.Context, arg AdminListPublishersParams) ([]AdminListPublishersRow, error) {
	rows, err := q.db.Query(ctx, adminListPublishers, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminListPublishersRow{}
	for rows.Next() {
		var i AdminListPublishersRow
		if err := rows.Scan(
			&i.ID,
			&i.ClerkUserID,
			&i.Name,
			&i.ContactEmail,
			&i.StatusID,
			&i.StatusKey,
			&i.StatusDisplayHebrew,
			&i.StatusDisplayEnglish,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminPermanentDeletePublisher = `-- name: AdminPermanentDeletePublisher :exec

DELETE FROM publishers WHERE id = $1
`

// Permanent Delete --
func (q *Queries) AdminPermanentDeletePublisher(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, adminPermanentDeletePublisher, id)
	return err
}

const adminReactivatePublisher = `-- name: AdminReactivatePublisher :one
UPDATE publishers
SET status_id = (SELECT ps.id FROM publisher_statuses ps WHERE ps.key = 'active'),
    suspension_reason = NULL,
    updated_at = NOW()
WHERE publishers.id = $1
RETURNING publishers.id, publishers.name, publishers.contact_email, publishers.status_id, publishers.created_at, publishers.updated_at
`

type AdminReactivatePublisherRow struct {
	ID           int32              `json:"id"`
	Name         string             `json:"name"`
	ContactEmail string             `json:"contact_email"`
	StatusID     int16              `json:"status_id"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) AdminReactivatePublisher(ctx context.Context, id int32) (AdminReactivatePublisherRow, error) {
	row := q.db.QueryRow(ctx, adminReactivatePublisher, id)
	var i AdminReactivatePublisherRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ContactEmail,
		&i.StatusID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const adminRestorePublisher = `-- name: AdminRestorePublisher :one
UPDATE publishers
SET deleted_at = NULL, deleted_by = NULL, updated_at = NOW()
WHERE id = $1 AND deleted_at IS NOT NULL
RETURNING id, name, status_id, updated_at
`

type AdminRestorePublisherRow struct {
	ID        int32              `json:"id"`
	Name      string             `json:"name"`
	StatusID  int16              `json:"status_id"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) AdminRestorePublisher(ctx context.Context, id int32) (AdminRestorePublisherRow, error) {
	row := q.db.QueryRow(ctx, adminRestorePublisher, id)
	var i AdminRestorePublisherRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StatusID,
		&i.UpdatedAt,
	)
	return i, err
}

const adminSetPublisherCertified = `-- name: AdminSetPublisherCertified :one
UPDATE publishers
SET is_certified = $1, updated_at = NOW()
WHERE id = $2
RETURNING id, name, is_certified, updated_at
`

type AdminSetPublisherCertifiedParams struct {
	IsCertified bool  `json:"is_certified"`
	ID          int32 `json:"id"`
}

type AdminSetPublisherCertifiedRow struct {
	ID          int32              `json:"id"`
	Name        string             `json:"name"`
	IsCertified bool               `json:"is_certified"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) AdminSetPublisherCertified(ctx context.Context, arg AdminSetPublisherCertifiedParams) (AdminSetPublisherCertifiedRow, error) {
	row := q.db.QueryRow(ctx, adminSetPublisherCertified, arg.IsCertified, arg.ID)
	var i AdminSetPublisherCertifiedRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsCertified,
		&i.UpdatedAt,
	)
	return i, err
}

const adminSoftDeletePublisher = `-- name: AdminSoftDeletePublisher :one

UPDATE publishers
SET deleted_at = NOW(), deleted_by = $1, updated_at = NOW()
WHERE id = $2 AND deleted_at IS NULL
RETURNING deleted_at
`

type AdminSoftDeletePublisherParams struct {
	DeletedBy *string `json:"deleted_by"`
	ID        int32   `json:"id"`
}

// Soft Delete and Restore --
func (q *Queries) AdminSoftDeletePublisher(ctx context.Context, arg AdminSoftDeletePublisherParams) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, adminSoftDeletePublisher, arg.DeletedBy, arg.ID)
	var deleted_at pgtype.Timestamptz
	err := row.Scan(&deleted_at)
	return deleted_at, err
}

const adminSuspendPublisher = `-- name: AdminSuspendPublisher :one

UPDATE publishers
SET status_id = (SELECT ps.id FROM publisher_statuses ps WHERE ps.key = 'suspended'),
    suspension_reason = $1,
    updated_at = NOW()
WHERE publishers.id = $2
RETURNING publishers.id, publishers.name, publishers.contact_email, publishers.status_id, publishers.suspension_reason, publishers.created_at, publishers.updated_at
`

type AdminSuspendPublisherParams struct {
	SuspensionReason *string `json:"suspension_reason"`
	ID               int32   `json:"id"`
}

type AdminSuspendPublisherRow struct {
	ID               int32              `json:"id"`
	Name             string             `json:"name"`
	ContactEmail     string             `json:"contact_email"`
	StatusID         int16              `json:"status_id"`
	SuspensionReason *string            `json:"suspension_reason"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

// Publisher Updates --
func (q *Queries) AdminSuspendPublisher(ctx context.Context, arg AdminSuspendPublisherParams) (AdminSuspendPublisherRow, error) {
	row := q.db.QueryRow(ctx, adminSuspendPublisher, arg.SuspensionReason, arg.ID)
	var i AdminSuspendPublisherRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ContactEmail,
		&i.StatusID,
		&i.SuspensionReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const adminUpdatePublisherFields = `-- name: AdminUpdatePublisherFields :one
UPDATE publishers
SET name = COALESCE($1, name),
    slug = CASE WHEN $1 IS NOT NULL THEN $2 ELSE slug END,
    contact_email = COALESCE($3, contact_email),
    website = COALESCE($4, website),
    description = COALESCE($5, description),
    updated_at = NOW()
WHERE id = $6
RETURNING id, name, slug, contact_email, website, description, status_id, created_at, updated_at
`

type AdminUpdatePublisherFieldsParams struct {
	Name        *string `json:"name"`
	Slug        *string `json:"slug"`
	Email       *string `json:"email"`
	Website     *string `json:"website"`
	Description *string `json:"description"`
	ID          int32   `json:"id"`
}

type AdminUpdatePublisherFieldsRow struct {
	ID           int32              `json:"id"`
	Name         string             `json:"name"`
	Slug         *string            `json:"slug"`
	ContactEmail string             `json:"contact_email"`
	Website      *string            `json:"website"`
	Description  *string            `json:"description"`
	StatusID     int16              `json:"status_id"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) AdminUpdatePublisherFields(ctx context.Context, arg AdminUpdatePublisherFieldsParams) (AdminUpdatePublisherFieldsRow, error) {
	row := q.db.QueryRow(ctx, adminUpdatePublisherFields,
		arg.Name,
		arg.Slug,
		arg.Email,
		arg.Website,
		arg.Description,
		arg.ID,
	)
	var i AdminUpdatePublisherFieldsRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.ContactEmail,
		&i.Website,
		&i.Description,
		&i.StatusID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const adminUpdatePublisherStatus = `-- name: AdminUpdatePublisherStatus :one
WITH updated AS (
    UPDATE publishers
    SET status_id = $2, updated_at = NOW()
    WHERE publishers.id = $1
    RETURNING id, status_id
)
SELECT u.id, u.status_id,
       ps.key as status_key,
       ps.display_name_hebrew as status_display_hebrew,
       ps.display_name_english as status_display_english
FROM updated u
JOIN publisher_statuses ps ON ps.id = u.status_id
`

type AdminUpdatePublisherStatusParams struct {
	ID       int32 `json:"id"`
	StatusID int16 `json:"status_id"`
}

type AdminUpdatePublisherStatusRow struct {
	ID                   int32  `json:"id"`
	StatusID             int16  `json:"status_id"`
	StatusKey            string `json:"status_key"`
	StatusDisplayHebrew  string `json:"status_display_hebrew"`
	StatusDisplayEnglish string `json:"status_display_english"`
}

func (q *Queries) AdminUpdatePublisherStatus(ctx context.Context, arg AdminUpdatePublisherStatusParams) (AdminUpdatePublisherStatusRow, error) {
	row := q.db.QueryRow(ctx, adminUpdatePublisherStatus, arg.ID, arg.StatusID)
	var i AdminUpdatePublisherStatusRow
	err := row.Scan(
		&i.ID,
		&i.StatusID,
		&i.StatusKey,
		&i.StatusDisplayHebrew,
		&i.StatusDisplayEnglish,
	)
	return i, err
}

const checkPublisherExists = `-- name: CheckPublisherExists :one

SELECT EXISTS(SELECT 1 FROM publishers WHERE id = $1)
`

// Publisher Existence and Basic Info --
func (q *Queries) CheckPublisherExists(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRow(ctx, checkPublisherExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkSystemConfigTableExists = `-- name: CheckSystemConfigTableExists :one

SELECT EXISTS (
    SELECT FROM information_schema.tables
    WHERE table_schema = 'public' AND table_name = 'system_config'
)
`

// System Config Management --
// NOTE: system_config table not yet created - queries commented out
func (q *Queries) CheckSystemConfigTableExists(ctx context.Context) (bool, error) {
	row := q.db.QueryRow(ctx, checkSystemConfigTableExists)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countPendingInvitationsForEmail = `-- name: CountPendingInvitationsForEmail :one
SELECT COUNT(*)
FROM publisher_invitations
WHERE publisher_id = $1 AND LOWER(email) = LOWER($2) AND expires_at > NOW()
`

type CountPendingInvitationsForEmailParams struct {
	PublisherID int32  `json:"publisher_id"`
	Lower       string `json:"lower"`
}

func (q *Queries) CountPendingInvitationsForEmail(ctx context.Context, arg CountPendingInvitationsForEmailParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPendingInvitationsForEmail, arg.PublisherID, arg.Lower)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInvitation = `-- name: CreateInvitation :one
INSERT INTO publisher_invitations (publisher_id, email, role_id, token, expires_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id
`

type CreateInvitationParams struct {
	PublisherID int32              `json:"publisher_id"`
	Email       string             `json:"email"`
	RoleID      int16              `json:"role_id"`
	Token       string             `json:"token"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreateInvitation(ctx context.Context, arg CreateInvitationParams) (int32, error) {
	row := q.db.QueryRow(ctx, createInvitation,
		arg.PublisherID,
		arg.Email,
		arg.RoleID,
		arg.Token,
		arg.ExpiresAt,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteExpiredInvitations = `-- name: DeleteExpiredInvitations :exec
DELETE FROM publisher_invitations
WHERE publisher_id = $1 AND expires_at <= NOW()
`

func (q *Queries) DeleteExpiredInvitations(ctx context.Context, publisherID int32) error {
	_, err := q.db.Exec(ctx, deleteExpiredInvitations, publisherID)
	return err
}

const deleteInvitation = `-- name: DeleteInvitation :exec
DELETE FROM publisher_invitations
WHERE id = $1
`

func (q *Queries) DeleteInvitation(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteInvitation, id)
	return err
}

const getAllPublishersBasicInfo = `-- name: GetAllPublishersBasicInfo :many
SELECT id, name FROM publishers ORDER BY name
`

type GetAllPublishersBasicInfoRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) GetAllPublishersBasicInfo(ctx context.Context) ([]GetAllPublishersBasicInfoRow, error) {
	rows, err := q.db.Query(ctx, getAllPublishersBasicInfo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllPublishersBasicInfoRow{}
	for rows.Next() {
		var i GetAllPublishersBasicInfoRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpiredInvitations = `-- name: GetExpiredInvitations :many
SELECT pi.id, pi.email, pi.role_id,
       pr.key as role_key,
       pr.display_name_hebrew as role_display_hebrew,
       pr.display_name_english as role_display_english,
       pi.expires_at, pi.created_at
FROM publisher_invitations pi
JOIN publisher_roles pr ON pr.id = pi.role_id
WHERE pi.publisher_id = $1 AND pi.expires_at <= NOW()
ORDER BY pi.created_at DESC
`

type GetExpiredInvitationsRow struct {
	ID                 int32              `json:"id"`
	Email              string             `json:"email"`
	RoleID             int16              `json:"role_id"`
	RoleKey            string             `json:"role_key"`
	RoleDisplayHebrew  string             `json:"role_display_hebrew"`
	RoleDisplayEnglish string             `json:"role_display_english"`
	ExpiresAt          pgtype.Timestamptz `json:"expires_at"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetExpiredInvitations(ctx context.Context, publisherID int32) ([]GetExpiredInvitationsRow, error) {
	rows, err := q.db.Query(ctx, getExpiredInvitations, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetExpiredInvitationsRow{}
	for rows.Next() {
		var i GetExpiredInvitationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.RoleID,
			&i.RoleKey,
			&i.RoleDisplayHebrew,
			&i.RoleDisplayEnglish,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvitationByToken = `-- name: GetInvitationByToken :one
SELECT pi.id, pi.publisher_id, pi.email, pi.role_id,
       pr.key as role_key,
       pr.display_name_hebrew as role_display_hebrew,
       pr.display_name_english as role_display_english,
       pi.expires_at, p.name as publisher_name
FROM publisher_invitations pi
JOIN publisher_roles pr ON pr.id = pi.role_id
JOIN publishers p ON pi.publisher_id = p.id
WHERE pi.token = $1 AND pi.expires_at > NOW()
`

type GetInvitationByTokenRow struct {
	ID                 int32              `json:"id"`
	PublisherID        int32              `json:"publisher_id"`
	Email              string             `json:"email"`
	RoleID             int16              `json:"role_id"`
	RoleKey            string             `json:"role_key"`
	RoleDisplayHebrew  string             `json:"role_display_hebrew"`
	RoleDisplayEnglish string             `json:"role_display_english"`
	ExpiresAt          pgtype.Timestamptz `json:"expires_at"`
	PublisherName      string             `json:"publisher_name"`
}

func (q *Queries) GetInvitationByToken(ctx context.Context, token string) (GetInvitationByTokenRow, error) {
	row := q.db.QueryRow(ctx, getInvitationByToken, token)
	var i GetInvitationByTokenRow
	err := row.Scan(
		&i.ID,
		&i.PublisherID,
		&i.Email,
		&i.RoleID,
		&i.RoleKey,
		&i.RoleDisplayHebrew,
		&i.RoleDisplayEnglish,
		&i.ExpiresAt,
		&i.PublisherName,
	)
	return i, err
}

const getPendingInvitations = `-- name: GetPendingInvitations :many

SELECT pi.id, pi.email, pi.role_id,
       pr.key as role_key,
       pr.display_name_hebrew as role_display_hebrew,
       pr.display_name_english as role_display_english,
       pi.expires_at, pi.created_at
FROM publisher_invitations pi
JOIN publisher_roles pr ON pr.id = pi.role_id
WHERE pi.publisher_id = $1 AND pi.expires_at > NOW()
ORDER BY pi.created_at DESC
`

type GetPendingInvitationsRow struct {
	ID                 int32              `json:"id"`
	Email              string             `json:"email"`
	RoleID             int16              `json:"role_id"`
	RoleKey            string             `json:"role_key"`
	RoleDisplayHebrew  string             `json:"role_display_hebrew"`
	RoleDisplayEnglish string             `json:"role_display_english"`
	ExpiresAt          pgtype.Timestamptz `json:"expires_at"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
}

// Publisher Invitations --
// Schema: id, publisher_id, email, role_id, token, expires_at, created_at
func (q *Queries) GetPendingInvitations(ctx context.Context, publisherID int32) ([]GetPendingInvitationsRow, error) {
	rows, err := q.db.Query(ctx, getPendingInvitations, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingInvitationsRow{}
	for rows.Next() {
		var i GetPendingInvitationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.RoleID,
			&i.RoleKey,
			&i.RoleDisplayHebrew,
			&i.RoleDisplayEnglish,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublisherEmailAndName = `-- name: GetPublisherEmailAndName :one
SELECT contact_email, name FROM publishers WHERE id = $1
`

type GetPublisherEmailAndNameRow struct {
	ContactEmail string `json:"contact_email"`
	Name         string `json:"name"`
}

func (q *Queries) GetPublisherEmailAndName(ctx context.Context, id int32) (GetPublisherEmailAndNameRow, error) {
	row := q.db.QueryRow(ctx, getPublisherEmailAndName, id)
	var i GetPublisherEmailAndNameRow
	err := row.Scan(&i.ContactEmail, &i.Name)
	return i, err
}

const getPublisherNameAndDeletedAt = `-- name: GetPublisherNameAndDeletedAt :one
SELECT name, deleted_at FROM publishers WHERE id = $1
`

type GetPublisherNameAndDeletedAtRow struct {
	Name      string             `json:"name"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

func (q *Queries) GetPublisherNameAndDeletedAt(ctx context.Context, id int32) (GetPublisherNameAndDeletedAtRow, error) {
	row := q.db.QueryRow(ctx, getPublisherNameAndDeletedAt, id)
	var i GetPublisherNameAndDeletedAtRow
	err := row.Scan(&i.Name, &i.DeletedAt)
	return i, err
}

const getPublisherNameByID = `-- name: GetPublisherNameByID :one
SELECT name FROM publishers WHERE id = $1
`

func (q *Queries) GetPublisherNameByID(ctx context.Context, id int32) (string, error) {
	row := q.db.QueryRow(ctx, getPublisherNameByID, id)
	var name string
	err := row.Scan(&name)
	return name, err
}

const getPublisherOwner = `-- name: GetPublisherOwner :one

SELECT clerk_user_id FROM publishers WHERE id = $1
`

// Team Management --
func (q *Queries) GetPublisherOwner(ctx context.Context, id int32) (*string, error) {
	row := q.db.QueryRow(ctx, getPublisherOwner, id)
	var clerk_user_id *string
	err := row.Scan(&clerk_user_id)
	return clerk_user_id, err
}

const updateInvitationToken = `-- name: UpdateInvitationToken :exec
UPDATE publisher_invitations
SET token = $1, expires_at = $2
WHERE id = $3
`

type UpdateInvitationTokenParams struct {
	Token     string             `json:"token"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	ID        int32              `json:"id"`
}

func (q *Queries) UpdateInvitationToken(ctx context.Context, arg UpdateInvitationTokenParams) error {
	_, err := q.db.Exec(ctx, updateInvitationToken, arg.Token, arg.ExpiresAt, arg.ID)
	return err
}
