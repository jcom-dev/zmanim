// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlcgen

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type DisplayStatus string

const (
	DisplayStatusCore     DisplayStatus = "core"
	DisplayStatusOptional DisplayStatus = "optional"
	DisplayStatusHidden   DisplayStatus = "hidden"
)

func (e *DisplayStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DisplayStatus(s)
	case string:
		*e = DisplayStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for DisplayStatus: %T", src)
	}
	return nil
}

type NullDisplayStatus struct {
	DisplayStatus DisplayStatus `json:"display_status"`
	Valid         bool          `json:"valid"` // Valid is true if DisplayStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDisplayStatus) Scan(value interface{}) error {
	if value == nil {
		ns.DisplayStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DisplayStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDisplayStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DisplayStatus), nil
}

type HebcalMatchType string

const (
	HebcalMatchTypeExact HebcalMatchType = "exact"
	HebcalMatchTypeGroup HebcalMatchType = "group"
)

func (e *HebcalMatchType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = HebcalMatchType(s)
	case string:
		*e = HebcalMatchType(s)
	default:
		return fmt.Errorf("unsupported scan type for HebcalMatchType: %T", src)
	}
	return nil
}

type NullHebcalMatchType struct {
	HebcalMatchType HebcalMatchType `json:"hebcal_match_type"`
	Valid           bool            `json:"valid"` // Valid is true if HebcalMatchType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullHebcalMatchType) Scan(value interface{}) error {
	if value == nil {
		ns.HebcalMatchType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.HebcalMatchType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullHebcalMatchType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.HebcalMatchType), nil
}

type Action struct {
	ID             string             `json:"id"`
	ActionType     string             `json:"action_type"`
	Concept        string             `json:"concept"`
	UserID         *string            `json:"user_id"`
	PublisherID    *int32             `json:"publisher_id"`
	RequestID      string             `json:"request_id"`
	ParentActionID pgtype.UUID        `json:"parent_action_id"`
	EntityType     *string            `json:"entity_type"`
	EntityID       *string            `json:"entity_id"`
	Payload        []byte             `json:"payload"`
	Result         []byte             `json:"result"`
	Status         *string            `json:"status"`
	ErrorMessage   *string            `json:"error_message"`
	StartedAt      pgtype.Timestamptz `json:"started_at"`
	CompletedAt    pgtype.Timestamptz `json:"completed_at"`
	DurationMs     *int32             `json:"duration_ms"`
	Metadata       []byte             `json:"metadata"`
}

type AiAuditLog struct {
	ID             int32              `json:"id"`
	PublisherID    *int32             `json:"publisher_id"`
	UserID         *string            `json:"user_id"`
	RequestType    string             `json:"request_type"`
	InputText      *string            `json:"input_text"`
	OutputText     *string            `json:"output_text"`
	TokensUsed     *int32             `json:"tokens_used"`
	Model          *string            `json:"model"`
	Confidence     pgtype.Numeric     `json:"confidence"`
	Success        *bool              `json:"success"`
	ErrorMessage   *string            `json:"error_message"`
	DurationMs     *int32             `json:"duration_ms"`
	RagContextUsed *bool              `json:"rag_context_used"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
}

type AiContentSource struct {
	ID                 int16              `json:"id"`
	Key                string             `json:"key"`
	DisplayNameHebrew  string             `json:"display_name_hebrew"`
	DisplayNameEnglish string             `json:"display_name_english"`
	Description        *string            `json:"description"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
}

type Algorithm struct {
	ID                int32              `json:"id"`
	PublisherID       int32              `json:"publisher_id"`
	Name              string             `json:"name"`
	Description       *string            `json:"description"`
	Configuration     []byte             `json:"configuration"`
	StatusID          *int16             `json:"status_id"`
	IsPublic          *bool              `json:"is_public"`
	ForkedFrom        *int32             `json:"forked_from"`
	AttributionText   *string            `json:"attribution_text"`
	ForkCount         *int32             `json:"fork_count"`
	CreatedByActionID pgtype.UUID        `json:"created_by_action_id"`
	UpdatedByActionID pgtype.UUID        `json:"updated_by_action_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

type AlgorithmRollbackAudit struct {
	ID            int32              `json:"id"`
	AlgorithmID   int32              `json:"algorithm_id"`
	SourceVersion int32              `json:"source_version"`
	TargetVersion int32              `json:"target_version"`
	NewVersion    int32              `json:"new_version"`
	Reason        *string            `json:"reason"`
	RolledBackBy  *string            `json:"rolled_back_by"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
}

type AlgorithmStatus struct {
	ID                 int16              `json:"id"`
	Key                string             `json:"key"`
	DisplayNameHebrew  string             `json:"display_name_hebrew"`
	DisplayNameEnglish string             `json:"display_name_english"`
	Description        *string            `json:"description"`
	Color              *string            `json:"color"`
	SortOrder          int16              `json:"sort_order"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
}

type AlgorithmTemplate struct {
	ID            int32              `json:"id"`
	TemplateKey   string             `json:"template_key"`
	Name          string             `json:"name"`
	Description   *string            `json:"description"`
	Configuration []byte             `json:"configuration"`
	SortOrder     int32              `json:"sort_order"`
	IsActive      bool               `json:"is_active"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

type AlgorithmVersionHistory struct {
	ID             int32              `json:"id"`
	AlgorithmID    int32              `json:"algorithm_id"`
	VersionNumber  int32              `json:"version_number"`
	Status         string             `json:"status"`
	Description    *string            `json:"description"`
	ConfigSnapshot []byte             `json:"config_snapshot"`
	CreatedBy      *string            `json:"created_by"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	PublishedAt    pgtype.Timestamptz `json:"published_at"`
}

type AstronomicalPrimitive struct {
	ID           int32              `json:"id"`
	VariableName string             `json:"variable_name"`
	DisplayName  string             `json:"display_name"`
	Description  *string            `json:"description"`
	FormulaDsl   string             `json:"formula_dsl"`
	CategoryID   int16              `json:"category_id"`
	SortOrder    *int32             `json:"sort_order"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

// Permanently blocked email addresses. Submissions silently ignored.
type BlockedEmail struct {
	ID    int32  `json:"id"`
	Email string `json:"email"`
	// Admin clerk_user_id who blocked the email
	BlockedBy string             `json:"blocked_by"`
	BlockedAt pgtype.Timestamptz `json:"blocked_at"`
	// Optional note explaining why email was blocked
	Reason *string `json:"reason"`
}

// Records all zmanim calculation requests for analytics. Optimized for high-volume inserts using batch COPY protocol.
type CalculationLog struct {
	ID             int64       `json:"id"`
	PublisherID    int32       `json:"publisher_id"`
	LocalityID     int64       `json:"locality_id"`
	DateCalculated pgtype.Date `json:"date_calculated"`
	// Whether result was served from Redis cache
	CacheHit bool `json:"cache_hit"`
	// Total calculation time in milliseconds (includes cache lookup)
	ResponseTimeMs *int16 `json:"response_time_ms"`
	ZmanCount      *int16 `json:"zman_count"`
	// Request source: 1=web UI, 2=authenticated API, 3=external API (M2M)
	Source    int16              `json:"source"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

// Pre-aggregated daily statistics for fast dashboard queries. Updated by daily rollup job.
type CalculationStatsDaily struct {
	PublisherID       int32       `json:"publisher_id"`
	Date              pgtype.Date `json:"date"`
	TotalCalculations int32       `json:"total_calculations"`
	CacheHits         int32       `json:"cache_hits"`
	// Sum of all response times for average calculation
	TotalResponseTimeMs int64 `json:"total_response_time_ms"`
	SourceWeb           int32 `json:"source_web"`
	SourceApi           int32 `json:"source_api"`
	SourceExternal      int32 `json:"source_external"`
}

// Audit trail for all correction request actions (approve, reject, revert)
type CorrectionRequestHistory struct {
	ID                  int32              `json:"id"`
	CorrectionRequestID int32              `json:"correction_request_id"`
	LocalityID          int32              `json:"locality_id"`
	Action              string             `json:"action"`
	PerformedBy         string             `json:"performed_by"`
	PerformedAt         pgtype.Timestamptz `json:"performed_at"`
	PreviousLatitude    *float64           `json:"previous_latitude"`
	PreviousLongitude   *float64           `json:"previous_longitude"`
	PreviousElevation   *int32             `json:"previous_elevation"`
	NewLatitude         *float64           `json:"new_latitude"`
	NewLongitude        *float64           `json:"new_longitude"`
	NewElevation        *int32             `json:"new_elevation"`
	Notes               *string            `json:"notes"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
}

type CoverageLevel struct {
	ID                 int16              `json:"id"`
	Key                string             `json:"key"`
	DisplayNameHebrew  string             `json:"display_name_hebrew"`
	DisplayNameEnglish string             `json:"display_name_english"`
	Description        *string            `json:"description"`
	SortOrder          int16              `json:"sort_order"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
}

type DisplayGroup struct {
	ID                 int32              `json:"id"`
	Key                string             `json:"key"`
	DisplayNameHebrew  string             `json:"display_name_hebrew"`
	DisplayNameEnglish string             `json:"display_name_english"`
	Description        *string            `json:"description"`
	IconName           *string            `json:"icon_name"`
	Color              *string            `json:"color"`
	SortOrder          int32              `json:"sort_order"`
	TimeCategories     []string           `json:"time_categories"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
}

type Embedding struct {
	ID          int32              `json:"id"`
	SourceID    int16              `json:"source_id"`
	ContentType string             `json:"content_type"`
	ChunkIndex  int32              `json:"chunk_index"`
	Content     string             `json:"content"`
	Metadata    []byte             `json:"metadata"`
	Embedding   interface{}        `json:"embedding"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

type ExplanationCache struct {
	ID          int32              `json:"id"`
	FormulaHash string             `json:"formula_hash"`
	Language    string             `json:"language"`
	Explanation string             `json:"explanation"`
	SourceID    int16              `json:"source_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
}

type GeoContinent struct {
	ID   int16  `json:"id"`
	Code string `json:"code"`
	Name string `json:"name"`
	// External ID from the source system
	SourceRef *string `json:"source_ref"`
	// FK to geo_data_sources - identifies where this data came from
	SourceID *int32 `json:"source_id"`
}

type GeoCountry struct {
	ID          int16              `json:"id"`
	Code        string             `json:"code"`
	CodeIso3    *string            `json:"code_iso3"`
	Name        string             `json:"name"`
	ContinentID int16              `json:"continent_id"`
	Adm1Label   *string            `json:"adm1_label"`
	Adm2Label   *string            `json:"adm2_label"`
	HasAdm1     *bool              `json:"has_adm1"`
	HasAdm2     *bool              `json:"has_adm2"`
	IsCityState *bool              `json:"is_city_state"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	// External ID from the source system
	SourceRef *string `json:"source_ref"`
	// FK to geo_data_sources - identifies where this data came from
	SourceID              *int32 `json:"source_id"`
	HierarchyInconsistent *bool  `json:"hierarchy_inconsistent"`
	// Polygon boundary from Overture division_area.parquet (optional)
	Boundary   interface{} `json:"boundary"`
	OvertureID *string     `json:"overture_id"`
}

type GeoDataSource struct {
	ID               int32              `json:"id"`
	Key              string             `json:"key"`
	Name             string             `json:"name"`
	Description      *string            `json:"description"`
	DataTypeID       int16              `json:"data_type_id"`
	Priority         int16              `json:"priority"`
	DefaultAccuracyM *int32             `json:"default_accuracy_m"`
	Attribution      *string            `json:"attribution"`
	Url              *string            `json:"url"`
	IsActive         *bool              `json:"is_active"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

// Localities (cities, towns, villages, neighborhoods) from Overture Maps. Point geometry only with flexible hierarchy support.
type GeoLocality struct {
	ID               int32              `json:"id"`
	ParentOvertureID *string            `json:"parent_overture_id"`
	LocalityTypeID   *int16             `json:"locality_type_id"`
	Name             string             `json:"name"`
	NameAscii        *string            `json:"name_ascii"`
	Timezone         string             `json:"timezone"`
	Population       *int32             `json:"population"`
	ContinentID      *int16             `json:"continent_id"`
	CountryID        *int16             `json:"country_id"`
	SourceID         *int32             `json:"source_id"`
	OvertureID       *string            `json:"overture_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	// Polygon boundary from Overture division_area.parquet (optional)
	Boundary interface{} `json:"boundary"`
}

// Locality elevation data with hierarchical override support. Resolution: publisher > admin > default (glo90)
type GeoLocalityElevation struct {
	ID         int32 `json:"id"`
	LocalityID int32 `json:"locality_id"`
	// NULL for system-wide records (admin override or default source)
	PublisherID *int32             `json:"publisher_id"`
	SourceID    int32              `json:"source_id"`
	ElevationM  int32              `json:"elevation_m"`
	AccuracyM   *int32             `json:"accuracy_m"`
	Reason      *string            `json:"reason"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	// Clerk user ID who created the record
	CreatedBy *string `json:"created_by"`
}

// Locality coordinates with hierarchical override support. Resolution: publisher > admin > default (overture)
type GeoLocalityLocation struct {
	ID         int32 `json:"id"`
	LocalityID int32 `json:"locality_id"`
	// NULL for system-wide records (admin override or default source)
	PublisherID *int32             `json:"publisher_id"`
	SourceID    int32              `json:"source_id"`
	Latitude    float64            `json:"latitude"`
	Longitude   float64            `json:"longitude"`
	Location    interface{}        `json:"location"`
	AccuracyM   *int32             `json:"accuracy_m"`
	Reason      *string            `json:"reason"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	// Clerk user ID who created the record
	CreatedBy *string `json:"created_by"`
}

// Best system-wide coordinates for each locality (admin > default). For publisher-specific resolution use get_effective_locality_location() function.
type GeoLocalityResolvedCoord struct {
	LocalityID          int32       `json:"locality_id"`
	Name                string      `json:"name"`
	Timezone            string      `json:"timezone"`
	Latitude            *float64    `json:"latitude"`
	Longitude           *float64    `json:"longitude"`
	Location            interface{} `json:"location"`
	CoordinateSourceID  *int32      `json:"coordinate_source_id"`
	CoordinateSourceKey *string     `json:"coordinate_source_key"`
	ElevationM          *int32      `json:"elevation_m"`
	ElevationSourceID   *int32      `json:"elevation_source_id"`
	ElevationSourceKey  *string     `json:"elevation_source_key"`
}

// Lookup table for locality types from Overture divisions (city, town, village, etc.)
type GeoLocalityType struct {
	ID              int16              `json:"id"`
	Code            string             `json:"code"`
	Name            string             `json:"name"`
	OvertureSubtype *string            `json:"overture_subtype"`
	SortOrder       *int16             `json:"sort_order"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

type GeoName struct {
	ID           int32              `json:"id"`
	EntityID     int32              `json:"entity_id"`
	LanguageCode string             `json:"language_code"`
	Name         string             `json:"name"`
	IsPreferred  *bool              `json:"is_preferred"`
	SourceID     *int32             `json:"source_id"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	EntityType   *string            `json:"entity_type"`
	NameType     *string            `json:"name_type"`
}

type GeoRegion struct {
	ID          int32              `json:"id"`
	CountryID   *int16             `json:"country_id"`
	Code        string             `json:"code"`
	Name        string             `json:"name"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	ContinentID *int16             `json:"continent_id"`
	// External ID from the source system
	SourceRef *string `json:"source_ref"`
	// FK to geo_data_sources - identifies where this data came from
	SourceID *int32 `json:"source_id"`
	// True when boundary-based hierarchy cannot be reliably determined (no boundary, disputed territory, no containing country)
	HierarchyInconsistent *bool   `json:"hierarchy_inconsistent"`
	ParentRegionID        *int32  `json:"parent_region_id"`
	RegionTypeID          *int16  `json:"region_type_id"`
	Population            *int64  `json:"population"`
	OvertureID            *string `json:"overture_id"`
	// Polygon boundary from Overture division_area.parquet (optional)
	Boundary interface{} `json:"boundary"`
}

// Lookup table for region types from Overture divisions (region, county, localadmin, etc.)
type GeoRegionType struct {
	ID              int16              `json:"id"`
	Code            string             `json:"code"`
	Name            string             `json:"name"`
	OvertureSubtype *string            `json:"overture_subtype"`
	SortOrder       *int16             `json:"sort_order"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

// Denormalized search index with keywords from all languages for fast multi-entity geographic search
type GeoSearchIndex struct {
	EntityType        string   `json:"entity_type"`
	EntityID          int32    `json:"entity_id"`
	EntitySubtype     *string  `json:"entity_subtype"`
	LocalityID        *int32   `json:"locality_id"`
	Keywords          []string `json:"keywords"`
	DisplayName       string   `json:"display_name"`
	DisplayHierarchy  string   `json:"display_hierarchy"`
	DisplayNames      []byte   `json:"display_names"`
	LocalityTypeID    *int16   `json:"locality_type_id"`
	DirectParentType  *string  `json:"direct_parent_type"`
	DirectParentID    *int32   `json:"direct_parent_id"`
	InheritedRegionID *int32   `json:"inherited_region_id"`
	HierarchyPath     []byte   `json:"hierarchy_path"`
	CountryID         *int16   `json:"country_id"`
	ContinentID       *int16   `json:"continent_id"`
	CountryCode       *string  `json:"country_code"`
	Population        *int64   `json:"population"`
	Latitude          *float64 `json:"latitude"`
	Longitude         *float64 `json:"longitude"`
	Timezone          *string  `json:"timezone"`
	DescendantCount   *int32   `json:"descendant_count"`
	DirectChildCount  *int32   `json:"direct_child_count"`
	HasChildren       *bool    `json:"has_children"`
	AncestorRegionIds []int32  `json:"ancestor_region_ids"`
}

type GeoSearchIndexTest struct {
	EntityType        *string  `json:"entity_type"`
	EntityID          *int32   `json:"entity_id"`
	EntitySubtype     *string  `json:"entity_subtype"`
	LocalityID        *int32   `json:"locality_id"`
	Keywords          []string `json:"keywords"`
	DisplayName       *string  `json:"display_name"`
	DisplayHierarchy  *string  `json:"display_hierarchy"`
	DisplayNames      []byte   `json:"display_names"`
	LocalityTypeID    *int16   `json:"locality_type_id"`
	DirectParentType  *string  `json:"direct_parent_type"`
	DirectParentID    *int32   `json:"direct_parent_id"`
	InheritedRegionID *int32   `json:"inherited_region_id"`
	HierarchyPath     []byte   `json:"hierarchy_path"`
	CountryID         *int16   `json:"country_id"`
	ContinentID       *int16   `json:"continent_id"`
	CountryCode       *string  `json:"country_code"`
	Population        *int64   `json:"population"`
	Latitude          *float64 `json:"latitude"`
	Longitude         *float64 `json:"longitude"`
	Timezone          *string  `json:"timezone"`
	DescendantCount   *int32   `json:"descendant_count"`
	DirectChildCount  *int32   `json:"direct_child_count"`
	HasChildren       *bool    `json:"has_children"`
}

type Language struct {
	Code       string  `json:"code"`
	Name       string  `json:"name"`
	NativeName *string `json:"native_name"`
	Script     *string `json:"script"`
	Direction  *string `json:"direction"`
	IsActive   *bool   `json:"is_active"`
}

// Community-submitted corrections to global locality data
type LocationCorrectionRequest struct {
	ID int32 `json:"id"`
	// Publisher who submitted the request (nullable for anonymous)
	PublisherID *int32 `json:"publisher_id"`
	// Email of the person who submitted the request
	RequesterEmail    string   `json:"requester_email"`
	RequesterName     *string  `json:"requester_name"`
	ProposedLatitude  *float64 `json:"proposed_latitude"`
	ProposedLongitude *float64 `json:"proposed_longitude"`
	ProposedElevation *int32   `json:"proposed_elevation"`
	// Explanation of why the correction is needed
	CorrectionReason string `json:"correction_reason"`
	// Links to supporting evidence (surveys, official sources, etc.)
	EvidenceUrls []string `json:"evidence_urls"`
	Status       string   `json:"status"`
	// Clerk user ID of admin who reviewed the request
	ReviewedBy  *string            `json:"reviewed_by"`
	ReviewedAt  pgtype.Timestamptz `json:"reviewed_at"`
	ReviewNotes *string            `json:"review_notes"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	LocalityID  *int32             `json:"locality_id"`
	// Timestamp when correction was approved (for quick filtering)
	ApprovedAt pgtype.Timestamptz `json:"approved_at"`
	// Timestamp when correction was reverted
	RevertedAt pgtype.Timestamptz `json:"reverted_at"`
	// User ID who reverted the correction
	RevertedBy *string `json:"reverted_by"`
	// Reason for reverting the correction
	RevertReason *string `json:"revert_reason"`
}

type MasterZmanTag struct {
	MasterZmanID int32              `json:"master_zman_id"`
	TagID        int32              `json:"tag_id"`
	IsNegated    bool               `json:"is_negated"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

// Master registry of zmanim with full documentation. Last updated: 2025-12-22 with ALOS category backfill.
type MasterZmanimRegistry struct {
	ID                   int32   `json:"id"`
	ZmanKey              string  `json:"zman_key"`
	CanonicalHebrewName  string  `json:"canonical_hebrew_name"`
	CanonicalEnglishName string  `json:"canonical_english_name"`
	Transliteration      *string `json:"transliteration"`
	Description          *string `json:"description"`
	// Primary halachic sources and authorities for this calculation method. References to Shulchan Aruch, poskim, and KosherJava documentation.
	HalachicSource    *string            `json:"halachic_source"`
	HalachicNotes     *string            `json:"halachic_notes"`
	TimeCategoryID    *int32             `json:"time_category_id"`
	DefaultFormulaDsl *string            `json:"default_formula_dsl"`
	IsHidden          bool               `json:"is_hidden"`
	IsCore            *bool              `json:"is_core"`
	Aliases           []string           `json:"aliases"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	// Comprehensive description of this zman, including halachic context and usage. Derived from KosherJava library documentation.
	FullDescription *string `json:"full_description"`
	// Plain-language explanation of how the default_formula_dsl calculates this zman. Helps users understand the calculation methodology.
	FormulaExplanation *string `json:"formula_explanation"`
	// When and how to use this zman. Describes practical applications, which communities use it, and any caveats.
	UsageContext *string `json:"usage_context"`
	// Array of master_zmanim_registry IDs that are related to this zman (e.g., same zman with different calculation methods).
	RelatedZmanimIds []int32 `json:"related_zmanim_ids"`
	// Primary halachic opinion (shita) for this zman. Values: GRA, MGA, BAAL_HATANYA, RABBEINU_TAM, GEONIM, ATERET_TORAH, YEREIM, UNIVERSAL
	Shita *string `json:"shita"`
	// Time category for UI grouping. Values: ALOS, MISHEYAKIR, SHEMA, TEFILLA, CHATZOS, MINCHA, PLAG, SHKIA, BEIN_HASHMASHOS, TZAIS, CANDLE_LIGHTING, SPECIAL, OTHER
	Category *string `json:"category"`
}

type PasswordResetToken struct {
	ID        int32              `json:"id"`
	Email     string             `json:"email"`
	Token     string             `json:"token"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type PrimitiveCategory struct {
	ID                 int16              `json:"id"`
	Key                string             `json:"key"`
	DisplayNameHebrew  string             `json:"display_name_hebrew"`
	DisplayNameEnglish string             `json:"display_name_english"`
	Description        *string            `json:"description"`
	SortOrder          int16              `json:"sort_order"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
}

// Publishers are organizations (e.g., "Orthodox Union", "Chabad") that publish zmanim calculations. They are NOT users - users (people) authenticate via Clerk and can belong to multiple publishers.
type Publisher struct {
	ID int32 `json:"id"`
	// Organization name (e.g., "Orthodox Union", "Chabad of Los Angeles")
	Name string `json:"name"`
	// Public contact email for inquiries about this organization. This is NOT a login email - users authenticate via Clerk.
	ContactEmail string  `json:"contact_email"`
	Phone        *string `json:"phone"`
	// Publisher organization website URL
	Website     *string `json:"website"`
	Description *string `json:"description"`
	// Publisher organization logo (external URL)
	LogoUrl   *string     `json:"logo_url"`
	Location  interface{} `json:"location"`
	Latitude  *float64    `json:"latitude"`
	Longitude *float64    `json:"longitude"`
	Timezone  *string     `json:"timezone"`
	// Publisher verification status (pending, active, suspended, verified)
	StatusID          int16              `json:"status_id"`
	VerificationToken *string            `json:"verification_token"`
	VerifiedAt        pgtype.Timestamptz `json:"verified_at"`
	// LEGACY: Primary owner user ID from Clerk. Current system has 1:1 relationship between user and publisher. Future: Multi-user support via user_publishers junction table.
	ClerkUserID *string            `json:"clerk_user_id"`
	IsPublished bool               `json:"is_published"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	// Public-facing description of the publisher organization
	Bio  *string `json:"bio"`
	Slug *string `json:"slug"`
	// Quick check: Is this publisher verified by admin?
	IsVerified bool `json:"is_verified"`
	// Publisher organization logo (base64-encoded data URI)
	LogoData *string `json:"logo_data"`
	// Is this a certified/premium publisher?
	IsCertified      bool    `json:"is_certified"`
	SuspensionReason *string `json:"suspension_reason"`
	// Soft delete timestamp (NULL = active, timestamp = deleted)
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
	// Clerk user ID who performed soft delete
	DeletedBy *string `json:"deleted_by"`
	// When true, all zmanim calculations for this publisher ignore elevation and use 0 meters. Useful for publishers who prefer sea-level calculations.
	IgnoreElevation bool `json:"ignore_elevation"`
	// Controls English transliteration style: ashkenazi (Shabbos, Sukkos) or sephardi (Shabbat, Sukkot)
	TransliterationStyle string `json:"transliteration_style"`
	// When true, publisher provides zmanim for all localities worldwide without coverage restrictions
	IsGlobal bool `json:"is_global"`
}

type PublisherCoverage struct {
	ID                int32              `json:"id"`
	PublisherID       int32              `json:"publisher_id"`
	CoverageLevelID   int16              `json:"coverage_level_id"`
	RegionID          *int32             `json:"region_id"`
	CountryID         *int16             `json:"country_id"`
	ContinentID       *int16             `json:"continent_id"`
	IsActive          bool               `json:"is_active"`
	Priority          *int32             `json:"priority"`
	GeoLocationID     pgtype.UUID        `json:"geo_location_id"`
	CreatedByActionID pgtype.UUID        `json:"created_by_action_id"`
	UpdatedByActionID pgtype.UUID        `json:"updated_by_action_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	LocalityID        *int32             `json:"locality_id"`
}

type PublisherImportHistory struct {
	ID                int32              `json:"id"`
	PublisherID       int32              `json:"publisher_id"`
	ImportedBy        string             `json:"imported_by"`
	ImportedAt        pgtype.Timestamptz `json:"imported_at"`
	FormatType        string             `json:"format_type"`
	FormatVersion     int32              `json:"format_version"`
	SourcePublisherID *int32             `json:"source_publisher_id"`
	ZmanimCreated     int32              `json:"zmanim_created"`
	ZmanimUpdated     int32              `json:"zmanim_updated"`
	ZmanimUnchanged   int32              `json:"zmanim_unchanged"`
	ZmanimNotInImport int32              `json:"zmanim_not_in_import"`
	CoverageCreated   *int32             `json:"coverage_created"`
	CoverageUpdated   *int32             `json:"coverage_updated"`
	ProfileUpdated    *bool              `json:"profile_updated"`
	ImportSummary     []byte             `json:"import_summary"`
}

type PublisherInvitation struct {
	ID          int32              `json:"id"`
	PublisherID int32              `json:"publisher_id"`
	Email       string             `json:"email"`
	RoleID      int16              `json:"role_id"`
	Token       string             `json:"token"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	// Clerk user ID of person who created invitation
	InvitedBy string `json:"invited_by"`
	// Invitation state: pending, accepted, expired, cancelled
	Status *string `json:"status"`
	// Timestamp when invitation was accepted (NULL = not accepted)
	AcceptedAt pgtype.Timestamptz `json:"accepted_at"`
	// Timestamp of last update
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// Publisher-specific location data overrides (lat/lon/elevation only) for accurate zmanim calculations
type PublisherLocationOverride struct {
	ID          int32 `json:"id"`
	PublisherID int32 `json:"publisher_id"`
	// Override latitude in decimal degrees (-90 to 90)
	OverrideLatitude *float64 `json:"override_latitude"`
	// Override longitude in decimal degrees (-180 to 180)
	OverrideLongitude *float64 `json:"override_longitude"`
	// Override elevation in meters
	OverrideElevation *int32 `json:"override_elevation"`
	// Optional explanation for the override
	Reason     *string            `json:"reason"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
	LocalityID *int32             `json:"locality_id"`
}

type PublisherOnboarding struct {
	ID                int32              `json:"id"`
	PublisherID       int32              `json:"publisher_id"`
	ProfileComplete   *bool              `json:"profile_complete"`
	AlgorithmSelected *bool              `json:"algorithm_selected"`
	ZmanimConfigured  *bool              `json:"zmanim_configured"`
	CoverageSet       *bool              `json:"coverage_set"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

// Email verification tokens for publisher registration. Unverified requests do NOT appear in admin queue.
type PublisherRegistrationToken struct {
	ID              string `json:"id"`
	RegistrantEmail string `json:"registrant_email"`
	// JSON with publisher_name, publisher_contact_email, publisher_description
	PublisherData []byte `json:"publisher_data"`
	Token         string `json:"token"`
	Status        string `json:"status"`
	// Server-side only flag. NEVER expose to public API (prevents user enumeration attacks).
	UserExists  *bool              `json:"user_exists"`
	VerifiedAt  pgtype.Timestamptz `json:"verified_at"`
	CompletedAt pgtype.Timestamptz `json:"completed_at"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	// Applicant first name
	FirstName *string `json:"first_name"`
	// Applicant last name
	LastName *string `json:"last_name"`
	// Set if email matches existing Clerk user (server-side only)
	ExistingClerkUserID *string `json:"existing_clerk_user_id"`
	// True if user confirmed "Yes, that is me" on verification page
	ConfirmedExistingUser *bool `json:"confirmed_existing_user"`
	// Admin clerk_user_id who reviewed the application
	ReviewedBy *string `json:"reviewed_by"`
	// Timestamp of admin review
	ReviewedAt pgtype.Timestamptz `json:"reviewed_at"`
	// Admin-provided rejection reason
	RejectionMessage *string `json:"rejection_message"`
	// reCAPTCHA v3 score (0.0-1.0) for audit purposes
	RecaptchaScore pgtype.Numeric `json:"recaptcha_score"`
}

type PublisherRequest struct {
	ID           int32              `json:"id"`
	Email        string             `json:"email"`
	Name         string             `json:"name"`
	Organization *string            `json:"organization"`
	Message      *string            `json:"message"`
	StatusID     int16              `json:"status_id"`
	ReviewedBy   *string            `json:"reviewed_by"`
	ReviewedAt   pgtype.Timestamptz `json:"reviewed_at"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

type PublisherRole struct {
	ID                 int16              `json:"id"`
	Key                string             `json:"key"`
	DisplayNameHebrew  string             `json:"display_name_hebrew"`
	DisplayNameEnglish string             `json:"display_name_english"`
	Description        *string            `json:"description"`
	Permissions        []byte             `json:"permissions"`
	SortOrder          int16              `json:"sort_order"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
}

type PublisherSnapshot struct {
	ID           int32              `json:"id"`
	PublisherID  int32              `json:"publisher_id"`
	Description  *string            `json:"description"`
	SnapshotData []byte             `json:"snapshot_data"`
	CreatedBy    *string            `json:"created_by"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

type PublisherStatus struct {
	ID                 int16              `json:"id"`
	Key                string             `json:"key"`
	DisplayNameHebrew  string             `json:"display_name_hebrew"`
	DisplayNameEnglish string             `json:"display_name_english"`
	Description        *string            `json:"description"`
	Color              *string            `json:"color"`
	SortOrder          int16              `json:"sort_order"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
}

type PublisherZmanAlias struct {
	ID                   int32              `json:"id"`
	PublisherZmanID      int32              `json:"publisher_zman_id"`
	PublisherID          int32              `json:"publisher_id"`
	AliasHebrew          string             `json:"alias_hebrew"`
	AliasEnglish         *string            `json:"alias_english"`
	AliasTransliteration *string            `json:"alias_transliteration"`
	Context              *string            `json:"context"`
	IsPrimary            bool               `json:"is_primary"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
}

type PublisherZmanTag struct {
	PublisherZmanID int32              `json:"publisher_zman_id"`
	TagID           int32              `json:"tag_id"`
	IsNegated       bool               `json:"is_negated"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

type PublisherZmanVersion struct {
	ID              int32              `json:"id"`
	PublisherZmanID int32              `json:"publisher_zman_id"`
	VersionNumber   int32              `json:"version_number"`
	HebrewName      string             `json:"hebrew_name"`
	EnglishName     *string            `json:"english_name"`
	FormulaDsl      *string            `json:"formula_dsl"`
	HalachicNotes   *string            `json:"halachic_notes"`
	CreatedBy       *string            `json:"created_by"`
	ChangeReason    *string            `json:"change_reason"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

type PublisherZmanim struct {
	ID                    int32              `json:"id"`
	PublisherID           int32              `json:"publisher_id"`
	ZmanKey               string             `json:"zman_key"`
	HebrewName            string             `json:"hebrew_name"`
	EnglishName           string             `json:"english_name"`
	Transliteration       *string            `json:"transliteration"`
	Description           *string            `json:"description"`
	FormulaDsl            string             `json:"formula_dsl"`
	AiExplanation         *string            `json:"ai_explanation"`
	PublisherComment      *string            `json:"publisher_comment"`
	MasterZmanID          *int32             `json:"master_zman_id"`
	HalachicNotes         *string            `json:"halachic_notes"`
	IsEnabled             bool               `json:"is_enabled"`
	IsVisible             bool               `json:"is_visible"`
	IsPublished           bool               `json:"is_published"`
	IsBeta                bool               `json:"is_beta"`
	IsCustom              bool               `json:"is_custom"`
	TimeCategoryID        *int32             `json:"time_category_id"`
	Aliases               []string           `json:"aliases"`
	Dependencies          []string           `json:"dependencies"`
	LinkedPublisherZmanID *int32             `json:"linked_publisher_zman_id"`
	CurrentVersion        *int32             `json:"current_version"`
	CreatedByActionID     pgtype.UUID        `json:"created_by_action_id"`
	UpdatedByActionID     pgtype.UUID        `json:"updated_by_action_id"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	DeletedAt             pgtype.Timestamptz `json:"deleted_at"`
	DeletedBy             *string            `json:"deleted_by"`
	CertifiedAt           pgtype.Timestamptz `json:"certified_at"`
	DisplayNameHebrew     *string            `json:"display_name_hebrew"`
	DisplayNameEnglish    *string            `json:"display_name_english"`
	// How to round time when seconds are hidden: floor (always down), math (standard >=30s up), ceil (always up)
	RoundingMode string `json:"rounding_mode"`
	// Controls how this zman is displayed to end users:
	// - core: Always shown in zmanim display (essential times)
	// - optional: Shown by default but users can hide via preferences
	// - hidden: Not shown to users but visible to publisher in admin
	// - deleted: Soft-deleted, not visible anywhere except restore UI
	DisplayStatus DisplayStatus `json:"display_status"`
	// If this zman was copied from another publisher, the source publisher ID. Used for lineage tracking.
	CopiedFromPublisherID *int32 `json:"copied_from_publisher_id"`
	// Controls whether this zman appears in preview contexts (week view, reports).
	// When false, zman only appears in Algorithm Editor (includeInactive=true).
	// Use false for event-specific zmanim that should only show when their event is active.
	ShowInPreview bool `json:"show_in_preview"`
}

type RequestStatus struct {
	ID                 int16              `json:"id"`
	Key                string             `json:"key"`
	DisplayNameHebrew  string             `json:"display_name_hebrew"`
	DisplayNameEnglish string             `json:"display_name_english"`
	Description        *string            `json:"description"`
	Color              *string            `json:"color"`
	SortOrder          int16              `json:"sort_order"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
}

type TagType struct {
	ID                 int32              `json:"id"`
	Key                string             `json:"key"`
	DisplayNameHebrew  string             `json:"display_name_hebrew"`
	DisplayNameEnglish string             `json:"display_name_english"`
	Color              *string            `json:"color"`
	Description        *string            `json:"description"`
	SortOrder          int32              `json:"sort_order"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
}

type TimeCategory struct {
	ID                 int32              `json:"id"`
	Key                string             `json:"key"`
	DisplayNameHebrew  string             `json:"display_name_hebrew"`
	DisplayNameEnglish string             `json:"display_name_english"`
	Description        *string            `json:"description"`
	IconName           *string            `json:"icon_name"`
	Color              *string            `json:"color"`
	SortOrder          int32              `json:"sort_order"`
	IsEveryday         *bool              `json:"is_everyday"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
}

// View of all HebCal event mappings showing tag keys and their match patterns
type VHebcalEventMapping struct {
	TagKey                      string              `json:"tag_key"`
	DisplayNameEnglishAshkenazi string              `json:"display_name_english_ashkenazi"`
	HebcalMatchType             NullHebcalMatchType `json:"hebcal_match_type"`
	MatchValue                  *string             `json:"match_value"`
}

type ZmanRegistryRequest struct {
	ID                   int32              `json:"id"`
	PublisherID          int32              `json:"publisher_id"`
	RequestedKey         string             `json:"requested_key"`
	RequestedHebrewName  string             `json:"requested_hebrew_name"`
	RequestedEnglishName string             `json:"requested_english_name"`
	RequestedFormulaDsl  *string            `json:"requested_formula_dsl"`
	TimeCategoryID       int32              `json:"time_category_id"`
	StatusID             int16              `json:"status_id"`
	ReviewedBy           *string            `json:"reviewed_by"`
	ReviewedAt           pgtype.Timestamptz `json:"reviewed_at"`
	ReviewerNotes        *string            `json:"reviewer_notes"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	Transliteration      *string            `json:"transliteration"`
	Description          *string            `json:"description"`
	HalachicNotes        *string            `json:"halachic_notes"`
	HalachicSource       *string            `json:"halachic_source"`
	PublisherEmail       *string            `json:"publisher_email"`
	PublisherName        *string            `json:"publisher_name"`
	AutoAddOnApproval    *bool              `json:"auto_add_on_approval"`
}

type ZmanRequestTag struct {
	ID               int32              `json:"id"`
	RequestID        int32              `json:"request_id"`
	TagID            *int32             `json:"tag_id"`
	RequestedTagName *string            `json:"requested_tag_name"`
	RequestedTagType *string            `json:"requested_tag_type"`
	IsNewTagRequest  bool               `json:"is_new_tag_request"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

// Tags for categorizing zmanim and events. HebCal event matching is done via hebcal_match_type/string/pattern/category fields.
type ZmanTag struct {
	ID                int32              `json:"id"`
	TagKey            string             `json:"tag_key"`
	DisplayNameHebrew string             `json:"display_name_hebrew"`
	TagTypeID         int32              `json:"tag_type_id"`
	Description       *string            `json:"description"`
	Color             *string            `json:"color"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	// English display name in Ashkenazi pronunciation (e.g., Shabbos, Sukkos, Shavuos)
	DisplayNameEnglishAshkenazi string `json:"display_name_english_ashkenazi"`
	// English display name in Sephardi pronunciation (e.g., Shabbat, Sukkot, Shavuot)
	DisplayNameEnglishSephardi *string `json:"display_name_english_sephardi"`
	// Indicates if this tag should be hidden from user-facing tag selectors. Used for internal categorization tags like yom_tov, fast_day, and category_* tags.
	IsHidden bool `json:"is_hidden"`
	// How to match HebCal events: exact (string), group (regex), or NULL (not a HebCal event)
	HebcalMatchType NullHebcalMatchType `json:"hebcal_match_type"`
	// For exact matches: the exact HebCal event title (e.g., "Purim", "Yom Kippur")
	HebcalMatchString *string `json:"hebcal_match_string"`
	// For group matches: PostgreSQL regex pattern (e.g., "^Chanukah:", "^Pesach [IVX]+")
	HebcalMatchPattern *string `json:"hebcal_match_pattern"`
	// For category matches: HebCal category field (e.g., "candles", "havdalah", "parashat")
	HebcalMatchCategory *string `json:"hebcal_match_category"`
}
