// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: registration_tokens.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const approveRegistration = `-- name: ApproveRegistration :exec
UPDATE publisher_registration_tokens
SET
    status = 'approved',
    reviewed_by = $1,
    reviewed_at = NOW()
WHERE id = $2
`

type ApproveRegistrationParams struct {
	ReviewedBy *string `json:"reviewed_by"`
	ID         string  `json:"id"`
}

func (q *Queries) ApproveRegistration(ctx context.Context, arg ApproveRegistrationParams) error {
	_, err := q.db.Exec(ctx, approveRegistration, arg.ReviewedBy, arg.ID)
	return err
}

const blockEmail = `-- name: BlockEmail :exec
INSERT INTO blocked_emails (email, blocked_by, reason)
VALUES (LOWER($1::text), $2, $3)
ON CONFLICT ((LOWER(email))) DO NOTHING
`

type BlockEmailParams struct {
	Email     string  `json:"email"`
	BlockedBy string  `json:"blocked_by"`
	Reason    *string `json:"reason"`
}

func (q *Queries) BlockEmail(ctx context.Context, arg BlockEmailParams) error {
	_, err := q.db.Exec(ctx, blockEmail, arg.Email, arg.BlockedBy, arg.Reason)
	return err
}

const cancelRegistration = `-- name: CancelRegistration :exec
UPDATE publisher_registration_tokens
SET status = 'cancelled'
WHERE token = $1
`

func (q *Queries) CancelRegistration(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, cancelRegistration, token)
	return err
}

const checkPendingRegistrationByContactEmail = `-- name: CheckPendingRegistrationByContactEmail :one
SELECT EXISTS(
    SELECT 1 FROM publisher_registration_tokens
    WHERE status IN ('pending_verification', 'verified')
      AND publisher_data->>'publisher_contact_email' ILIKE $1::text
) AS exists
`

// Check if there's a pending/verified registration with this contact email
func (q *Queries) CheckPendingRegistrationByContactEmail(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, checkPendingRegistrationByContactEmail, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkPendingRegistrationByName = `-- name: CheckPendingRegistrationByName :one
SELECT EXISTS(
    SELECT 1 FROM publisher_registration_tokens
    WHERE status IN ('pending_verification', 'verified')
      AND publisher_data->>'publisher_name' ILIKE $1::text
) AS exists
`

// Check if there's a pending/verified registration with this publisher name
func (q *Queries) CheckPendingRegistrationByName(ctx context.Context, name string) (bool, error) {
	row := q.db.QueryRow(ctx, checkPendingRegistrationByName, name)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkPublisherContactEmailExists = `-- name: CheckPublisherContactEmailExists :one
SELECT EXISTS(
    SELECT 1 FROM publishers WHERE LOWER(contact_email) = LOWER($1::text)
) AS exists
`

// Check if a publisher with this contact email already exists (case-insensitive)
func (q *Queries) CheckPublisherContactEmailExists(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, checkPublisherContactEmailExists, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkPublisherNameExists = `-- name: CheckPublisherNameExists :one

SELECT EXISTS(
    SELECT 1 FROM publishers WHERE LOWER(name) = LOWER($1::text)
) AS exists
`

// =============================================================================
// DUPLICATE DETECTION
// =============================================================================
// Check if a publisher with this name already exists (case-insensitive)
func (q *Queries) CheckPublisherNameExists(ctx context.Context, name string) (bool, error) {
	row := q.db.QueryRow(ctx, checkPublisherNameExists, name)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const cleanupExpiredTokens = `-- name: CleanupExpiredTokens :execrows

UPDATE publisher_registration_tokens
SET status = 'expired'
WHERE status = 'pending_verification'
  AND expires_at < NOW()
`

// =============================================================================
// CLEANUP
// =============================================================================
// Mark pending tokens as expired
func (q *Queries) CleanupExpiredTokens(ctx context.Context) (int64, error) {
	result, err := q.db.Exec(ctx, cleanupExpiredTokens)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const confirmExistingUser = `-- name: ConfirmExistingUser :exec
UPDATE publisher_registration_tokens
SET confirmed_existing_user = true
WHERE token = $1
  AND status = 'verified'
`

func (q *Queries) ConfirmExistingUser(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, confirmExistingUser, token)
	return err
}

const createRegistrationToken = `-- name: CreateRegistrationToken :one

INSERT INTO publisher_registration_tokens (
    first_name,
    last_name,
    registrant_email,
    publisher_data,
    token,
    status,
    recaptcha_score,
    expires_at
) VALUES (
    $1,
    $2,
    LOWER($3::text),
    $4,
    $5,
    'pending_verification',
    $6,
    NOW() + INTERVAL '7 days'
) RETURNING id, registrant_email, publisher_data, token, status, user_exists, verified_at, completed_at, expires_at, created_at, first_name, last_name, existing_clerk_user_id, confirmed_existing_user, reviewed_by, reviewed_at, rejection_message, recaptcha_score
`

type CreateRegistrationTokenParams struct {
	FirstName       *string        `json:"first_name"`
	LastName        *string        `json:"last_name"`
	RegistrantEmail string         `json:"registrant_email"`
	PublisherData   []byte         `json:"publisher_data"`
	Token           string         `json:"token"`
	RecaptchaScore  pgtype.Numeric `json:"recaptcha_score"`
}

// =============================================================================
// REGISTRATION TOKEN CREATION
// =============================================================================
func (q *Queries) CreateRegistrationToken(ctx context.Context, arg CreateRegistrationTokenParams) (PublisherRegistrationToken, error) {
	row := q.db.QueryRow(ctx, createRegistrationToken,
		arg.FirstName,
		arg.LastName,
		arg.RegistrantEmail,
		arg.PublisherData,
		arg.Token,
		arg.RecaptchaScore,
	)
	var i PublisherRegistrationToken
	err := row.Scan(
		&i.ID,
		&i.RegistrantEmail,
		&i.PublisherData,
		&i.Token,
		&i.Status,
		&i.UserExists,
		&i.VerifiedAt,
		&i.CompletedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.FirstName,
		&i.LastName,
		&i.ExistingClerkUserID,
		&i.ConfirmedExistingUser,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.RejectionMessage,
		&i.RecaptchaScore,
	)
	return i, err
}

const createRegistrationTokenWithExpiry = `-- name: CreateRegistrationTokenWithExpiry :one
INSERT INTO publisher_registration_tokens (
    first_name,
    last_name,
    registrant_email,
    publisher_data,
    token,
    status,
    recaptcha_score,
    expires_at
) VALUES (
    $1,
    $2,
    LOWER($3::text),
    $4,
    $5,
    'pending_verification',
    $6,
    $7
) RETURNING id, registrant_email, publisher_data, token, status, user_exists, verified_at, completed_at, expires_at, created_at, first_name, last_name, existing_clerk_user_id, confirmed_existing_user, reviewed_by, reviewed_at, rejection_message, recaptcha_score
`

type CreateRegistrationTokenWithExpiryParams struct {
	FirstName       *string            `json:"first_name"`
	LastName        *string            `json:"last_name"`
	RegistrantEmail string             `json:"registrant_email"`
	PublisherData   []byte             `json:"publisher_data"`
	Token           string             `json:"token"`
	RecaptchaScore  pgtype.Numeric     `json:"recaptcha_score"`
	ExpiresAt       pgtype.Timestamptz `json:"expires_at"`
}

// For testing or custom expiry
func (q *Queries) CreateRegistrationTokenWithExpiry(ctx context.Context, arg CreateRegistrationTokenWithExpiryParams) (PublisherRegistrationToken, error) {
	row := q.db.QueryRow(ctx, createRegistrationTokenWithExpiry,
		arg.FirstName,
		arg.LastName,
		arg.RegistrantEmail,
		arg.PublisherData,
		arg.Token,
		arg.RecaptchaScore,
		arg.ExpiresAt,
	)
	var i PublisherRegistrationToken
	err := row.Scan(
		&i.ID,
		&i.RegistrantEmail,
		&i.PublisherData,
		&i.Token,
		&i.Status,
		&i.UserExists,
		&i.VerifiedAt,
		&i.CompletedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.FirstName,
		&i.LastName,
		&i.ExistingClerkUserID,
		&i.ConfirmedExistingUser,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.RejectionMessage,
		&i.RecaptchaScore,
	)
	return i, err
}

const deleteExpiredRegistrationTokens = `-- name: DeleteExpiredRegistrationTokens :exec
DELETE FROM publisher_registration_tokens
WHERE status IN ('expired', 'cancelled')
  AND created_at < NOW() - INTERVAL '30 days'
`

// Hard delete very old expired/cancelled tokens (30 days)
func (q *Queries) DeleteExpiredRegistrationTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredRegistrationTokens)
	return err
}

const deleteOldCompletedTokens = `-- name: DeleteOldCompletedTokens :exec
DELETE FROM publisher_registration_tokens
WHERE status IN ('completed', 'approved')
  AND completed_at < NOW() - INTERVAL '30 days'
`

func (q *Queries) DeleteOldCompletedTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteOldCompletedTokens)
	return err
}

const getBlockedEmails = `-- name: GetBlockedEmails :many
SELECT id, email, blocked_by, blocked_at, reason FROM blocked_emails
ORDER BY blocked_at DESC
`

func (q *Queries) GetBlockedEmails(ctx context.Context) ([]BlockedEmail, error) {
	rows, err := q.db.Query(ctx, getBlockedEmails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BlockedEmail{}
	for rows.Next() {
		var i BlockedEmail
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.BlockedBy,
			&i.BlockedAt,
			&i.Reason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRegistrationByEmail = `-- name: GetRegistrationByEmail :many
SELECT id, registrant_email, publisher_data, token, status, user_exists, verified_at, completed_at, expires_at, created_at, first_name, last_name, existing_clerk_user_id, confirmed_existing_user, reviewed_by, reviewed_at, rejection_message, recaptcha_score FROM publisher_registration_tokens
WHERE LOWER(registrant_email) = LOWER($1::text)
ORDER BY created_at DESC
`

// Get all registrations for an email (for duplicate detection)
func (q *Queries) GetRegistrationByEmail(ctx context.Context, email string) ([]PublisherRegistrationToken, error) {
	rows, err := q.db.Query(ctx, getRegistrationByEmail, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PublisherRegistrationToken{}
	for rows.Next() {
		var i PublisherRegistrationToken
		if err := rows.Scan(
			&i.ID,
			&i.RegistrantEmail,
			&i.PublisherData,
			&i.Token,
			&i.Status,
			&i.UserExists,
			&i.VerifiedAt,
			&i.CompletedAt,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.ExistingClerkUserID,
			&i.ConfirmedExistingUser,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.RejectionMessage,
			&i.RecaptchaScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRegistrationTokenByID = `-- name: GetRegistrationTokenByID :one
SELECT id, registrant_email, publisher_data, token, status, user_exists, verified_at, completed_at, expires_at, created_at, first_name, last_name, existing_clerk_user_id, confirmed_existing_user, reviewed_by, reviewed_at, rejection_message, recaptcha_score FROM publisher_registration_tokens
WHERE id = $1
`

func (q *Queries) GetRegistrationTokenByID(ctx context.Context, id string) (PublisherRegistrationToken, error) {
	row := q.db.QueryRow(ctx, getRegistrationTokenByID, id)
	var i PublisherRegistrationToken
	err := row.Scan(
		&i.ID,
		&i.RegistrantEmail,
		&i.PublisherData,
		&i.Token,
		&i.Status,
		&i.UserExists,
		&i.VerifiedAt,
		&i.CompletedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.FirstName,
		&i.LastName,
		&i.ExistingClerkUserID,
		&i.ConfirmedExistingUser,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.RejectionMessage,
		&i.RecaptchaScore,
	)
	return i, err
}

const getRegistrationTokenByToken = `-- name: GetRegistrationTokenByToken :one

SELECT id, registrant_email, publisher_data, token, status, user_exists, verified_at, completed_at, expires_at, created_at, first_name, last_name, existing_clerk_user_id, confirmed_existing_user, reviewed_by, reviewed_at, rejection_message, recaptcha_score FROM publisher_registration_tokens
WHERE token = $1
LIMIT 1
`

// =============================================================================
// TOKEN LOOKUP
// =============================================================================
func (q *Queries) GetRegistrationTokenByToken(ctx context.Context, token string) (PublisherRegistrationToken, error) {
	row := q.db.QueryRow(ctx, getRegistrationTokenByToken, token)
	var i PublisherRegistrationToken
	err := row.Scan(
		&i.ID,
		&i.RegistrantEmail,
		&i.PublisherData,
		&i.Token,
		&i.Status,
		&i.UserExists,
		&i.VerifiedAt,
		&i.CompletedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.FirstName,
		&i.LastName,
		&i.ExistingClerkUserID,
		&i.ConfirmedExistingUser,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.RejectionMessage,
		&i.RecaptchaScore,
	)
	return i, err
}

const getRegistrationTokenStats = `-- name: GetRegistrationTokenStats :one

SELECT
    COUNT(*) FILTER (WHERE status = 'pending_verification') as pending_count,
    COUNT(*) FILTER (WHERE status = 'verified') as verified_count,
    COUNT(*) FILTER (WHERE status = 'approved') as approved_count,
    COUNT(*) FILTER (WHERE status = 'rejected') as rejected_count,
    COUNT(*) FILTER (WHERE status = 'cancelled') as cancelled_count,
    COUNT(*) FILTER (WHERE expires_at < NOW() AND status = 'pending_verification') as expired_count
FROM publisher_registration_tokens
`

type GetRegistrationTokenStatsRow struct {
	PendingCount   int64 `json:"pending_count"`
	VerifiedCount  int64 `json:"verified_count"`
	ApprovedCount  int64 `json:"approved_count"`
	RejectedCount  int64 `json:"rejected_count"`
	CancelledCount int64 `json:"cancelled_count"`
	ExpiredCount   int64 `json:"expired_count"`
}

// =============================================================================
// STATISTICS
// =============================================================================
func (q *Queries) GetRegistrationTokenStats(ctx context.Context) (GetRegistrationTokenStatsRow, error) {
	row := q.db.QueryRow(ctx, getRegistrationTokenStats)
	var i GetRegistrationTokenStatsRow
	err := row.Scan(
		&i.PendingCount,
		&i.VerifiedCount,
		&i.ApprovedCount,
		&i.RejectedCount,
		&i.CancelledCount,
		&i.ExpiredCount,
	)
	return i, err
}

const getRegistrationsByStatus = `-- name: GetRegistrationsByStatus :many
SELECT id, registrant_email, publisher_data, token, status, user_exists, verified_at, completed_at, expires_at, created_at, first_name, last_name, existing_clerk_user_id, confirmed_existing_user, reviewed_by, reviewed_at, rejection_message, recaptcha_score FROM publisher_registration_tokens
WHERE status = $1
ORDER BY created_at DESC
`

func (q *Queries) GetRegistrationsByStatus(ctx context.Context, status string) ([]PublisherRegistrationToken, error) {
	rows, err := q.db.Query(ctx, getRegistrationsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PublisherRegistrationToken{}
	for rows.Next() {
		var i PublisherRegistrationToken
		if err := rows.Scan(
			&i.ID,
			&i.RegistrantEmail,
			&i.PublisherData,
			&i.Token,
			&i.Status,
			&i.UserExists,
			&i.VerifiedAt,
			&i.CompletedAt,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.ExistingClerkUserID,
			&i.ConfirmedExistingUser,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.RejectionMessage,
			&i.RecaptchaScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVerifiedRegistrations = `-- name: GetVerifiedRegistrations :many

SELECT id, registrant_email, publisher_data, token, status, user_exists, verified_at, completed_at, expires_at, created_at, first_name, last_name, existing_clerk_user_id, confirmed_existing_user, reviewed_by, reviewed_at, rejection_message, recaptcha_score FROM publisher_registration_tokens
WHERE status = 'verified'
ORDER BY created_at DESC
`

// =============================================================================
// ADMIN REVIEW
// =============================================================================
// Get all verified applications ready for admin review
func (q *Queries) GetVerifiedRegistrations(ctx context.Context) ([]PublisherRegistrationToken, error) {
	rows, err := q.db.Query(ctx, getVerifiedRegistrations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PublisherRegistrationToken{}
	for rows.Next() {
		var i PublisherRegistrationToken
		if err := rows.Scan(
			&i.ID,
			&i.RegistrantEmail,
			&i.PublisherData,
			&i.Token,
			&i.Status,
			&i.UserExists,
			&i.VerifiedAt,
			&i.CompletedAt,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.ExistingClerkUserID,
			&i.ConfirmedExistingUser,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.RejectionMessage,
			&i.RecaptchaScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isEmailBlocked = `-- name: IsEmailBlocked :one


SELECT EXISTS(
    SELECT 1 FROM blocked_emails WHERE LOWER(email) = LOWER($1::text)
) AS blocked
`

// ============================================================================
// Publisher Registration Tokens - SQLc Queries
// Story 8-37: Unified Publisher Onboarding Flow
// ============================================================================
// =============================================================================
// BLOCKED EMAILS
// =============================================================================
func (q *Queries) IsEmailBlocked(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, isEmailBlocked, email)
	var blocked bool
	err := row.Scan(&blocked)
	return blocked, err
}

const markTokenCompleted = `-- name: MarkTokenCompleted :exec
UPDATE publisher_registration_tokens
SET status = 'completed',
    completed_at = NOW()
WHERE token = $1
`

func (q *Queries) MarkTokenCompleted(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, markTokenCompleted, token)
	return err
}

const markTokenVerified = `-- name: MarkTokenVerified :exec

UPDATE publisher_registration_tokens
SET
    status = 'verified',
    verified_at = NOW(),
    user_exists = $1,
    existing_clerk_user_id = $2
WHERE token = $3
  AND status = 'pending_verification'
`

type MarkTokenVerifiedParams struct {
	UserExists          *bool   `json:"user_exists"`
	ExistingClerkUserID *string `json:"existing_clerk_user_id"`
	Token               string  `json:"token"`
}

// =============================================================================
// VERIFICATION FLOW
// =============================================================================
func (q *Queries) MarkTokenVerified(ctx context.Context, arg MarkTokenVerifiedParams) error {
	_, err := q.db.Exec(ctx, markTokenVerified, arg.UserExists, arg.ExistingClerkUserID, arg.Token)
	return err
}

const rejectRegistration = `-- name: RejectRegistration :exec
UPDATE publisher_registration_tokens
SET
    status = 'rejected',
    reviewed_by = $1,
    reviewed_at = NOW(),
    rejection_message = $2
WHERE id = $3
`

type RejectRegistrationParams struct {
	ReviewedBy       *string `json:"reviewed_by"`
	RejectionMessage *string `json:"rejection_message"`
	ID               string  `json:"id"`
}

func (q *Queries) RejectRegistration(ctx context.Context, arg RejectRegistrationParams) error {
	_, err := q.db.Exec(ctx, rejectRegistration, arg.ReviewedBy, arg.RejectionMessage, arg.ID)
	return err
}

const unblockEmail = `-- name: UnblockEmail :exec
DELETE FROM blocked_emails
WHERE LOWER(email) = LOWER($1::text)
`

func (q *Queries) UnblockEmail(ctx context.Context, email string) error {
	_, err := q.db.Exec(ctx, unblockEmail, email)
	return err
}

const updateRegistrationTokenStatus = `-- name: UpdateRegistrationTokenStatus :exec

UPDATE publisher_registration_tokens
SET status = $1,
    user_exists = $2,
    verified_at = CASE WHEN $1 = 'verified' THEN NOW() ELSE verified_at END,
    completed_at = CASE WHEN $1 = 'completed' OR $1 = 'approved' THEN NOW() ELSE completed_at END
WHERE token = $3
`

type UpdateRegistrationTokenStatusParams struct {
	Status     string `json:"status"`
	UserExists *bool  `json:"user_exists"`
	Token      string `json:"token"`
}

// =============================================================================
// STATUS UPDATES (Legacy compatibility + new statuses)
// =============================================================================
func (q *Queries) UpdateRegistrationTokenStatus(ctx context.Context, arg UpdateRegistrationTokenStatusParams) error {
	_, err := q.db.Exec(ctx, updateRegistrationTokenStatus, arg.Status, arg.UserExists, arg.Token)
	return err
}
